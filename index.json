[{"content":"[TOC]\n常见技巧 防止速度过快导致的平台位置偏移 void AMovingPlatform::Tick(float DeltaTime){ Super::Tick(DeltaTime); FVector CurrentLocation = GetActorLocation(); CurrentLocation = CurrentLocation + (PlatformVelocity*DeltaTime); SetActorLocation(CurrentLocation); float DistanceMoved = FVector::Dist(StartLocation, CurrentLocation); if(DistanceMoved \u0026gt; MoveDistance){ // 获得速度的单位向量 FVector MoveDirection = PlatformVelocty.GetSafeNormal(); StartLocation = StartLocation+ MoveDirection*MoveDistance; SetActorLocation(StartLocation); PlatformVelocty = -PlatformVelocty; } } 解决被方块撞击时人物视角异常的问题 这是因为只有角色默认只有在移动时才会检查碰撞\n解决方法：使用蓝图中的MoveUpdatedComponent，在每一帧都移动一个小距离再反向移动\n可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n背对光源时场景过暗的问题 在场景中加入PostProcessVolume，在Lens-Exposure-Metering Mode中，将选项改为Auto Exposure Basic，然后修改Brush中的x,y,z，令其覆盖整个场景。\n调试方法 UE_LOG 打印的格式如下：\nUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 如果使用FString格式如下\nFString Name = GetName(); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name); 绘制调试射线、球 #include \u0026#34;Engine/World.h\u0026#34; 引入该头文件获得UWorld\n#include \u0026#34;DrawDebugHelpers.h\u0026#34; DrawDebugLine(GetWorld(), Start, End, FColor::Red); DrawDebugSphere(GetWorld(), End, 10, 10, FColor::Blue, false, 5); 移动Actor 旋转平台 AddActorRotation(RotationVelocity*DeltaT) 通过C++创建SceneComponent移动物品 不同的灯光类型 名称 解释 Point Light 从一个点向外发射的光源 Spot Light 聚光灯，有方向性地发出光线 Rect Light 方形的有方向性光源 Directional Light 太阳光（只有方向，没有位置的光） Sky Light 将远处的场景作为光源 将SceneComponent添加到角色后，角色旋转和组件旋转的差异 void UGrabber::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) { Super::TickComponent(DeltaTime, TickType, ThisTickFunction); auto Rotator = GetOwner()-\u0026gt;GetActorRotation(); auto MyRotation = GetComponentRotation(); auto RotatorString = Rotator.ToCompactString(); auto MyRotationString = MyRotation.ToCompactString(); // LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75) // 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转 UE_LOG(LogTemp, Display, TEXT(\u0026#34;Owner Rotation: %s, Component Rotation: %s\u0026#34;), *RotatorString, *MyRotationString); } 其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。\n如何创建一个摄像头投射并且和特定物品交互 首先新建一个Trace Channel\n前往Project Settings-Engine-Collision在Trace Channels中新建Channel，取名叫做Grabber，默认ignore。重启编辑器\nbool UGrabber::GetGrabableInReach(FHitResult\u0026amp; OutHitResult) const { FVector Start = GetComponentLocation(); FVector End = Start + GetForwardVector()*MaxGrabDistance; DrawDebugLine(GetWorld(), Start, End, FColor::Red); FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius); bool HasHit = GetWorld()-\u0026gt;SweepSingleByChannel( OutHitResult, Start, End,FQuat::Identity, ECC_GameTraceChannel2,Sphere); return HasHit; } 这里的ECC_GameTraceChannel2就是Grabber通道，具体需要在项目目录下的/config/DefaultEngine.ini查看\nvoid UGrabber::Grab() { UPhysicsHandleComponent *PhysicsHandle = GetPhysicsHandle(); FHitResult HitResult; bool HasHit = GetGrabableInReach(HitResult); if(PhysicsHandle \u0026amp;\u0026amp; HasHit) { AActor *HitActor = HitResult.GetActor(); HitActor-\u0026gt;Tags.Add(\u0026#34;Grabbed\u0026#34;); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;The raycast has hit %s\u0026#34;), *HitActor-\u0026gt;GetActorNameOrLabel()); UPrimitiveComponent * HitComponent = HitResult.GetComponent(); HitComponent-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;GrabComponentAtLocationWithRotation( HitComponent, NAME_None, HitResult.ImpactPoint, GetComponentRotation() ); } } 其中，HitComponent-\u0026gt;WakeAllRigidBodies();的目的是为了防止部分静止时间较长的物体不在模拟物理效果，而手动进行唤醒\n要放开物品的时候代码如下：\nvoid UGrabber::Release() { UPhysicsHandleComponent* PhysicsHandle = GetPhysicsHandle(); if(PhysicsHandle \u0026amp;\u0026amp; PhysicsHandle-\u0026gt;GetGrabbedComponent()!=nullptr) { AActor* GrabbedActor = PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;GetOwner(); GrabbedActor-\u0026gt;Tags.Remove(\u0026#34;Grabbed\u0026#34;); PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;ReleaseComponent(); } } 物体碰撞关系 两个物体之间的碰撞关系依赖于两者的collision的组合：\nIgnore Overlap Block Ignore Ignore Ignore Ignore Overlap Ignore Overlap Overlap Block Ignore Overlap Block 除此以外，还需要在碰撞双方的选项中启用Generate overlap events\n依赖注入 使用场景：自己希望调用一个组件，但是自己找不到该组件（object）\n实现方式：\nUFUNCTION(BlueprintCallable) void SetMover(UMover * Mover); void UTriggerComponent::SetMover(UMover* NewMover) { Mover = NewMover; } 随后在蓝图中将Mover接到函数中\n强制转换与组件接触 Unreal中，UPrimitiveComponent是包含了物理性质的组件，而USceneComponent是其父组件，为了可以获取Actor的可能的UPrimitiveComponent，可以使用指针强制类型转换。完整强制转换与组件接触代码如下：\nUPrimitiveComponent* Component = Cast\u0026lt;UPrimitiveComponent\u0026gt;(Actor-\u0026gt;GetRootComponent()); if(Component!=nullptr) { Component-\u0026gt;SetSimulatePhysics(false); } Actor-\u0026gt;AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform); Mover-\u0026gt;SetShouldMove(true); USceneComponent 1. USceneComponent Transform: 具有变换（位置、旋转、缩放）功能。 Attachment: 可以附加到其他组件上。 视觉内容: 没有视觉内容，主要用于场景中的逻辑组织。 2. UCapsuleComponent 继承自: USceneComponent 作用: 主要用于处理碰撞检测。 3. UStaticMeshComponent 继承自: USceneComponent 作用: 主要用于视觉展示，可以加载静态网格体。 4. Actor 及其子类 包括: Pawn, Character 等。 RootComponent: 类型为 USceneComponent*，是 Actor 的根组件。 修改 RootComponent: 可以通过修改 RootComponent 来改变其类型，例如将其设置为 UCapsuleComponent。 ","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unreal-notes/","summary":"\u003cp\u003e[TOC]\u003c/p\u003e\n\u003ch2 id=\"常见技巧\"\u003e常见技巧\u003c/h2\u003e\n\u003ch3 id=\"防止速度过快导致的平台位置偏移\"\u003e防止速度过快导致的平台位置偏移\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e AMovingPlatform\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eTick(\u003cspan style=\"color:#66d9ef\"\u003efloat\u003c/span\u003e DeltaTime){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tSuper\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eTick(DeltaTime);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    FVector CurrentLocation \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e GetActorLocation();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    CurrentLocation \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e CurrentLocation \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e (PlatformVelocity\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eDeltaTime);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    SetActorLocation(CurrentLocation);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efloat\u003c/span\u003e DistanceMoved \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e FVector\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eDist(StartLocation, CurrentLocation);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e(DistanceMoved \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e MoveDistance){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 获得速度的单位向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        FVector MoveDirection \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e PlatformVelocty.GetSafeNormal();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        StartLocation \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e StartLocation\u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e MoveDirection\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eMoveDistance;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        SetActorLocation(StartLocation);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        PlatformVelocty \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003ePlatformVelocty;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"解决被方块撞击时人物视角异常的问题\"\u003e解决被方块撞击时人物视角异常的问题\u003c/h3\u003e\n\u003cp\u003e这是因为只有角色默认只有在移动时才会检查碰撞\u003c/p\u003e\n\u003cp\u003e解决方法：使用蓝图中的\u003ccode\u003eMoveUpdatedComponent\u003c/code\u003e，在每一帧都移动一个小距离再反向移动\u003c/p\u003e\n\u003cp\u003e可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003ch3 id=\"背对光源时场景过暗的问题\"\u003e背对光源时场景过暗的问题\u003c/h3\u003e\n\u003cp\u003e在场景中加入\u003ccode\u003ePostProcessVolume\u003c/code\u003e，在\u003ccode\u003eLens-Exposure-Metering Mode\u003c/code\u003e中，将选项改为\u003ccode\u003eAuto Exposure Basic\u003c/code\u003e，然后修改\u003ccode\u003eBrush\u003c/code\u003e中的x,y,z，令其覆盖整个场景。\u003c/p\u003e\n\u003ch2 id=\"调试方法\"\u003e调试方法\u003c/h2\u003e\n\u003ch3 id=\"ue_log\"\u003eUE_LOG\u003c/h3\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果使用\u003ccode\u003eFString\u003c/code\u003e格式如下\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eFString Name = GetName();\nUE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"绘制调试射线球\"\u003e绘制调试射线、球\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include \u0026#34;Engine/World.h\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e引入该头文件获得UWorld\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e#include \u0026#34;DrawDebugHelpers.h\u0026#34;\n\nDrawDebugLine(GetWorld(), Start, End, FColor::Red);\nDrawDebugSphere(GetWorld(), End, 10, 10, FColor::Blue, false, 5);\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"移动actor\"\u003e移动Actor\u003c/h2\u003e\n\u003ch3 id=\"旋转平台\"\u003e旋转平台\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eAddActorRotation(RotationVelocity*DeltaT)\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"通过c创建scenecomponent移动物品\"\u003e通过C++创建SceneComponent移动物品\u003c/h3\u003e\n\u003ch2 id=\"不同的灯光类型\"\u003e不同的灯光类型\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e名称\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e解释\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePoint Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e从一个点向外发射的光源\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSpot Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e聚光灯，有方向性地发出光线\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRect Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e方形的有方向性光源\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDirectional Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e太阳光（只有方向，没有位置的光）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSky Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将远处的场景作为光源\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"将scenecomponent添加到角色后角色旋转和组件旋转的差异\"\u003e将SceneComponent添加到角色后，角色旋转和组件旋转的差异\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e UGrabber\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eTickComponent(\u003cspan style=\"color:#66d9ef\"\u003efloat\u003c/span\u003e DeltaTime, ELevelTick TickType, FActorComponentTickFunction\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e ThisTickFunction)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tSuper\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eTickComponent(DeltaTime, TickType, ThisTickFunction);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e Rotator \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e GetOwner()\u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003eGetActorRotation();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e MyRotation \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e GetComponentRotation();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e RotatorString \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Rotator.ToCompactString();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eauto\u003c/span\u003e MyRotationString \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e MyRotation.ToCompactString();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e// LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\t\u003cspan style=\"color:#75715e\"\u003e// 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\tUE_LOG(LogTemp, Display, TEXT(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Owner Rotation: %s, Component Rotation: %s\u0026#34;\u003c/span\u003e), \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eRotatorString, \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eMyRotationString);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。\u003c/p\u003e","title":"Unreal Notes"},{"content":"[TOC]\nUE4: 将蓝图转换为C++ 教程https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c的笔记\n创建C++基类 注意点：\n可以使用蓝图继承C++，反之不行 C++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现 如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注 UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent), Blueprintable) class BLUEPRINTSTOCPP_API UGrabber : public USceneComponent { // ... }; 需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成 进行生成后，点击VS的“开始执行（不调试）”，即可重启UE 如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目 生命周期方法 对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n打印的格式如下：\nUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\nPrimaryComponentTick.bCanEverTick = false; 可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\nActor 与 Components 比较 Actors Components Can be placed in levels √ ✘ Can have components √ ✘ Modularity 低 高 Inheritance √ √ Default variable values √ √ Maintainability 低 高 Composable _ √ 我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\nUPROPERTY Defaults Instance Defaults \u0026amp; Instance Blueprint RO VisibleDefaultsOnly VisibleInstanceOnly VisibleAnywhere BlueprintReadOnly RW EditDefaultsOnly EditInstanceOnly EditAnywhere BlueprintReadWrite 如果我们想要对应的C++变量可以在其继承的蓝图中被读取（但是运行时不能修改），同时可以在蓝图中修改默认值，实例化后也可以进行修改，可以将UPROPERTY设置为\nUPROPERTY(EditAnywhere, BlueprintReadWrite) float MaxGrabDistance = 100.f; 可以被蓝图调用的UFUNCTION 蓝图和C++数据类型的对应关系：\nBlueprint C++ Float float \u0026ndash; double Integer int32 \u0026ndash; uint32 Integer64 int64 \u0026ndash; uint64 Bool bool Blueprint C++ String FString Name FName Vector FVector Rotator FRotator Transform FTransform Object UObject* Actor AActor* ActorComponent UActorComponent* 要实现一个可以被蓝图调用的C++函数，首先声明：\nUFUNCTION(BlueprintCallable, BlueprintPure) FVector GetMaxGrabLocation() const; 其中BlueprintCallable令继承该类的蓝图可以调用这个函数，BlueprintPure表示这是一个纯函数\n接下来进行相应的实现：\n#include \u0026#34;Grabber.h\u0026#34; #include \u0026#34;Kismet/KismetMathLibrary.h\u0026#34; // ... FVector UGrabber::GetMaxGrabLocation() const { return GetComponentLocation() + UKismetMathLibrary::GetForwardVector(GetComponentRotation()) * MaxGrabDistance; } 从蓝图函数找到并使用C++类方法 常用C++类：\nClass #include UWorld Engine/World.h AActor GameFramework/Actor.h UActorComponent Components/ActorComponent.h UGameplayStatics Kismet/GameplayStatics.h UKismetSystemLibrary Kismet/KismetSystemLibrary.h FMath Math/UnrealMathUtility.h 有许多蓝图方法在其对应的C++实现中名字有差别，所以要找到对应的方法，可以按照以下步骤：\nVS中，使用ctrl+ , 找到函数的Target对应的类，这个类所在的路径的最后一个子文件夹一般就是要导入头文件的时候输入的路径 将头文件输入到当前实现类的头文件时，注意不能放在#include \u0026quot;Grabber.generated.h\u0026quot;之后 对于对应的方法，可以查看许多相似的名字，其中可能有更加适合的方法，比如一个模板函数方法 使用BlueprintImplementableEvent在蓝图中实现C++ 通过在C++中声明函数的时候如以下方法注明 BlueprintImplementableEvent：\nUFUNCTION(BlueprintCallable, BlueprintImplementableEvent) void NotifyQuestActor(AActor* Actor); 在继承的蓝图中会出现相应的函数/事件，注意：这里不需要写virtual，预编译指令会进行相应的处理。\n因为这里没有返回值，在蓝图中会对应一个事件，而已经有的同名函数会报错，这里可以删除对应的函数，将相关的实现复制到事件当中。\n注意：这里的蓝图中的Access Specifier必须和C++中的对应声明的访问权限一样\n使用BlueprintImplementableEvent在蓝图中实现C++ 比较：\nBlueprintImplementableEvent No C++ implementation possible. Typically wants to be overridden. BlueprintNativeEvent Has default C++ implementation. Blueprint can call to super. Doesn’t have to be implemented in Blueprint. 实现的时候，首先如下定义头文件：\n如果对应的函数返回3个参数，一个为bool，另外两个为 Object Reference，可以使用以下方法声明C++：\nUFUNCTION(BlueprintCallable, BlueprintNativeEvent) bool TraceForPhysicsBodies(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent); 实现时需要在名字后边添加_Implementation，如下：\nbool UGrabber::TraceForPhysicsBodies_Implementation(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent) { return false; } 接着在C++蓝图中点击Override重写相关的蓝图实现即可\n注意：如果在蓝图中相关事件是private的，在C++中声明的时候应该将其放在protected中\n将蓝图Structs转成C++ USTRUCT(BlueprintType) struct BLUEPRINTSTOCPP_API FQuestInfo { GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadwrite) FString Name; UPROPERTY(EditAnywhere, BlueprintReadwrite) FName QuestId; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 Progress; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 ProgressTotal; }; 注意：结构体开头必须为F，不需要继承任何类，预编译指令 USTRUCT(BlueprintType) 表示这是一个可以在蓝图中使用的类型\n将Component转换为C++ 首先在头文件中输入\n#include \u0026#34;Particles/ParticleSystemComponent.h\u0026#34; protected: UPROPERTY(VisibleAnywhere, BlueprintReadOnly) USceneComponent* Root; UPROPERTY(VisibleAnywhere, BlueprintReadOnly) UParticleSystemComponent* ParticleSystem; UPROPERTY(VisibleAnywhere, BlueprintReadOnly)是为了在构造函数的时候让指针不知向其他位置；\n随后在cpp文件中进行实现\nAQuestMarker::AQuestMarker() { PrimaryActorTick.bCanEverTick = false; // Can only be called in constructor Root = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(TEXT(\u0026#34;SceneRoot\u0026#34;)); ParticleSystem = CreateDefaultSubobject\u0026lt;UParticleSystemComponent\u0026gt;(TEXT(\u0026#34;ParticleSystem\u0026#34;)); SetRootComponent(Root); // Can only be called in constructor ParticleSystem-\u0026gt;SetupAttachment(Root); } 注意到其中一些函数只能在构造函数中才能使用；\n创建完之后，将希望使用这个UParticleSystemComponent的蓝图Actor的父类设置为写出来的类，将对应的属性粘贴到ParticleSystem上面，修改相关的引用，最后删除原ParticleSystem\nC++实现Delegate 在 Unreal Engine 中，Delegate（委托） 和 Event（事件） 都是用于实现对象间通信的机制，但它们在设计目的、使用方式和灵活性上有显著区别。以下是详细对比：\n1. 核心概念 特性 Delegate（委托） Event（事件） 本质 一种类型安全的函数指针容器，支持动态绑定多个函数。 基于委托的封装，通常与特定游戏逻辑或引擎系统（如 Actor 生命周期）关联。 设计目的 通用的解耦通信机制，任何类均可使用。 通常用于引擎内部或特定场景（如碰撞、动画通知），提供更严格的访问控制。 绑定权限 允许外部对象绑定/解绑。 通常是单向的：只有事件拥有者可以触发，外部对象只能绑定。 2. 关键区别 (1) 绑定与触发权限 Delegate\n任何对象都可以绑定（Bind）、解绑（Unbind）或触发（Execute）委托。 例如：FOnActorClicked 委托允许任意类绑定点击回调。 Event\n只有定义事件的类可以触发（Broadcast），外部对象只能绑定。 例如：AActor::OnActorBeginOverlap 事件只能由引擎在碰撞时触发，外部代码无法直接调用。 (2) 多播能力 Delegate\n分为单播（Unicast，一对一）和多播（Multicast，一对多）。 需要显式选择类型（如 DECLARE_DELEGATE vs DECLARE_MULTICAST_DELEGATE）。 Event\n本质是多播委托的封装（隐式支持一对多）。 使用 DECLARE_EVENT 宏定义时，默认允许多个绑定。 (3) 访问控制 Delegate\n完全公开，绑定和触发无限制。 风险：可能被外部代码误触发。 Event\n通过封装实现更安全的访问控制： DECLARE_EVENT(MyClass, MyEvent) // 只有 MyClass 能触发 MyEvent.AddLambda([](){...}); // 外部仅能绑定 (4) 常见用途 Delegate\nUI 按钮回调、自定义游戏逻辑解耦。 动态绑定运行时逻辑（如技能效果）。 Event\n引擎内置行为（如 Actor 生命周期、碰撞、动画通知）。 需要严格控制的场景（如关卡加载完成事件）。 3. 代码示例 (1) Delegate 示例 // 声明一个多播委托 DECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float); class AMyActor : public AActor { public: FOnHealthChanged OnHealthChanged; void TakeDamage(float Damage) { Health -= Damage; OnHealthChanged.Broadcast(Health); // 任意触发 } }; // 外部绑定 OtherActor-\u0026gt;OnHealthChanged.AddLambda([](float Health){ ... }); (2) Event 示例 // 声明一个事件（只有 MyClass 能触发） DECLARE_EVENT(MyClass, FOnSecretEvent) class MyClass { public: FOnSecretEvent OnSecretEvent; void DoSecretThing() { OnSecretEvent.Broadcast(); // 仅限 MyClass 内部触发 } }; // 外部只能绑定 MyInstance-\u0026gt;OnSecretEvent.AddLambda([](){ ... }); 总结 维度 Delegate Event 触发权限 公开 仅限定义者 多播支持 需显式声明 默认支持 典型用途 自定义逻辑解耦 引擎内置通知 安全性 较低（需自行管理） 较高（封装触发权限） 理解两者的差异后，可以根据场景灵活选择：需要灵活性用委托，需要安全性用事件。\n实现使用C++替换Delegate 在头文件中首先声明宏\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FCompletedQuestSignature, int32, Index); 随后进行声明\nUPROPERTY(BlueprintAssignable, BlueprintCallable) FCompletedQuestSignature CompletedQuest; 如何和将要被替换的蓝图事件分配器声明一致，这时只需要在蓝图中将call的部分进行替换即可，否则需要搜索原本的Bind Event并进行逐个替换。\n在C++中进行广播和注册 要使用广播，首先在先前的Delegate声明完成之后，在需要广播的位置调用\nCompletedQuest.Broadcast(QuestIndex); 要进行注册，首先要实现绑定事件，在C++中声明并且实现一个函数，其签名和声明的Delegate一致\n// QuestMarker.h private: UFUNCTION() void QuestUpdate(int32 Index); 注意这里绑定的事件实际是一个使用UFUNCTION预编译的函数\n// QuestMarker.cpp void AQuestMarker::QuestUpdate(int32 Index) { RefreshVisibility(); } 随后在希望的位置进行绑定\nvoid AQuestMarker::BeginPlay() { GetQuestManager()-\u0026gt;CompletedQuest.AddDynamic(this, \u0026amp;AQuestMarker::QuestUpdate); RefreshVisibility(); } C++中绑定用户输入 首先创建对应类，将蓝图父类重新设置\n随后新建函数表示轴输入和Action输入\nprivate: void Forward(float AxisValue); void Jump(); 随后进行实现和绑定\n#include \u0026#34;FirstPersonCharacter.h\u0026#34; #include \u0026#34;Components/InputComponent.h\u0026#34; #include \u0026#34;GameFramework/CharacterMovementComponent.h\u0026#34; void AFirstPersonCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Forward\u0026#34;), this, \u0026amp;AFirstPersonCharacter::Forward); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Right\u0026#34;), this, \u0026amp;AFirstPersonCharacter::Right); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUp\u0026#34;), this, \u0026amp;APawn::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRight\u0026#34;), this, \u0026amp;APawn::AddControllerYawInput); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Jump\u0026#34;), IE_Pressed, this, \u0026amp;ACharacter::Jump); } void AFirstPersonCharacter::Forward(float AxisValue) { GetCharacterMovement()-\u0026gt;AddInputVector(GetActorForwardVector()* AxisValue); } void AFirstPersonCharacter::Right(float AxisValue) { GetCharacterMovement()-\u0026gt;AddInputVector(GetActorRightVector() * AxisValue); } 其中，BindAxis(TEXT(\u0026quot;Forward\u0026quot;), this, \u0026amp;AFirstPersonCharacter::Forward);中，第一个参数的名称可以在Project Setting中找到\nBindAction(TEXT(\u0026quot;Jump\u0026quot;), IE_Pressed, this, \u0026amp;AFirstPersonCharacter::Jump);中，第二个参数是一个枚举类型\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/converting-blueprint-to-c++/","summary":"\u003cp\u003e[TOC]\u003c/p\u003e\n\u003ch1 id=\"ue4-将蓝图转换为c\"\u003eUE4: 将蓝图转换为C++\u003c/h1\u003e\n\u003cp\u003e教程\u003ca href=\"https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\"\u003ehttps://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\u003c/a\u003e的笔记\u003c/p\u003e\n\u003ch2 id=\"创建c基类\"\u003e创建C++基类\u003c/h2\u003e\n\u003cp\u003e注意点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以使用蓝图继承C++，反之不行\u003c/li\u003e\n\u003cli\u003eC++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现\u003c/li\u003e\n\u003cli\u003e如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUCLASS( ClassGroup\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(Custom), meta\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(BlueprintSpawnableComponent), Blueprintable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBLUEPRINTSTOCPP_API\u003c/span\u003e UGrabber : \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e USceneComponent\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成\u003c/li\u003e\n\u003cli\u003e进行生成后，点击VS的“开始执行（不调试）”，即可重启UE\u003c/li\u003e\n\u003cli\u003e如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生命周期方法\"\u003e生命周期方法\u003c/h2\u003e\n\u003cp\u003e对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePrimaryComponentTick.bCanEverTick = false;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\u003c/p\u003e\n\u003ch2 id=\"actor-与-components-比较\"\u003eActor 与 Components 比较\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003eActors\u003c/th\u003e\n          \u003cth\u003eComponents\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan be placed in levels\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan have components\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eModularity\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInheritance\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDefault variable values\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMaintainability\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eComposable\u003c/td\u003e\n          \u003ctd\u003e_\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\u003c/p\u003e","title":"Converting Blueprint to C++"},{"content":"在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\n1. 整数输入输出 输入单个整数：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a; cin \u0026gt;\u0026gt; a; // 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); return 0; } 输入多个整数（空格分隔）：\nint a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); 输出整数：\ncout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%d\\n\u0026#34;, a); 2. 字符串输入输出 输入无空格的字符串：\nstring s; cin \u0026gt;\u0026gt; s; // 遇到空格停止 // 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s); 输入有空格的字符串（整行）：\n#include \u0026lt;string\u0026gt; string s; cin.ignore(); // 清除缓冲区残留的换行符 getline(cin, s); // 读取整行（含空格） 输出字符串：\ncout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%s\\n\u0026#34;, s.c_str()); 3. 浮点数输入输出 输入浮点数：\ndouble d; cin \u0026gt;\u0026gt; d; // 或 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); 输出有效精度固定（如3位有效数字）：\n#include \u0026lt;iomanip\u0026gt; cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 非fixed模式下为有效数字 输出小数位数固定（如2位小数）：\ncout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 固定小数点后2位 4. 混合数据输入示例 假设输入格式为：先读整数n，再读n行，每行包含一个带空格的字符串和一个浮点数：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; cin.ignore(); // 忽略换行符 while (n--) { string line; getline(cin, line); // 读取整行（如：\u0026#34;Apple Pie 3.1415\u0026#34;） // 使用字符串流分割数据 stringstream ss(line); string name, part; double value; // 提取前导字符串部分 name = \u0026#34;\u0026#34;; while (ss \u0026gt;\u0026gt; part) { if (isdigit(part[0]) || part[0] == \u0026#39;-\u0026#39; || part.find(\u0026#39;.\u0026#39;) != string::npos) { // 可能是数值，回退并提取 ss.seekg(-part.size(), ios::cur); break; } if (!name.empty()) name += \u0026#34; \u0026#34;; name += part; } ss \u0026gt;\u0026gt; value; // 提取数值 // 输出结果，保留两位小数 cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } return 0; } 关键库和函数 输入输出基础： \u0026lt;iostream\u0026gt;：提供cin、cout。 \u0026lt;cstdio\u0026gt;：提供scanf、printf（速度更快）。 字符串处理： \u0026lt;string\u0026gt;：提供string类和getline。 格式控制： \u0026lt;iomanip\u0026gt;：提供setprecision、fixed等控制符。 字符串分割： \u0026lt;sstream\u0026gt;：提供stringstream处理复杂输入。 注意事项 关闭同步流提升速度： ios::sync_with_stdio(false); cin.tie(0); // 在大量数据输入时优化性能 处理换行符残留：在cin后使用getline时，需先调用cin.ignore()。 通过灵活组合上述方法，可以高效处理ACM竞赛中的各类输入输出需求。\n","permalink":"https://wstfdxfh.github.io/posts/others/acmformat/","summary":"\u003cp\u003e在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-整数输入输出\"\u003e\u003cstrong\u003e1. 整数输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入单个整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e a;  \u003cspan style=\"color:#75715e\"\u003e// 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入多个整数（空格分隔）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a, b, c;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e c;  \u003cspan style=\"color:#75715e\"\u003e// 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;  \u003cspan style=\"color:#75715e\"\u003e// 或 printf(\u0026#34;%d\\n\u0026#34;, a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"2-字符串输入输出\"\u003e\u003cstrong\u003e2. 字符串输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入无空格的字符串\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estring s;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e s;  \u003cspan style=\"color:#75715e\"\u003e// 遇到空格停止\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入有空格的字符串（整行）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003estring s;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin.ignore();        \u003cspan style=\"color:#75715e\"\u003e// 清除缓冲区残留的换行符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003egetline(cin, s);     \u003cspan style=\"color:#75715e\"\u003e// 读取整行（含空格）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出字符串\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e s \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;  \u003cspan style=\"color:#75715e\"\u003e// 或 printf(\u0026#34;%s\\n\u0026#34;, s.c_str());\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"3-浮点数输入输出\"\u003e\u003cstrong\u003e3. 浮点数输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入浮点数\u003c/strong\u003e：\u003c/p\u003e","title":"ACMFormat"},{"content":" 可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。 #include \u0026lt;iostream\u0026gt; struct Point { double x, y; }; // 向量叉积：计算向量a × 向量b的值 double crossProduct(const Point\u0026amp; a, const Point\u0026amp; b) { return a.x * b.y - a.y * b.x; } // 检查点p1和p2是否在边a-b的同一侧（包含边上的点） bool isSameSide(const Point\u0026amp; p1, const Point\u0026amp; p2, const Point\u0026amp; a, const Point\u0026amp; b) { Point ab = {b.x - a.x, b.y - a.y}; // 边a→b的向量 Point ap1 = {p1.x - a.x, p1.y - a.y}; Point ap2 = {p2.x - a.x, p2.y - a.y}; double cp1 = crossProduct(ab, ap1); // 计算叉积AB × AP1 double cp2 = crossProduct(ab, ap2); // 计算叉积AB × AP2 return (cp1 * cp2) \u0026gt;= 0; // 符号相同或其中一个为0（点在线段上） } // 判断点P是否在三角形ABC内 bool isInsideTriangle(const Point\u0026amp; A, const Point\u0026amp; B, const Point\u0026amp; C, const Point\u0026amp; P) { return isSameSide(P, C, A, B) \u0026amp;\u0026amp; // P和C在AB同侧 isSameSide(P, A, B, C) \u0026amp;\u0026amp; // P和A在BC同侧 isSameSide(P, B, C, A); // P和B在CA同侧 } int main() { Point A = {0, 0}; Point B = {3, 0}; Point C = {1.5, 2.5}; Point P = {1.5, 10}; // 待检测点 if (isInsideTriangle(A, B, C, P)) { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形内部\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形外部\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","permalink":"https://wstfdxfh.github.io/posts/others/ispointintriangle/","summary":"\u003cul\u003e\n\u003cli\u003e可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePoint\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e x, y;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 向量叉积：计算向量a × 向量b的值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecrossProduct\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e a, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e b) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e a.x \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e b.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e b.x;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查点p1和p2是否在边a-b的同一侧（包含边上的点）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eisSameSide\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e p1, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e p2, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e a,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e b) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point ab \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {b.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, b.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};  \u003cspan style=\"color:#75715e\"\u003e// 边a→b的向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  Point ap1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {p1.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, p1.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point ap2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {p2.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, p2.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e cp1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e crossProduct(ab, ap1);  \u003cspan style=\"color:#75715e\"\u003e// 计算叉积AB × AP1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e cp2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e crossProduct(ab, ap2);  \u003cspan style=\"color:#75715e\"\u003e// 计算叉积AB × AP2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (cp1 \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e cp2) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;             \u003cspan style=\"color:#75715e\"\u003e// 符号相同或其中一个为0（点在线段上）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 判断点P是否在三角形ABC内\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eisInsideTriangle\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e A, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e B, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e C,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                      \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e P) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e isSameSide(P, C, A, B) \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// P和C在AB同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e         isSameSide(P, A, B, C) \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// P和A在BC同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e         isSameSide(P, B, C, A);    \u003cspan style=\"color:#75715e\"\u003e// P和B在CA同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point A \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point B \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point C \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e1.5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2.5\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point P \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e1.5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e};  \u003cspan style=\"color:#75715e\"\u003e// 待检测点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (isInsideTriangle(A, B, C, P)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;点P在三角形内部\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;点P在三角形外部\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"IsPointInTriangle"},{"content":"UE5快节奏横板射击对战游戏 这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\n前往Github仓库进行下载：\n该游戏项目的原创部分适用于 CC BY-NC 4.0 许可\n开发进度 已完成功能 ✅ 基础场景搭建 ✅ 初始地图设计 ✅ 基础设计系统 ✅ 增益道具系统 ✅ 基础人物角色实现 待开发功能 ⏳ 敌方 AI 系统 ⏳ 多人游戏系统 ⏳ 游戏 UI 优化 ⏳ 更多地图场景 目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\n","permalink":"https://wstfdxfh.github.io/posts/gamedev/platform-shooter/","summary":"\u003ch2 id=\"ue5快节奏横板射击对战游戏\"\u003eUE5快节奏横板射击对战游戏\u003c/h2\u003e\n\u003cp\u003e这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\u003c/p\u003e\n\u003cp\u003e前往\u003ca href=\"https://github.com/wstfdxfh/Platform-Shooter\"\u003eGithub仓库\u003c/a\u003e进行下载：\u003c/p\u003e\n\u003cp\u003e该游戏项目的原创部分适用于 \u003ca href=\"https://creativecommons.org/licenses/by-nc/4.0/\"\u003eCC BY-NC 4.0\u003c/a\u003e 许可\u003c/p\u003e\n\u003ch2 id=\"开发进度\"\u003e开发进度\u003c/h2\u003e\n\u003ch3 id=\"已完成功能\"\u003e已完成功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e✅ 基础场景搭建\u003c/li\u003e\n\u003cli\u003e✅ 初始地图设计\u003c/li\u003e\n\u003cli\u003e✅ 基础设计系统\u003c/li\u003e\n\u003cli\u003e✅ 增益道具系统\u003c/li\u003e\n\u003cli\u003e✅ 基础人物角色实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"待开发功能\"\u003e待开发功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e⏳ 敌方 AI 系统\u003c/li\u003e\n\u003cli\u003e⏳ 多人游戏系统\u003c/li\u003e\n\u003cli\u003e⏳ 游戏 UI 优化\u003c/li\u003e\n\u003cli\u003e⏳ 更多地图场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\u003c/p\u003e","title":"Platform Shooter"}]