[{"content":"在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\n1. 整数输入输出 输入单个整数：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a; cin \u0026gt;\u0026gt; a; // 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); return 0; } 输入多个整数（空格分隔）：\nint a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); 输出整数：\ncout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%d\\n\u0026#34;, a); 2. 字符串输入输出 输入无空格的字符串：\nstring s; cin \u0026gt;\u0026gt; s; // 遇到空格停止 // 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s); 输入有空格的字符串（整行）：\n#include \u0026lt;string\u0026gt; string s; cin.ignore(); // 清除缓冲区残留的换行符 getline(cin, s); // 读取整行（含空格） 输出字符串：\ncout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%s\\n\u0026#34;, s.c_str()); 3. 浮点数输入输出 输入浮点数：\ndouble d; cin \u0026gt;\u0026gt; d; // 或 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); 输出有效精度固定（如3位有效数字）：\n#include \u0026lt;iomanip\u0026gt; cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 非fixed模式下为有效数字 输出小数位数固定（如2位小数）：\ncout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 固定小数点后2位 4. 混合数据输入示例 假设输入格式为：先读整数n，再读n行，每行包含一个带空格的字符串和一个浮点数：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; cin.ignore(); // 忽略换行符 while (n--) { string line; getline(cin, line); // 读取整行（如：\u0026#34;Apple Pie 3.1415\u0026#34;） // 使用字符串流分割数据 stringstream ss(line); string name, part; double value; // 提取前导字符串部分 name = \u0026#34;\u0026#34;; while (ss \u0026gt;\u0026gt; part) { if (isdigit(part[0]) || part[0] == \u0026#39;-\u0026#39; || part.find(\u0026#39;.\u0026#39;) != string::npos) { // 可能是数值，回退并提取 ss.seekg(-part.size(), ios::cur); break; } if (!name.empty()) name += \u0026#34; \u0026#34;; name += part; } ss \u0026gt;\u0026gt; value; // 提取数值 // 输出结果，保留两位小数 cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } return 0; } 关键库和函数 输入输出基础： \u0026lt;iostream\u0026gt;：提供cin、cout。 \u0026lt;cstdio\u0026gt;：提供scanf、printf（速度更快）。 字符串处理： \u0026lt;string\u0026gt;：提供string类和getline。 格式控制： \u0026lt;iomanip\u0026gt;：提供setprecision、fixed等控制符。 字符串分割： \u0026lt;sstream\u0026gt;：提供stringstream处理复杂输入。 注意事项 关闭同步流提升速度： ios::sync_with_stdio(false); cin.tie(0); // 在大量数据输入时优化性能 处理换行符残留：在cin后使用getline时，需先调用cin.ignore()。 通过灵活组合上述方法，可以高效处理ACM竞赛中的各类输入输出需求。\n","permalink":"https://wstfdxfh.github.io/posts/others/acmformat/","summary":"\u003cp\u003e在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-整数输入输出\"\u003e\u003cstrong\u003e1. 整数输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入单个整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eusing\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enamespace\u003c/span\u003e std;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e a;  \u003cspan style=\"color:#75715e\"\u003e// 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入多个整数（空格分隔）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e a, b, c;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e b \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e c;  \u003cspan style=\"color:#75715e\"\u003e// 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;  \u003cspan style=\"color:#75715e\"\u003e// 或 printf(\u0026#34;%d\\n\u0026#34;, a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"2-字符串输入输出\"\u003e\u003cstrong\u003e2. 字符串输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入无空格的字符串\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estring s;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e s;  \u003cspan style=\"color:#75715e\"\u003e// 遇到空格停止\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入有空格的字符串（整行）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003estring s;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecin.ignore();        \u003cspan style=\"color:#75715e\"\u003e// 清除缓冲区残留的换行符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003egetline(cin, s);     \u003cspan style=\"color:#75715e\"\u003e// 读取整行（含空格）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出字符串\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e s \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e endl;  \u003cspan style=\"color:#75715e\"\u003e// 或 printf(\u0026#34;%s\\n\u0026#34;, s.c_str());\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"3-浮点数输入输出\"\u003e\u003cstrong\u003e3. 浮点数输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入浮点数\u003c/strong\u003e：\u003c/p\u003e","title":"ACMFormat"},{"content":" 可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。 #include \u0026lt;iostream\u0026gt; struct Point { double x, y; }; // 向量叉积：计算向量a × 向量b的值 double crossProduct(const Point\u0026amp; a, const Point\u0026amp; b) { return a.x * b.y - a.y * b.x; } // 检查点p1和p2是否在边a-b的同一侧（包含边上的点） bool isSameSide(const Point\u0026amp; p1, const Point\u0026amp; p2, const Point\u0026amp; a, const Point\u0026amp; b) { Point ab = {b.x - a.x, b.y - a.y}; // 边a→b的向量 Point ap1 = {p1.x - a.x, p1.y - a.y}; Point ap2 = {p2.x - a.x, p2.y - a.y}; double cp1 = crossProduct(ab, ap1); // 计算叉积AB × AP1 double cp2 = crossProduct(ab, ap2); // 计算叉积AB × AP2 return (cp1 * cp2) \u0026gt;= 0; // 符号相同或其中一个为0（点在线段上） } // 判断点P是否在三角形ABC内 bool isInsideTriangle(const Point\u0026amp; A, const Point\u0026amp; B, const Point\u0026amp; C, const Point\u0026amp; P) { return isSameSide(P, C, A, B) \u0026amp;\u0026amp; // P和C在AB同侧 isSameSide(P, A, B, C) \u0026amp;\u0026amp; // P和A在BC同侧 isSameSide(P, B, C, A); // P和B在CA同侧 } int main() { Point A = {0, 0}; Point B = {3, 0}; Point C = {1.5, 2.5}; Point P = {1.5, 10}; // 待检测点 if (isInsideTriangle(A, B, C, P)) { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形内部\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形外部\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","permalink":"https://wstfdxfh.github.io/posts/others/ispointintriangle/","summary":"\u003cul\u003e\n\u003cli\u003e可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePoint\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e x, y;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 向量叉积：计算向量a × 向量b的值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecrossProduct\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e a, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e b) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e a.x \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e b.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e b.x;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 检查点p1和p2是否在边a-b的同一侧（包含边上的点）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eisSameSide\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e p1, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e p2, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e a,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e b) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point ab \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {b.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, b.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};  \u003cspan style=\"color:#75715e\"\u003e// 边a→b的向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  Point ap1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {p1.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, p1.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point ap2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {p2.x \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.x, p2.y \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e a.y};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e cp1 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e crossProduct(ab, ap1);  \u003cspan style=\"color:#75715e\"\u003e// 计算叉积AB × AP1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003edouble\u003c/span\u003e cp2 \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e crossProduct(ab, ap2);  \u003cspan style=\"color:#75715e\"\u003e// 计算叉积AB × AP2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (cp1 \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e cp2) \u003cspan style=\"color:#f92672\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;             \u003cspan style=\"color:#75715e\"\u003e// 符号相同或其中一个为0（点在线段上）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 判断点P是否在三角形ABC内\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003ebool\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eisInsideTriangle\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e A, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e B, \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e C,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                      \u003cspan style=\"color:#66d9ef\"\u003econst\u003c/span\u003e Point\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e P) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e isSameSide(P, C, A, B) \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// P和C在AB同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e         isSameSide(P, A, B, C) \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// P和A在BC同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e         isSameSide(P, B, C, A);    \u003cspan style=\"color:#75715e\"\u003e// P和B在CA同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eint\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point A \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point B \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point C \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e1.5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2.5\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  Point P \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\u003cspan style=\"color:#ae81ff\"\u003e1.5\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e};  \u003cspan style=\"color:#75715e\"\u003e// 待检测点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (isInsideTriangle(A, B, C, P)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;点P在三角形内部\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  } \u003cspan style=\"color:#66d9ef\"\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003ecout \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;点P在三角形外部\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e std\u003cspan style=\"color:#f92672\"\u003e::\u003c/span\u003eendl;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"IsPointInTriangle"},{"content":"UE5快节奏横板射击对战游戏 这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\n前往Github仓库进行下载：\n该游戏项目的原创部分适用于 CC BY-NC 4.0 许可\n开发进度 已完成功能 ✅ 基础场景搭建 ✅ 初始地图设计 ✅ 基础设计系统 ✅ 增益道具系统 ✅ 基础人物角色实现 待开发功能 ⏳ 敌方 AI 系统 ⏳ 多人游戏系统 ⏳ 游戏 UI 优化 ⏳ 更多地图场景 目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\n","permalink":"https://wstfdxfh.github.io/posts/gamedev/platform-shooter/","summary":"\u003ch2 id=\"ue5快节奏横板射击对战游戏\"\u003eUE5快节奏横板射击对战游戏\u003c/h2\u003e\n\u003cp\u003e这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\u003c/p\u003e\n\u003cp\u003e前往\u003ca href=\"https://github.com/wstfdxfh/Platform-Shooter\"\u003eGithub仓库\u003c/a\u003e进行下载：\u003c/p\u003e\n\u003cp\u003e该游戏项目的原创部分适用于 \u003ca href=\"https://creativecommons.org/licenses/by-nc/4.0/\"\u003eCC BY-NC 4.0\u003c/a\u003e 许可\u003c/p\u003e\n\u003ch2 id=\"开发进度\"\u003e开发进度\u003c/h2\u003e\n\u003ch3 id=\"已完成功能\"\u003e已完成功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e✅ 基础场景搭建\u003c/li\u003e\n\u003cli\u003e✅ 初始地图设计\u003c/li\u003e\n\u003cli\u003e✅ 基础设计系统\u003c/li\u003e\n\u003cli\u003e✅ 增益道具系统\u003c/li\u003e\n\u003cli\u003e✅ 基础人物角色实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"待开发功能\"\u003e待开发功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e⏳ 敌方 AI 系统\u003c/li\u003e\n\u003cli\u003e⏳ 多人游戏系统\u003c/li\u003e\n\u003cli\u003e⏳ 游戏 UI 优化\u003c/li\u003e\n\u003cli\u003e⏳ 更多地图场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\u003c/p\u003e","title":"Platform Shooter"},{"content":"date: \u0026lsquo;2025-03-25T22:20:27+08:00\u0026rsquo; draft: false title: \u0026lsquo;Converting Blueprint to C++\u0026rsquo;\nUE4: 将蓝图转换为C++ 教程https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c的笔记\n创建C++基类 注意点：\n可以使用蓝图继承C++，反之不行 C++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现 如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注 UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent), Blueprintable) class BLUEPRINTSTOCPP_API UGrabber : public USceneComponent { // ... }; 需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成 进行生成后，点击VS的“开始执行（不调试）”，即可重启UE 如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目 生命周期方法 对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n打印的格式如下：\nUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\nPrimaryComponentTick.bCanEverTick = false; 可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\nActor 与 Components 比较 Actors Components Can be placed in levels √ ✘ Can have components √ ✘ Modularity 低 高 Inheritance √ √ Default variable values √ √ Maintainability 低 高 Composable _ √ 我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\nUPROPERTY Defaults Instance Defaults \u0026amp; Instance Blueprint RO VisibleDefaultsOnly VisibleInstanceOnly VisibleAnywhere BlueprintReadOnly RW EditDefaultsOnly EditInstanceOnly EditAnywhere BlueprintReadWrite 如果我们想要对应的C++变量可以在其继承的蓝图中被读取（但是运行时不能修改），同时可以在蓝图中修改默认值，实例化后也可以进行修改，可以将UPROPERTY设置为\nUPROPERTY(EditAnywhere, BlueprintReadWrite) float MaxGrabDistance = 100.f; 可以被蓝图调用的UFUNCTION 蓝图和C++数据类型的对应关系：\nBlueprint C++ Float float \u0026ndash; double Integer int32 \u0026ndash; uint32 Integer64 int64 \u0026ndash; uint64 Bool bool Blueprint C++ String FString Name FName Vector FVector Rotator FRotator Transform FTransform Object UObject* Actor AActor* ActorComponent UActorComponent* 要实现一个可以被蓝图调用的C++函数，首先声明：\nUFUNCTION(BlueprintCallable, BlueprintPure) FVector GetMaxGrabLocation() const; 其中BlueprintCallable令继承该类的蓝图可以调用这个函数，BlueprintPure表示这是一个纯函数\n接下来进行相应的实现：\n#include \u0026#34;Grabber.h\u0026#34; #include \u0026#34;Kismet/KismetMathLibrary.h\u0026#34; // ... FVector UGrabber::GetMaxGrabLocation() const { return GetComponentLocation() + UKismetMathLibrary::GetForwardVector(GetComponentRotation()) * MaxGrabDistance; } 从蓝图函数找到并使用C++类方法 常用C++类：\nClass #include UWorld Engine/World.h AActor GameFramework/Actor.h UActorComponent Components/ActorComponent.h UGameplayStatics Kismet/GameplayStatics.h UKismetSystemLibrary Kismet/KismetSystemLibrary.h FMath Math/UnrealMathUtility.h 有许多蓝图方法在其对应的C++实现中名字有差别，所以要找到对应的方法，可以按照以下步骤：\nVS中，使用ctrl+ , 找到函数的Target对应的类，这个类所在的路径的最后一个子文件夹一般就是要导入头文件的时候输入的路径 将头文件输入到当前实现类的头文件时，注意不能放在#include \u0026quot;Grabber.generated.h\u0026quot;之后 对于对应的方法，可以查看许多相似的名字，其中可能有更加适合的方法，比如一个模板函数方法 使用BlueprintImplementableEvent在蓝图中实现C++ 通过在C++中声明函数的时候如以下方法注明 BlueprintImplementableEvent：\nUFUNCTION(BlueprintCallable, BlueprintImplementableEvent) void NotifyQuestActor(AActor* Actor); 在继承的蓝图中会出现相应的函数/事件，注意：这里不需要写virtual，预编译指令会进行相应的处理。\n因为这里没有返回值，在蓝图中会对应一个事件，而已经有的同名函数会报错，这里可以删除对应的函数，将相关的实现复制到事件当中。\n注意：这里的蓝图中的Access Specifier必须和C++中的对应声明的访问权限一样\n使用BlueprintImplementableEvent在蓝图中实现C++ 比较：\nBlueprintImplementableEvent No C++ implementation possible. Typically wants to be overridden. BlueprintNativeEvent Has default C++ implementation. Blueprint can call to super. Doesn’t have to be implemented in Blueprint. 实现的时候，首先如下定义头文件：\n如果对应的函数返回3个参数，一个为bool，另外两个为 Object Reference，可以使用以下方法声明C++：\nUFUNCTION(BlueprintCallable, BlueprintNativeEvent) bool TraceForPhysicsBodies(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent); 实现时需要在名字后边添加_Implementation，如下：\nbool UGrabber::TraceForPhysicsBodies_Implementation(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent) { return false; } 接着在C++蓝图中点击Override重写相关的蓝图实现即可\n将蓝图Structs转成C++ USTRUCT(BlueprintType) struct BLUEPRINTSTOCPP_API FQuestInfo { GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadwrite) FString Name; UPROPERTY(EditAnywhere, BlueprintReadwrite) FName QuestId; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 Progress; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 ProgressTotal; }; 注意：结构体开头必须为F，不需要继承任何类，预编译指令 USTRUCT(BlueprintType) 表示这是一个可以在蓝图中使用的类型\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/converting-blueprint-to-c++/","summary":"\u003cp\u003edate: \u0026lsquo;2025-03-25T22:20:27+08:00\u0026rsquo;\ndraft: false\ntitle: \u0026lsquo;Converting Blueprint to C++\u0026rsquo;\u003c/p\u003e\n\u003ch1 id=\"ue4-将蓝图转换为c\"\u003eUE4: 将蓝图转换为C++\u003c/h1\u003e\n\u003cp\u003e教程\u003ca href=\"https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\"\u003ehttps://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\u003c/a\u003e的笔记\u003c/p\u003e\n\u003ch2 id=\"创建c基类\"\u003e创建C++基类\u003c/h2\u003e\n\u003cp\u003e注意点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以使用蓝图继承C++，反之不行\u003c/li\u003e\n\u003cli\u003eC++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现\u003c/li\u003e\n\u003cli\u003e如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eUCLASS( ClassGroup\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(Custom), meta\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e(BlueprintSpawnableComponent), Blueprintable)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBLUEPRINTSTOCPP_API\u003c/span\u003e UGrabber : \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e USceneComponent\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e};\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成\u003c/li\u003e\n\u003cli\u003e进行生成后，点击VS的“开始执行（不调试）”，即可重启UE\u003c/li\u003e\n\u003cli\u003e如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生命周期方法\"\u003e生命周期方法\u003c/h2\u003e\n\u003cp\u003e对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePrimaryComponentTick.bCanEverTick = false;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\u003c/p\u003e\n\u003ch2 id=\"actor-与-components-比较\"\u003eActor 与 Components 比较\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003eActors\u003c/th\u003e\n          \u003cth\u003eComponents\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan be placed in levels\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan have components\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eModularity\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInheritance\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDefault variable values\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMaintainability\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eComposable\u003c/td\u003e\n          \u003ctd\u003e_\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\u003c/p\u003e","title":""}]