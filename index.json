[{"content":"本文简要介绍实时渲染的基础数学知识，渲染管线，以及面试常见问题\n数学基础 坐标表示 在三维计算机图形学中，我们通常使用**齐次坐标（Homogeneous Coordinates）**来表示点和向量。\n三维空间点变换时为什么需要齐次坐标？\n这主要是为了解决“平移”运算的线性化问题。在普通的三维笛卡尔坐标系中，旋转和缩放可以通过 $3 \\times 3$ 矩阵与向量相乘（线性变换）来实现，但平移仅仅是向量的加法，无法合并进同一个 $3 \\times 3$ 矩阵乘法中。\n通过引入第四个分量 $w$，将三维向量 $(x, y, z)$ 扩展为四维向量 $(x, y, z, w)$，我们就能够将平移、旋转和缩放全部统一到一个 $4 \\times 4$ 的矩阵乘法运算中。对于点，通常设置 $w=1$，表示位置；对于方向向量，设置 $w=0$，意味着它不受平移影响（因为方向只有朝向和大小，没有具体位置）。这种统一性使得图形硬件（GPU）能够用一套通用的逻辑快速处理所有类型的变换。\n物体变换矩阵 物体变换通常涉及三个基础操作：平移（Translation）、旋转（Rotation）和缩放（Scale）。\n平移、缩放、旋转物体变换矩阵分别是？\n平移矩阵：基于齐次坐标，我们将平移量 $(t_x, t_y, t_z)$ 放在矩阵的最后一列。 $$ T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n缩放矩阵：缩放因子 $(s_x, s_y, s_z)$ 位于矩阵的对角线上。 $$ S = \\begin{bmatrix} s_x \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; s_y \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; s_z \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n旋转矩阵：绕主轴的旋转稍微复杂一些。例如，绕 Z 轴旋转 $\\theta$ 角的矩阵为： $$ R_z(\\theta) = \\begin{bmatrix} \\cos\\theta \u0026amp; -\\sin\\theta \u0026amp; 0 \u0026amp; 0 \\ \\sin\\theta \u0026amp; \\cos\\theta \u0026amp; 0 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} $$\n绕 X 轴和 Y 轴的旋转矩阵结构类似，只是正余弦项的位置不同。\n有什么缩小矩阵运算的技巧？\n最核心的技巧是矩阵级联（Matrix Concatenation）。由于矩阵乘法满足结合律（但不满足交换律），如果我们有一系列的变换（例如先缩放 $S$，再旋转 $R$，最后平移 $T$），我们不需要对场景中的几百万个顶点依次进行三次矩阵乘法。\n我们可以预先计算出一个“模型矩阵” $M = T \\times R \\times S$。这样，对于每一个顶点 $v$，只需要计算一次 $v\u0026rsquo; = M \\times v$ 即可。这极大地减少了计算量。此外，对于视图变换和投影变换，也可以继续合并，形成最终的 $MVP$（Model-View-Projection）矩阵。\n四元数基础 在处理旋转时，除了矩阵和欧拉角，四元数（Quaternion）是实时渲染中非常重要的工具，特别是在动画插值方面。\n什么是单位四元数？\n四元数是由一个实部和三个虚部构成的复数扩展，形式为 $q = w + xi + yj + zk$。当四元数的模长（Norm）为 1 时，它被称为单位四元数。在计算机图形学中，我们只使用单位四元数来表示旋转。\n四元数怎么表示物体的多少旋转？\n四元数通过“轴-角”对来直观地描述旋转。假设你想绕着一个单位向量轴 $$ \\mathbf{u} = (u_x, u_y, u_z) $$ 旋转角度 $\\theta$，对应的四元数表示为：\n$$ q = (\\cos(\\frac{\\theta}{2}), \\sin(\\frac{\\theta}{2})\\mathbf{u}) $$\n即 $$ w = \\cos(\\frac{\\theta}{2}) $$ ，而虚部向量 $$ (x, y, z) = \\sin(\\frac{\\theta}{2}) \\cdot (u_x, u_y, u_z) $$ 。相比于欧拉角，四元数避免了“万向节死锁”（Gimbal Lock）问题，并且计算效率较高。\n其他表示物体平移旋转缩放的方式 除了矩阵变换，还有哪种计算物体平移旋转缩放变换的方法？\n另一种常见的方法是TRS 分量表示法（或者叫变换分解法）。即不直接存储一个 $4 \\times 4$ 矩阵，而是将物体的状态数据结构化存储为三个独立的分量：\n位置向量（Position，Vector3） 旋转四元数（Rotation，Quaternion） 缩放向量（Scale，Vector3） 两种方法的适用情景是？\nTRS 分量法（适用于 CPU 端的逻辑与动画）：\n当需要对物体进行物理模拟、碰撞检测或者动画插值时，TRS 是首选。因为矩阵很难直接进行线性插值（两个旋转矩阵相加再平均，结果往往不再是旋转矩阵），而位置向量可以进行线性插值（Lerp），四元数可以进行球面线性插值（Slerp），这能产生平滑自然的动画过渡。\n矩阵法（适用于 GPU 端的渲染）：\n当数据准备好要发送给显卡进行顶点着色时，矩阵是绝对的标准。因为 GPU 的硬件设计就是为了并行处理大规模的矩阵向量乘法。通常的做法是：在 CPU 端维护 TRS 状态，每帧更新后计算出对应的 Model Matrix，然后传给 GPU。\n法线变换 法线（Normal）是垂直于物体表面的方向向量，用于光照计算。它在变换时需要特殊处理。\n什么情况下法线变换和普通的坐标变换相同？\n当变换矩阵仅包含平移、旋转和统一缩放（Uniform Scale，即 $x,y,z$ 轴缩放倍数相等）时，法线变换矩阵与物体变换矩阵是一致的（或者说仅差一个缩放系数，归一化后就相同了）。这是因为旋转和统一缩放保持了角度的正交性。\n为什么一般情况下不能使用普通的坐标变换？\n当物体发生非统一缩放（Non-uniform Scale）时，普通变换会破坏法线的垂直性。\n举个例子：如果你将一个球体在 Y 轴方向压扁，表面上的切线向量会随之变得平缓，如果你直接用同样的矩阵去变换法线，法线也会在 Y 轴上被“压扁”，结果就是法线不再垂直于压扁后的表面，导致光照计算错误。\n为了修正这个问题，我们使用物体变换矩阵的**逆转置矩阵（Inverse Transpose Matrix）**来变换法线。即，如果模型矩阵是 $M$，那么专门用于法线的变换矩阵 $N$ 应该是：\n$$ N = (M^{-1})^T $$\n这个数学推导保证了变换后的法线依然与变换后的表面切线保持垂直。\n渲染管线 渲染管线示意图如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 graph TD %% 定义样式 classDef prog fill:#76c776,stroke:#333,stroke-width:2px,color:white; classDef fixed fill:#7ab8e8,stroke:#333,stroke-width:2px,color:white; classDef data fill:#e0e0e0,stroke:#999,stroke-dasharray: 5 5,color:black; %% ================= CPU 阶段 ================= subgraph Host [CPU 主机端] App[\u0026#34;应用程序 / 游戏逻辑\u0026#34;] --\u0026gt; API调用[\u0026#34;图形 API (DirectX/Vulkan/OpenGL)\u0026#34;] end API调用 --\u0026gt; CommandBuffer(\u0026#34;命令缓冲区 \u0026amp; 顶点数据\u0026#34;):::data CommandBuffer -- \u0026#34;GPU 读取命令\u0026#34; --\u0026gt; GPUFrontEnd[\u0026#34;GPU 前端 / 命令处理器\u0026#34;]:::fixed %% ================= 几何处理阶段 ================= subgraph GeometryPhase [\u0026#34;GPU: 几何处理阶段\u0026#34;] GPUFrontEnd --\u0026gt; InputAssembler[\u0026#34;输入装配器 (IA) \u0026amp; 顶点读取\u0026#34;]:::fixed InputAssembler -- \u0026#34;顶点流\u0026#34; --\u0026gt; VS[\u0026#34;顶点着色器 (Vertex Shader)\u0026#34;]:::prog %% 细分曲面子流程 VS --\u0026gt; TessCheck{\u0026#34;启用细分曲面?\u0026#34;} subgraph Tessellation [\u0026#34;可选: 细分曲面阶段\u0026#34;] TessCheck -- Yes --\u0026gt; TCS[\u0026#34;细分控制着色器 (Hull Shader)\u0026#34;]:::prog TCS -- \u0026#34;控制点 \u0026amp; 细分因子\u0026#34; --\u0026gt; Tessellator[\u0026#34;细分器硬件单元\u0026#34;]:::fixed Tessellator -- \u0026#34;生成的域点\u0026#34; --\u0026gt; TES[\u0026#34;细分评估着色器 (Domain Shader)\u0026#34;]:::prog end TessCheck -- No --\u0026gt; GSCheck TES --\u0026gt; GSCheck %% 几何着色器子流程 GSCheck{\u0026#34;启用几何着色器?\u0026#34;} subgraph GeometryShaderStage [\u0026#34;可选: 几何着色器阶段\u0026#34;] GSCheck -- Yes --\u0026gt; GS[\u0026#34;几何着色器 (Geometry Shader)\u0026#34;]:::prog end GSCheck -- No --\u0026gt; PrimitiveAssembly GS --\u0026gt; PrimitiveAssembly PrimitiveAssembly[\u0026#34;图元装配 \u0026amp; 变换反馈 (Transform Feedback)\u0026#34;]:::fixed end %% ================= 光栅化阶段 ================= subgraph RasterizationPhase [\u0026#34;GPU: 光栅化阶段\u0026#34;] PrimitiveAssembly --\u0026#34;图元(三角形/线)\u0026#34;--\u0026gt; Clipping[\u0026#34;裁剪 (Clipping) \u0026amp; 屏幕映射\u0026#34;]:::fixed Clipping --\u0026gt; Rasterizer[\u0026#34;光栅化器 (三角形遍历 \u0026amp; 插值)\u0026#34;]:::fixed Rasterizer -- \u0026#34;Early-Z 测试\u0026#34; --\u0026gt; PreFS_Depth[\u0026#34;早期深度/模板测试\u0026#34;]:::fixed end %% ================= 像素处理阶段 ================= Rasterizer -- \u0026#34;生成的片段(Fragment)流\u0026#34; --\u0026gt; FragmentPhase subgraph FragmentPhase [\u0026#34;GPU: 像素/片段处理阶段\u0026#34;] PreFS_Depth --\u0026gt; FS[\u0026#34;片段着色器 (Fragment/Pixel Shader)\u0026#34;]:::prog Textures(\u0026#34;纹理/资源\u0026#34;):::data -.-\u0026gt; FS end %% ================= 输出合并阶段 ================= subgraph OutputMergerPhase [\u0026#34;GPU: 输出合并阶段 (ROP)\u0026#34;] FS -- \u0026#34;片段颜色 \u0026amp; 深度值\u0026#34; --\u0026gt; LateDepthStencil[\u0026#34;后期深度/模板测试\u0026#34;]:::fixed LateDepthStencil --\u0026gt; Blending[\u0026#34;颜色混合 (Blending)\u0026#34;]:::fixed end Blending -- \u0026#34;最终像素写入\u0026#34; --\u0026gt; Framebuffer(\u0026#34;帧缓冲区 / Render Targets\u0026#34;):::data %% ================= 图例 ================= subgraph Legend [\u0026#34;图例说明\u0026#34;] L1[\u0026#34;完全可编程 Shader 核心\u0026#34;]:::prog L2[\u0026#34;固定功能硬件单元 (可配置)\u0026#34;]:::fixed L3(\u0026#34;数据缓冲区 / 内存\u0026#34;):::data end ","permalink":"https://wstfdxfh.github.io/posts/cheetsheets/realtimerendering/","summary":"\u003cp\u003e本文简要介绍实时渲染的基础数学知识，渲染管线，以及面试常见问题\u003c/p\u003e\n\u003ch2 id=\"数学基础\"\u003e数学基础\u003c/h2\u003e\n\u003ch3 id=\"坐标表示\"\u003e坐标表示\u003c/h3\u003e\n\u003cp\u003e在三维计算机图形学中，我们通常使用**齐次坐标（Homogeneous Coordinates）**来表示点和向量。\u003c/p\u003e\n\u003cp\u003e三维空间点变换时为什么需要齐次坐标？\u003c/p\u003e\n\u003cp\u003e这主要是为了解决“平移”运算的线性化问题。在普通的三维笛卡尔坐标系中，旋转和缩放可以通过 $3 \\times 3$ 矩阵与向量相乘（线性变换）来实现，但平移仅仅是向量的加法，无法合并进同一个 $3 \\times 3$ 矩阵乘法中。\u003c/p\u003e\n\u003cp\u003e通过引入第四个分量 $w$，将三维向量 $(x, y, z)$ 扩展为四维向量 $(x, y, z, w)$，我们就能够将平移、旋转和缩放全部统一到一个 $4 \\times 4$ 的矩阵乘法运算中。对于点，通常设置 $w=1$，表示位置；对于方向向量，设置 $w=0$，意味着它不受平移影响（因为方向只有朝向和大小，没有具体位置）。这种统一性使得图形硬件（GPU）能够用一套通用的逻辑快速处理所有类型的变换。\u003c/p\u003e\n\u003ch3 id=\"物体变换矩阵\"\u003e物体变换矩阵\u003c/h3\u003e\n\u003cp\u003e物体变换通常涉及三个基础操作：平移（Translation）、旋转（Rotation）和缩放（Scale）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e平移、缩放、旋转物体变换矩阵分别是？\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e平移矩阵\u003c/strong\u003e：基于齐次坐标，我们将平移量 $(t_x, t_y, t_z)$ 放在矩阵的最后一列。\n$$\nT = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_x \\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_y \\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_z \\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}\n$$\u003c/p\u003e","title":"RealtimeRendering"},{"content":"一款多人设计游戏的Demo，使用UnrealOnlineSubSystemSteam实现互联网双人联机\n游戏包含开始界面，等待大厅和正式游戏关卡，在关卡开始之前，玩家可以飞行浏览地图\n游戏开始后，玩家可以拾取地图上的武器，包括步枪和火箭筒，进行对抗\nHUD上记录了击杀数和被击败的次数，通过人头数量决定最后的胜者。\n相关内容参考 相关课程，UE5.5进行开发。相关开发笔记可以参见Unreal网络多人开发和Unreal版本控制等\n下载链接\n注意，游玩时，需要两台不同的电脑主机，各自登录不同的Steam账号；\n点击开始界面的Host主持游戏作为Listen Server，另一台点击加入后作为Client\n因为使用Steam的公用ID，在高峰期可能会出现连接缓慢或者无法加入的问题。\n附多人游戏截图：\n改进笔记 以下将改进的部分内容列在下方：\n源代码中，使用一个自定义的RocketMovementComponent解决火箭弹会在接触自己的时候爆炸的问题，而改进后只需要使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void AProjectile::BeginPlay() { Super::BeginPlay(); if(Tracer) { TracerComponent = UGameplayStatics::SpawnEmitterAttached(Tracer, CollisionBox, NAME_None, GetActorLocation(), GetActorRotation(), EAttachLocation::KeepWorldPosition); } if(HasAuthority()) { CollisionBox-\u0026gt;OnComponentHit.AddDynamic(this, \u0026amp;AProjectile::OnHit); CollisionBox-\u0026gt;IgnoreActorWhenMoving(Owner, true); } } 通过添加CollisionBox-\u0026gt;IgnoreActorWhenMoving(Owner, true);实现\n","permalink":"https://wstfdxfh.github.io/posts/myworks/multiplayerdemo/","summary":"\u003cp\u003e一款多人设计游戏的Demo，使用UnrealOnlineSubSystemSteam实现互联网双人联机\u003c/p\u003e\n\u003cp\u003e游戏包含开始界面，等待大厅和正式游戏关卡，在关卡开始之前，玩家可以飞行浏览地图\u003c/p\u003e\n\u003cp\u003e游戏开始后，玩家可以拾取地图上的武器，包括步枪和火箭筒，进行对抗\u003c/p\u003e\n\u003cp\u003eHUD上记录了击杀数和被击败的次数，通过人头数量决定最后的胜者。\u003c/p\u003e\n\u003cp\u003e相关内容参考 \u003ca href=\"https://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter\"\u003e相关课程\u003c/a\u003e，UE5.5进行开发。相关开发笔记可以参见\u003ca href=\"/posts/UnrealEngine/UnrealOnline/\"\u003eUnreal网络多人开发\u003c/a\u003e和\u003ca href=\"/posts/UnrealEngine/UnrealVersionControl/\"\u003eUnreal版本控制\u003c/a\u003e等\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/wstfdxfh/UnealOnlineDemo/releases/tag/v1.0.0\"\u003e下载链接\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e，游玩时，需要两台不同的电脑主机，各自登录不同的Steam账号；\u003c/p\u003e\n\u003cp\u003e点击开始界面的Host主持游戏作为Listen Server，另一台点击加入后作为Client\u003c/p\u003e\n\u003cp\u003e因为使用Steam的公用ID，在高峰期可能会出现连接缓慢或者无法加入的问题。\u003c/p\u003e\n\u003cp\u003e附多人游戏截图：\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003ch2 id=\"改进笔记\"\u003e改进笔记\u003c/h2\u003e\n\u003cp\u003e以下将改进的部分内容列在下方：\u003c/p\u003e\n\u003cp\u003e源代码中，使用一个自定义的RocketMovementComponent解决火箭弹会在接触自己的时候爆炸的问题，而改进后只需要使用\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eAProjectile\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eBeginPlay\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eBeginPlay\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTracer\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eTracerComponent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eUGameplayStatics\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eSpawnEmitterAttached\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTracer\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCollisionBox\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNAME_None\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eGetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003eGetActorRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                                \u003cspan class=\"n\"\u003eEAttachLocation\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eKeepWorldPosition\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eHasAuthority\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCollisionBox\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eOnComponentHit\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAddDynamic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eAProjectile\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eOnHit\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCollisionBox\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIgnoreActorWhenMoving\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOwner\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e通过添加\u003ccode\u003eCollisionBox-\u0026gt;IgnoreActorWhenMoving(Owner, true);\u003c/code\u003e实现\u003c/p\u003e","title":"MultiPlayerDemo"},{"content":"Unreal版本管理 本文简单介绍如何通过Git LFS+阿里云Codeup进行Unreal项目内容的版本管理\n使用阿里云Codeup的原因是因为其LFS拥有比较大的免费空间，也可以使用其他平台，比如Github, GitLab或者云服务器+GitLab。\n1. 下载Git 和Git LFS https://git-scm.com/\nhttps://git-lfs.com/\n2.创建一个Codeup代码库 3.在本地创建SSH的公钥和私钥，将公钥上传到Codeup（可选） https://help.aliyun.com/zh/yunxiao/user-guide/configure-ssh-key\n首先查看已经存在的SSH秘钥，在Git Bash或者Windows WSL中输入\n1 2 cat ~/.ssh/id_ed25519.pub cat ~/.ssh/id_rsa.pub 查看是否有ed25519秘钥或者rsa秘钥，如果没有，就输入\n1 ssh-keygen -t ed25519 -C \u0026#34;\u0026lt;注释内容\u0026gt;\u0026#34; 或者\n1 ssh-keygen -t rsa -C \u0026#34;\u0026lt;注释内容\u0026gt;\u0026#34; 进行创建，注释内容可以是邮箱地址\n1 2 Generating public/private ed25519 key pair. Enter file in which to save the key (/home/user/.ssh/id_ed25519): 密钥默认生成路径：/home/user/.ssh/id_ed25519，公钥与之对应为：/home/user/.ssh/id_ed25519.pub\n1 2 Enter passphrase (empty for no passphrase): Enter same passphrase again: 秘钥口令默认为空\n1 cat ~/.ssh/id_ed25519.pub | clip 将秘钥复制到剪贴板，最后在codeup上的设置界面设置公钥。\n如果在克隆或者推送过程中出现Host key verification failed. fatal: Could not read from remote repository.等错误，就需要进行ssh配置，输入\n1 code ~/.ssh/config 进行编辑，输入\n1 2 3 4 5 6 Host codeup.aliyun.com HostName codeup.aliyun.com Port 22 # 默认SSH端口，如有特殊端口需修改 User git IdentityFile ~/.ssh/id_ed25519 # 指定私钥路径 IdentitiesOnly yes # 强制使用指定密钥 进行秘钥配置，随后即可正常拉取和上传文件\n由于也可以使用HTTP(S)进行下载和上传，所以不是必须内容\n4. 克隆项目 通过Git GUI进行克隆，或者通过git bash或者命令行输入\n1 git clone git@codeup.aliyun.com:6844ea9006a2c55225caea98/OddTanks.git my-project 进行克隆，其中my-project是表示存放目录的可选项\n5. 在Unreal中添加并且配置Git-LFS 点击右下角的Version Control，进行以下设置：\n其中，URL表示远程项目的HTTP地址，可以在\n查看。\n初始化成功后，在Github Disktop或者Git GUI中添加文件夹，并且在Git Bash中对大文件进行指定配置\n1 2 3 4 git lfs install cd \u0026#34;E:\\CodeRepository\\Blasters\u0026#34; git lfs track \u0026#34;*.uasset\u0026#34; git lfs track \u0026#34;*.umap\u0026#34; 6.提交和推送项目 可以在Github Desktop中对项目进行提交，进行推送的时候，需要用户名和密码，Codeup的用户名在用户设置如下：\n进行提交之前，首先需要拉取远程更改\n首先建立远程分支和当前分支的联系\n1 git branch --set-upstream-to=origin/master master 弹出以上弹窗是因为两个仓库各自进行了初始化，如果不需要保留远程初始化的内容的话可以直接进行强制push，或者使用\n1 git pull origin master --allow-unrelated-histories 强制拉取远程历史，并且解决冲突。\n随后就可以将当前内容push到远程分支\n注意：拉取内容或者其他任何可能改变当前工作区的内容时，必须关闭Unreal\n7.清除暂存内容，回退到上一次编辑结果 点击Discard all changes即可清除内容，回退到上一次编辑结果，但是要注意，必须关闭unreal进行相关操作。\n8.回退到某个分支 1 2 3 4 5 6 7 8 9 10 # 1. 查看提交历史，找到目标提交的哈希（如 abc1234） git log --oneline # 2. 混合重置（保留更改，但撤销暂存）HEAD 和暂存区回退，但工作区的文件修改保留（需重新 git add） git reset --mixed \u0026lt;commit-hash\u0026gt; # --mixed 是默认选项，可省略 # 2. 硬重置到该提交 所有未提交的修改和之后的提交都会被删除！ git reset --hard abc1234 # 3. 强制推送到远程（如需） git push --force origin main ","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unrealversioncontrol/","summary":"\u003ch2 id=\"unreal版本管理\"\u003eUnreal版本管理\u003c/h2\u003e\n\u003cp\u003e本文简单介绍如何通过Git LFS+阿里云Codeup进行Unreal项目内容的版本管理\u003c/p\u003e\n\u003cp\u003e使用阿里云Codeup的原因是因为其LFS拥有比较大的免费空间，也可以使用其他平台，比如Github, GitLab或者云服务器+GitLab。\u003c/p\u003e\n\u003ch2 id=\"1-下载git-和git-lfs\"\u003e1. 下载Git 和Git LFS\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://git-scm.com/\"\u003ehttps://git-scm.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://git-lfs.com/\"\u003ehttps://git-lfs.com/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"2创建一个codeup代码库\"\u003e2.创建一个Codeup代码库\u003c/h2\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250608175403555\" loading=\"lazy\" src=\"/posts/unrealengine/unrealversioncontrol/image-20250608175403555.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"3在本地创建ssh的公钥和私钥将公钥上传到codeup可选\"\u003e3.在本地创建SSH的公钥和私钥，将公钥上传到Codeup（可选）\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://help.aliyun.com/zh/yunxiao/user-guide/configure-ssh-key\"\u003ehttps://help.aliyun.com/zh/yunxiao/user-guide/configure-ssh-key\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e首先查看已经存在的SSH秘钥，在Git Bash或者Windows WSL中输入\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat ~/.ssh/id_ed25519.pub\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat ~/.ssh/id_rsa.pub\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e查看是否有ed25519秘钥或者rsa秘钥，如果没有，就输入\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t ed25519 -C \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;注释内容\u0026gt;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e或者\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003essh-keygen -t rsa -C \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;注释内容\u0026gt;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e进行创建，注释内容可以是邮箱地址\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eGenerating public/private ed25519 key pair.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter file in which to save the key \u003cspan class=\"o\"\u003e(\u003c/span\u003e/home/user/.ssh/id_ed25519\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e密钥默认生成路径：\u003ccode\u003e/home/user/.ssh/id_ed25519\u003c/code\u003e，公钥与之对应为：\u003ccode\u003e/home/user/.ssh/id_ed25519.pub\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter passphrase \u003cspan class=\"o\"\u003e(\u003c/span\u003eempty \u003cspan class=\"k\"\u003efor\u003c/span\u003e no passphrase\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eEnter same passphrase again:\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e秘钥口令默认为空\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ecat ~/.ssh/id_ed25519.pub \u003cspan class=\"p\"\u003e|\u003c/span\u003e clip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e将秘钥复制到剪贴板，最后在codeup上的设置界面设置公钥。\u003c/p\u003e","title":"UnrealVersionControl"},{"content":"简介 相关课程：\nhttps://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/\n这篇笔记简单介绍如何在UE5.5中建立一个在线链接，包含OnlineSubsystem的使用方法，自定义代理的建立等内容。\n效果如下：\n在steam登录的情况下，在2台不同的主机上可以建立链接，在一个大厅中进行游玩（注意需要不同的账号，以及相同的地域）。\n配置文件设置 在DefaultEngine.ini中，添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 [/Script/Engine.GameEngine] +NetDriverDefinitions=(DefName=\u0026#34;GameNetDriver\u0026#34;,DriverClassName=\u0026#34;OnlineSubsystemSteam.SteamNetDriver\u0026#34;,DriverClassNameFallback=\u0026#34;OnlineSubsystemUtils.IpNetDriver\u0026#34;) [OnlineSubsystem] DefaultPlatformService=Steam [OnlineSubsystemSteam] bEnabled=true SteamDevAppId=480 bInitServerOnClient=true [/Script/OnlineSubsystemSteam.SteamNetDriver] NetConnectionClassName=\u0026#34;OnlineSubsystemSteam.SteamNetConnection\u0026#34; 480是一个公用的游戏id\n在DefaultGame.ini中添加\n1 2 [/Script/Engine.GameSession] MaxPlayers=100 规定了最大玩家数量。\n插件创建 在编辑器的插件设置中可以创建相应的插件，并且在游戏中利用这些插件，以实现代码或者蓝图的复用。插件和游戏存在以下的单项依赖关系：\n例如，游戏模块可以依赖于游戏插件或者其他模块，但是插件不可依赖于游戏模块。\n在创建插件时，选择Blank模板，创建后在MultiplayerSessions.uplugin中添加依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { ... \u0026#34;Modules\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;MultiplayerSessions\u0026#34;, \u0026#34;Type\u0026#34;: \u0026#34;Runtime\u0026#34;, \u0026#34;LoadingPhase\u0026#34;: \u0026#34;Default\u0026#34; } ], \u0026#34;Plugins\u0026#34;:[ { \u0026#34;Name\u0026#34;: \u0026#34;OnlineSubsystem\u0026#34;, \u0026#34;Enabled\u0026#34;: true }, { \u0026#34;Name\u0026#34;: \u0026#34;OnlineSubsystemSteam\u0026#34;, \u0026#34;Enabled\u0026#34;: true } ] } MultiplayerSessions.Build.cs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 using UnrealBuildTool; public class MultiplayerSessions : ModuleRules { public MultiplayerSessions(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs; PublicIncludePaths.AddRange( new string[] {} ); PrivateIncludePaths.AddRange( new string[] {} ); PublicDependencyModuleNames.AddRange( new string[]{ \u0026#34;Core\u0026#34;, \u0026#34;OnlineSubsystem\u0026#34;, \u0026#34;OnlineSubsystemSteam\u0026#34;, \u0026#34;UMG\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34; } ); PrivateDependencyModuleNames.AddRange( new string[]{ \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;Slate\u0026#34;, \u0026#34;SlateCore\u0026#34;, } ); DynamicallyLoadedModuleNames.AddRange(new string[]{}); } } 目录类代码 创建一个menuC++类，并在此基础上创建一个蓝图\n对应蓝图实现如下：\n初始关卡蓝图如下：\nMenu.h代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;Blueprint/UserWidget.h\u0026#34; #include \u0026#34;Interfaces/OnlineSessionInterface.h\u0026#34; #include \u0026#34;Menu.generated.h\u0026#34; UCLASS() class MULTIPLAYERSESSIONS_API UMenu : public UUserWidget { GENERATED_BODY() public: UFUNCTION(BlueprintCallable) void MenuSetup( int32 NumberOfPublicConnections = 4, FString TypeOfMatch = FString(TEXT(\u0026#34;FreeForAll\u0026#34;)), FString LobbyPath = FString(TEXT(\u0026#34;/Game/ThirdPerson/Maps/Lobby\u0026#34;))); protected: virtual bool Initialize() override; // 当退出关卡加入大厅时调用 virtual void NativeDestruct() override; // 回调函数，绑定在FMultiplayerOnCreateSessionComplete上 UFUNCTION() void OnCreateSession(bool bWasSuccessful); void OnFindSessions(const TArray\u0026lt;FOnlineSessionSearchResult\u0026gt;\u0026amp; SessionResults, bool bWasSuccessful); void OnJoinSession(EOnJoinSessionCompleteResult::Type Result); UFUNCTION() void OnDestroySession(bool bWasSuccessful); UFUNCTION() void OnStartSession(bool bWasSuccessful); private: // 必须和Editor中名称完全一致 UPROPERTY(meta=(BindWidget)) class UButton* HostButton; UPROPERTY(meta=(BindWidget)) UButton* JoinButton; UFUNCTION() void HostButtonClicked(); UFUNCTION() void JoinButtonClicked(); void MenuTearDown(); class UMultiplayerSessionsSubsystem* MultiplayerSessionsSubsystem; int32 NumPublicConnections{4}; FString MatchType{TEXT(\u0026#34;FreeForAll\u0026#34;)}; FString PathToLobby{TEXT(\u0026#34;\u0026#34;)}; }; 按钮绑定 对于蓝图中名称和头文件中完全一致的UI控件，可以使用UPROPERTY(meta=(BindWidget))进行自动绑定，这样当蓝图中的按钮被点击时，cpp中的同名称按钮也会被触发，由于UMenu::Initialize函数添加了HostButton-\u0026gt;OnClicked.AddDynamic(this, \u0026amp;ThisClass::HostButtonClicked);绑定，因此会触发相应的回调函数。\n回调函数声明注意 这里回调函数中，有部分包含了UFUNCTION声明，有的没有，其中包含了的使用的是动态回调，而没有的则使用普通回调，不能被蓝图使用，这种差别的原因是TArray\u0026lt;\u0026gt;或者EOnJoinSessionCompleteResult::Type的类型不被UE的反射系统支持，而bool则原生支持，所以调用的时候可以使用动态代理的回调。要令上述类型支持动态回调，方法之一是将这些类型作为一个声明了UCLASS,USTRUCT的成员，并且使用UPROPERTY标记，这样可以将类作为参数间接访问相关类型。\nMenu.cpp代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 #include \u0026#34;Menu.h\u0026#34; #include \u0026#34;Components/Button.h\u0026#34; #include \u0026#34;MultiplayerSessionsSubsystem.h\u0026#34; #include \u0026#34;OnlineSessionSettings.h\u0026#34; #include \u0026#34;OnlineSubsystemUtils.h\u0026#34; void UMenu::MenuSetup(int32 NumberOfPublicConnections, FString TypeOfMatch, FString LobbyPath) { PathToLobby = FString::Printf(TEXT(\u0026#34;%s?listen\u0026#34;), *LobbyPath); NumPublicConnections = NumberOfPublicConnections; MatchType = TypeOfMatch; AddToViewport(); SetVisibility(ESlateVisibility::Visible); SetIsFocusable(true); UWorld* World = GetWorld(); if(World) { APlayerController* PlayerController = World-\u0026gt;GetFirstPlayerController(); if(PlayerController) { FInputModeUIOnly InputModeData; InputModeData.SetWidgetToFocus(TakeWidget()); InputModeData.SetLockMouseToViewportBehavior(EMouseLockMode::DoNotLock); PlayerController-\u0026gt;SetInputMode(InputModeData); PlayerController-\u0026gt;SetShowMouseCursor(true); } } UGameInstance* GameInstance = GetGameInstance(); if(GameInstance) { MultiplayerSessionsSubsystem = GameInstance-\u0026gt;GetSubsystem\u0026lt;UMultiplayerSessionsSubsystem\u0026gt;(); } if(MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-\u0026gt;MultiplayerOnCreateSessionComplete.AddDynamic(this, \u0026amp;ThisClass::OnCreateSession); MultiplayerSessionsSubsystem-\u0026gt;MultiplayerOnFindSessionsComplete.AddUObject(this, \u0026amp;ThisClass::OnFindSessions); MultiplayerSessionsSubsystem-\u0026gt;MultiplayerOnJoinSessionComplete.AddUObject(this, \u0026amp;ThisClass::OnJoinSession); MultiplayerSessionsSubsystem-\u0026gt;MultiplayerOnDestroySessionComplete.AddDynamic(this, \u0026amp;ThisClass::OnDestroySession); MultiplayerSessionsSubsystem-\u0026gt;MultiplayerOnStartSessionComplete.AddDynamic(this, \u0026amp;ThisClass::OnStartSession); } } bool UMenu::Initialize() { // AddToViewport不放在该函数的原因是此时尚未完成全部初始化 if(!Super::Initialize()){ return false; } if(HostButton){ HostButton-\u0026gt;OnClicked.AddDynamic(this, \u0026amp;ThisClass::HostButtonClicked); } if(JoinButton) { JoinButton-\u0026gt;OnClicked.AddDynamic(this, \u0026amp;ThisClass::JoinButtonClicked); } return true; } void UMenu::NativeDestruct() { MenuTearDown(); Super::NativeDestruct(); } void UMenu::OnCreateSession(bool bWasSuccessful) { if(bWasSuccessful) { UWorld* World = GetWorld(); if(World) { World-\u0026gt;ServerTravel(PathToLobby); } } else { HostButton-\u0026gt;SetIsEnabled(true); } } void UMenu::OnFindSessions(const TArray\u0026lt;FOnlineSessionSearchResult\u0026gt;\u0026amp; SessionResults, bool bWasSuccessful) { if(!MultiplayerSessionsSubsystem) { return; } for(auto\u0026amp; Result : SessionResults) { FString SettingsValue; Result.Session.SessionSettings.Get(FName(\u0026#34;MatchType\u0026#34;), SettingsValue); if(SettingsValue == MatchType) { MultiplayerSessionsSubsystem-\u0026gt;JoinSession(Result); return; } } if(!bWasSuccessful || SessionResults.Num()==0) { JoinButton-\u0026gt;SetIsEnabled(true); } } void UMenu::OnJoinSession(EOnJoinSessionCompleteResult::Type Result) { IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld()); if(Subsystem) { IOnlineSessionPtr SessionInterface = Subsystem-\u0026gt;GetSessionInterface(); if(SessionInterface.IsValid()) { FString Address; SessionInterface-\u0026gt;GetResolvedConnectString(NAME_GameSession, Address); APlayerController* PlayerController = GetGameInstance()-\u0026gt;GetFirstLocalPlayerController(); if(PlayerController) { PlayerController-\u0026gt;ClientTravel(Address, TRAVEL_Absolute); } } } if(Result!=EOnJoinSessionCompleteResult::Success) { JoinButton-\u0026gt;SetIsEnabled(true); } } void UMenu::HostButtonClicked() { HostButton-\u0026gt;SetIsEnabled(false); if(MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-\u0026gt;CreateSession(NumPublicConnections, MatchType); } } void UMenu::JoinButtonClicked() { JoinButton-\u0026gt;SetIsEnabled(false); if(MultiplayerSessionsSubsystem) { MultiplayerSessionsSubsystem-\u0026gt;FindSessions(10000); } } void UMenu::MenuTearDown() { RemoveFromParent(); if(UWorld* World = GetWorld()) { if(APlayerController* PlayerController = World-\u0026gt;GetFirstPlayerController()) { FInputModeGameOnly InputModeData; PlayerController-\u0026gt;SetInputMode(InputModeData); PlayerController-\u0026gt;SetShowMouseCursor(false); } } } 该代码的注意点如下：\nInitialize函数在创建UI时进行调用，只进行按钮的代理绑定操作，其他初始操作（比如AddToViewport）放到自定义函数； MenuSetup中，调整了一些UI设置，并且获取了UMultiplayerSessionsSubsystem，并且获取其中的代理进行了回调函数的绑定，注意动态回调和非动态的函数区别。 在相关按钮被按下后，按钮被设置为不可用，直到回调中返回结果后才可以再次点击，这是为了防止多次调用内容。 UMenu::NativeDestruct函数被调用时，表示用户被移动到其他地图，本地图被移除。 OnlineSubSystem代码 MultiplayerSessionsSubsystem.h继承UGameInstanceSubsystem，特点为：\n是一个单例类 和GameInstance拥有相同的生命周期，游戏开始时创建，结束时销毁 通过继承UGameInstanceSubsystem，而非UGameInstance，可以使具体功能实现解耦 实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;Subsystems/GameInstanceSubsystem.h\u0026#34; #include \u0026#34;Interfaces/OnlineSessionInterface.h\u0026#34; #include \u0026#34;MultiplayerSessionsSubsystem.generated.h\u0026#34; // // Delcaring our own custom delegates for the Menu class to bind callbacks to // DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnCreateSessionComplete, bool, bWasSuccessful); DECLARE_MULTICAST_DELEGATE_TwoParams(FMultiplayerOnFindSessionsComplete, const TArray\u0026lt;FOnlineSessionSearchResult\u0026gt;\u0026amp; SessionResults, bool bWasSuccessful); DECLARE_MULTICAST_DELEGATE_OneParam(FMultiplayerOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnDestroySessionComplete, bool, bWasSuccessful); DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FMultiplayerOnStartSessionComplete, bool, bWasSuccessful); UCLASS() class MULTIPLAYERSESSIONS_API UMultiplayerSessionsSubsystem : public UGameInstanceSubsystem { GENERATED_BODY() public: UMultiplayerSessionsSubsystem(); // // To handle session functionality. The Menu class will call these // void CreateSession(int32 NumPublicConnections, FString MatchType); void FindSessions(int32 MaxSearchResults); void JoinSession(const FOnlineSessionSearchResult\u0026amp; SessionResult); void DestroySession(); void StartSession(); // // Our own custom delegates for the Menu class to bind callbacks to // FMultiplayerOnCreateSessionComplete MultiplayerOnCreateSessionComplete; FMultiplayerOnFindSessionsComplete MultiplayerOnFindSessionsComplete; FMultiplayerOnJoinSessionComplete MultiplayerOnJoinSessionComplete; FMultiplayerOnDestroySessionComplete MultiplayerOnDestroySessionComplete; FMultiplayerOnStartSessionComplete MultiplayerOnStartSessionComplete; protected: // // Internal callbacks for the delegates we\u0026#39;ll add to the Online Session Interface delegate list. // These don\u0026#39;t need to be called outside this class. // void OnCreateSessionComplete(FName SessionName, bool bWasSuccessful); void OnFindSessionsComplete(bool bWasSuccessful); void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result); void OnDestroySessionComplete(FName SessionName, bool bWasSuccessful); void OnStartSessionComplete(FName SessionName, bool bWasSuccessful); private: IOnlineSessionPtr SessionInterface; TSharedPtr\u0026lt;FOnlineSessionSettings\u0026gt; LastSessionSettings; TSharedPtr\u0026lt;FOnlineSessionSearch\u0026gt; LastSessionSearch; // // To add to the Online Session Interface delegate list. // We\u0026#39;ll bind our MultiplayerSessionsSubsystem internal callbacks to these. // FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate; FDelegateHandle CreateSessionCompleteDelegateHandle; FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate; FDelegateHandle FindSessionsCompleteDelegateHandle; FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate; FDelegateHandle JoinSessionCompleteDelegateHandle; FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate; FDelegateHandle DestroySessionCompleteDelegateHandle; FOnStartSessionCompleteDelegate StartSessionCompleteDelegate; FDelegateHandle StartSessionCompleteDelegateHandle; bool bCreateSessionOnDestroy{false}; int32 LastNumPublicConnections; FString LastMatchType; }; 注意点如下：\n代码开始通过宏定义了若干个自定义的代理，这些代理有些是动态多播代理，有些是普通多播代理，原因在于参数的限制。声明代理后需要在类内部进行实例的声明； 在这里声明若干自定义代理的目的是为了让menu的函数可以在各种session任务完成后执行相应的回调函数，同时本类不需要知道具体的实现，实现类之间的解耦； 这里将CreateSession等函数声明为public函数，方便menu直接调用 private部分声明了多种代理，用于绑定当相关Session操作完成后会进行回调的函数，和上面的自定义回调进行对比，前面的用于令其他类绑定对应的回调函数，通知者为当前类；当前的代理用来给Session Interface进行绑定，通知者为Interface； 将代理绑定到Session Interface后，返回对应的Handle，这个Handle可以后续将代理进行解绑。 MultiplayerSessionsSubsystem.cpp实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 #include \u0026#34;MultiplayerSessionsSubsystem.h\u0026#34; #include \u0026#34;OnlineSubsystem.h\u0026#34; #include \u0026#34;OnlineSessionSettings.h\u0026#34; #include \u0026#34;OnlineSubsystemUtils.h\u0026#34; #include \u0026#34;Online/OnlineSessionNames.h\u0026#34; UMultiplayerSessionsSubsystem::UMultiplayerSessionsSubsystem(): CreateSessionCompleteDelegate(FOnCreateSessionCompleteDelegate::CreateUObject(this, \u0026amp;ThisClass::OnCreateSessionComplete)), FindSessionsCompleteDelegate(FOnFindSessionsCompleteDelegate::CreateUObject(this, \u0026amp;ThisClass::OnFindSessionsComplete)), JoinSessionCompleteDelegate(FOnJoinSessionCompleteDelegate::CreateUObject(this, \u0026amp;ThisClass::OnJoinSessionComplete)), DestroySessionCompleteDelegate(FOnDestroySessionCompleteDelegate::CreateUObject(this, \u0026amp;ThisClass::OnDestroySessionComplete)), StartSessionCompleteDelegate(FOnStartSessionCompleteDelegate::CreateUObject(this, \u0026amp;ThisClass::OnStartSessionComplete)) { IOnlineSubsystem* Subsystem = Online::GetSubsystem(UObject::GetWorld()); if(Subsystem) { SessionInterface = Subsystem-\u0026gt;GetSessionInterface(); } } void UMultiplayerSessionsSubsystem::CreateSession(int32 NumPublicConnections, FString MatchType) { if(!SessionInterface.IsValid()) { return; } auto ExistingSession = SessionInterface-\u0026gt;GetNamedSession(NAME_GameSession); if(ExistingSession != nullptr) { bCreateSessionOnDestroy = true; LastNumPublicConnections = NumPublicConnections; LastMatchType = MatchType; DestroySession(); } // Store the delegate in a FDelegateHandle so we can later remove it from the delegate list CreateSessionCompleteDelegateHandle = SessionInterface-\u0026gt;AddOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegate); LastSessionSettings = MakeShareable(new FOnlineSessionSettings()); LastSessionSettings-\u0026gt;bIsLANMatch = Online::GetSubsystem(GetWorld())-\u0026gt;GetSubsystemName() == \u0026#34;NULL\u0026#34; ? true : false; LastSessionSettings-\u0026gt;NumPublicConnections = NumPublicConnections; LastSessionSettings-\u0026gt;bAllowJoinInProgress = true; LastSessionSettings-\u0026gt;bAllowJoinViaPresence = true; LastSessionSettings-\u0026gt;bShouldAdvertise = true; LastSessionSettings-\u0026gt;bUsesPresence = true; LastSessionSettings-\u0026gt;bUseLobbiesIfAvailable = true; LastSessionSettings-\u0026gt;Set(FName(\u0026#34;MatchType\u0026#34;), MatchType, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing); LastSessionSettings-\u0026gt;BuildUniqueId = 1; const ULocalPlayer* LocalPlayer = GetWorld()-\u0026gt;GetFirstLocalPlayerFromController(); if(!SessionInterface-\u0026gt;CreateSession(*LocalPlayer-\u0026gt;GetPreferredUniqueNetId(), NAME_GameSession, *LastSessionSettings)) { SessionInterface-\u0026gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle); // Broadcast our own custom delegate MultiplayerOnCreateSessionComplete.Broadcast(false); } } void UMultiplayerSessionsSubsystem::FindSessions(int32 MaxSearchResults) { if(!SessionInterface.IsValid()) { return; } FindSessionsCompleteDelegateHandle = SessionInterface-\u0026gt;AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate); LastSessionSearch = MakeShareable(new FOnlineSessionSearch()); LastSessionSearch-\u0026gt;MaxSearchResults = MaxSearchResults; LastSessionSearch-\u0026gt;bIsLanQuery = Online::GetSubsystem(GetWorld())-\u0026gt;GetSubsystemName() == \u0026#34;NULL\u0026#34; ? true : false; LastSessionSearch-\u0026gt;QuerySettings.Set(SEARCH_PRESENCE, true, EOnlineComparisonOp::Equals); const ULocalPlayer* LocalPlayer = GetWorld()-\u0026gt;GetFirstLocalPlayerFromController(); if(!SessionInterface-\u0026gt;FindSessions(*LocalPlayer-\u0026gt;GetPreferredUniqueNetId(), LastSessionSearch.ToSharedRef())) { SessionInterface-\u0026gt;ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle); MultiplayerOnFindSessionsComplete.Broadcast(TArray\u0026lt;FOnlineSessionSearchResult\u0026gt;(), false); } } void UMultiplayerSessionsSubsystem::JoinSession(const FOnlineSessionSearchResult\u0026amp; SessionResult) { // 相较原版本修改的地方 FOnlineSessionSearchResult Result = SessionResult; if(!SessionInterface || !SessionInterface.IsValid()) { MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError); return; } JoinSessionCompleteDelegateHandle = SessionInterface-\u0026gt;AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate); Result.Session.SessionSettings.bUseLobbiesIfAvailable = true; Result.Session.SessionSettings.bUsesPresence = true; const ULocalPlayer* LocalPlayer = GetWorld()-\u0026gt;GetFirstLocalPlayerFromController(); if(!SessionInterface-\u0026gt;JoinSession(*LocalPlayer-\u0026gt;GetPreferredUniqueNetId(), NAME_GameSession, Result)) { SessionInterface-\u0026gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle); MultiplayerOnJoinSessionComplete.Broadcast(EOnJoinSessionCompleteResult::UnknownError); } } void UMultiplayerSessionsSubsystem::DestroySession() { if(!SessionInterface.IsValid()) { MultiplayerOnDestroySessionComplete.Broadcast(false); return; } DestroySessionCompleteDelegateHandle = SessionInterface-\u0026gt;AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate); if(!SessionInterface-\u0026gt;DestroySession(NAME_GameSession)) { SessionInterface-\u0026gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle); MultiplayerOnDestroySessionComplete.Broadcast(false); } } void UMultiplayerSessionsSubsystem::OnCreateSessionComplete(FName SessionName, bool bWasSuccessful) { if(SessionInterface) { SessionInterface-\u0026gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle); } MultiplayerOnCreateSessionComplete.Broadcast(bWasSuccessful); } void UMultiplayerSessionsSubsystem::OnFindSessionsComplete(bool bWasSuccessful) { if(SessionInterface) { SessionInterface-\u0026gt;ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle); } if(LastSessionSearch-\u0026gt;SearchResults.Num() \u0026lt;= 0) { MultiplayerOnFindSessionsComplete.Broadcast(TArray\u0026lt;FOnlineSessionSearchResult\u0026gt;(), false); return; } MultiplayerOnFindSessionsComplete.Broadcast(LastSessionSearch-\u0026gt;SearchResults, bWasSuccessful); } void UMultiplayerSessionsSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result) { if(SessionInterface) { SessionInterface-\u0026gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle); } MultiplayerOnJoinSessionComplete.Broadcast(Result); } void UMultiplayerSessionsSubsystem::OnDestroySessionComplete(FName SessionName, bool bWasSuccessful) { if(SessionInterface) { SessionInterface-\u0026gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle); } if(bWasSuccessful \u0026amp;\u0026amp; bCreateSessionOnDestroy) { bCreateSessionOnDestroy = false; CreateSession(LastNumPublicConnections, LastMatchType); } MultiplayerOnDestroySessionComplete.Broadcast(bWasSuccessful); } 首先，这里和官方实现的主要差别在：UMultiplayerSessionsSubsystem::JoinSession部分，在其中，使用了拷贝的FOnlineSessionSearchResult类型，并且重新进行了一些设定，进行设定后，在测试的版本中可以顺利加入游戏，否则不能。\n接下来对代码内容进行说明：\n在构造函数中，对各种Delegate进行了初始化，注意到这里的回调函数都是非动态的； CreateSession的实现中，如果当前还有未删除的session，就保存当前的参数，执行DestroySession，并在实现后的回调函数中进行判断并再次创建Session，如果直接在CreateSession中删除并创建，会导致Destroy还未成功就进行创建，导致创建失败。 NAME_GameSession是一个宏，在这里作为session的固定名字； 在Session操作开始时，将代理进行绑定，而当操作成功的回调或者操作失败时，就通过Handle清除对应的代理，防止重复触发； 对于自定义代理，需要在操作成功或者失败时进行广播（Broadcast）操作 无缝传送 非无缝传送（Non-Seamless Travel）\n客户端断开与服务器的连接 客户端重新连接到同一个服务器 非无缝传送发生的情况：\n第一次加载地图时 第一次连接到服务器时 结束一场多人游戏并开始新游戏时 无缝传送（Seamless Travel）\n带来更流畅的游戏体验 避免任何重新连接问题（例如玩家在切换地图时被踢出） 1 2 // 在GameMode中启用 bUseSeamlessTravel = true; 需要一个过渡地图（transition map），用于在主地图切换时承载玩家状态 在任何时刻必须有地图被加载，以保证传送过程不中断，系统正常运行，同时可以不同时加载两个大型地图 多人游戏中的关卡切换（Travel in Multiplayer） 1. UWorld::ServerTravel\n仅限服务器端调用 将服务器跳转至一个新关卡 所有已连接的客户端都会跟随切换 服务器会调用 APlayerController::ClientTravel 2. APlayerController::ClientTravel\n当客户端调用时：连接到一个新的服务器 当服务器调用时：使特定玩家切换到一个新地图 接下来以大厅实现的LobbyGameMode为例，说明实现：\n1 2 3 4 5 6 7 8 // .h UCLASS() class BLASTERS_API ALobbyGameMode : public AGameMode { GENERATED_BODY() public: virtual void PostLogin(APlayerController* NewPlayer) override; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // .cpp void ALobbyGameMode::PostLogin(APlayerController* NewPlayer) { Super::PostLogin(NewPlayer); int32 NumberOfPlayers = GameState.Get()-\u0026gt;PlayerArray.Num(); if(NumberOfPlayers == 2) { UWorld* World = GetWorld(); if(World) { bUseSeamlessTravel = true; World-\u0026gt;ServerTravel(FString(\u0026#34;/Game/Maps/BlasterMap?listen\u0026#34;)); } } } 随后可以在此基础上新建一个蓝图GameMode，并且设置默认角色等内容。\n同时，需要设置一个过渡关卡，新建空关卡并且在设置中设置Transition Level为本关卡\n打印NetworkRole 对于Pawn和character，它们在服务端和客户端中的网络角色会有不同，分为\n角色类型 控制权 所在位置 用途 ROLE_Authority 服务器 服务器 控制游戏逻辑，广播状态 ROLE_AutonomousProxy 客户端 本地玩家客户端 接收输入，发送请求到服务器 ROLE_SimulatedProxy 客户端 其他客户端玩家 显示服务器同步的玩家动作 ROLE_None 无 本地（非网络参与） 本地临时对象、不同步 为了在玩家头顶显示不同段中所有玩家的Role，首先设计一个UserWidget（包括C++以及对应蓝图），随后将这些蓝图附加在角色上，同时在角色的C++类中也要创建\n1 2 3 4 5 6 7 // .h UPROPERTY(EditAnywhere, BlueprintReadOnly, meta=(AllowPrivateAccess=\u0026#34;true\u0026#34;)) class UWidgetComponent* OverheadWidget; // .cpp 构造函数 OverheadWidget = CreateDefaultSubobject\u0026lt;UWidgetComponent\u0026gt;(TEXT(\u0026#34;OverheadWidget\u0026#34;)); OverheadWidget-\u0026gt;SetupAttachment(RootComponent); 随后在Widget中进行相关的代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // .h UCLASS() class BLASTERS_API UOverheadWidget : public UUserWidget { GENERATED_BODY() public: UPROPERTY(meta=(BindWidget)) class UTextBlock* DisplayText; void SetDisplayText(FString TextToDisplay); UFUNCTION(BlueprintCallable) void ShowPlayerRole(APawn* InPawn); protected: virtual void NativeDestruct() override; }; // .cpp void UOverheadWidget::SetDisplayText(FString TextToDisplay) { if(DisplayText) { DisplayText-\u0026gt;SetText(FText::FromString(TextToDisplay)); } } void UOverheadWidget::ShowPlayerRole(APawn* InPawn) { if(InPawn) { // ENetRole RemoteRole = InPawn-\u0026gt;GetRemoteRole(); ENetRole LocalRole = InPawn-\u0026gt;GetLocalRole(); FString Role; switch(LocalRole) { case ENetRole::ROLE_Authority: Role = FString(\u0026#34;Authority\u0026#34;); break; case ENetRole::ROLE_AutonomousProxy: Role = FString(\u0026#34;AutonomousProxy\u0026#34;); break; case ENetRole::ROLE_SimulatedProxy: Role = FString(\u0026#34;SimulatedProxy\u0026#34;); break; case ENetRole::ROLE_None: Role = FString(\u0026#34;None\u0026#34;); break; } SetDisplayText(FString::Printf(TEXT(\u0026#34;Local Role: %s\u0026#34;), *Role)); } } void UOverheadWidget::NativeDestruct() { RemoveFromParent(); Super::NativeDestruct(); } 最后在蓝图中实现\n变量复制 接下来以bIsAiming这个和角色动画有关的变量说明如何将变量传递到服务器和客户端\n为了编译管理和武器装备有关的变量，设置一个CombatComponent，因为其中的变量需要复制到客户端，所以创建的时候需要设置该组件可复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // CombatComponent.h class BLASTERS_API UCombatComponent : public UActorComponent // CombatComponent.cpp UPROPERTY(Replicated) bool bAiming; // BlasterCharacter.h UPROPERTY(VisibleAnywhere) class UCombatComponent* Combat; // BlasterCharacter.cpp ABlasterCharacter::ABlasterCharacter() { // ... Combat = CreateDefaultSubobject\u0026lt;UCombatComponent\u0026gt;(TEXT(\u0026#34;CombatComponent\u0026#34;)); Combat-\u0026gt;SetIsReplicated(true); // ... } 通过SetIsReplicated(true)，该组件下的相关内容就可以标记为可复制.\n将输入关联到函数中，并且由函数修改相关变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ABlasterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAction(\u0026#34;Aim\u0026#34;, IE_Pressed, this, \u0026amp;ABlasterCharacter::AimButtonPressed); PlayerInputComponent-\u0026gt;BindAction(\u0026#34;Aim\u0026#34;, IE_Released, this, \u0026amp;ABlasterCharacter::AimButtonReleased); } void ABlasterCharacter::AimButtonPressed() { if(Combat) { Combat-\u0026gt;SetAiming(true); } } void ABlasterCharacter::AimButtonReleased() { if(Combat) { Combat-\u0026gt;SetAiming(false); } } 该方法确保了只有在实际装备武器的时候才执行相关变量修改命令，对应的函数如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // .h void SetAiming(bool bIsAiming); UFUNCTION(Server, Reliable) void ServerSetAiming(bool bIsAiming); // .cpp void UCombatComponent::SetAiming(bool bIsAiming) { // 这里首先进行设置是为了保证客户端可以立即获得反馈 bAiming = bIsAiming; // 客户端和服务端调用都在服务端执行 ServerSetAiming(bIsAiming); if (Character) { Character-\u0026gt;GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed; } } void UCombatComponent::ServerSetAiming_Implementation(bool bIsAiming) { bAiming = bIsAiming; if (Character) { Character-\u0026gt;GetCharacterMovement()-\u0026gt;MaxWalkSpeed = bIsAiming ? AimWalkSpeed : BaseWalkSpeed; } } 其中在声明中的Server表示该行为只在服务器端执行，如果在客户端调用了该函数也会变为在服务端执行；\nReliable表示该函数是可靠，并且相对于同一个Actor是有序执行的。\n同时，需要重写GetLifetimeReplicatedProps函数来指定变量复制时的行为\n1 2 3 4 5 6 7 8 9 10 11 // .h public:\tvirtual void GetLifetimeReplicatedProps(TArray\u0026lt;class FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const override; // .cpp void UCombatComponent::GetLifetimeReplicatedProps(TArray\u0026lt;class FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); DOREPLIFETIME(UCombatComponent, EquippedWeapon); DOREPLIFETIME(UCombatComponent, bAiming); } 以上的DOREPLIFETIME表示进行无条件复制，再比如ABlasterCharacter::GetLifetimeReplicatedProps 中的DOREPLIFETIME_CONDITION(ABlasterCharacter, OverlappingWeapon, COND_OwnerOnly);表示只复制给Owner.\n同时，OnRep类的函数还可以传递参数，表示上一次复制的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // BlasterCharacter.h UPROPERTY(ReplicatedUsing = OnRep_OverlappingWeapon) class AWeapon* OverlappingWeapon; UFUNCTION() void OnRep_OverlappingWeapon(AWeapon* LastWeapon); // BlasterCharacter.cpp void ABlasterCharacter::OnRep_OverlappingWeapon(AWeapon* LastWeapon){ if(OverlappingWeapon){ OverlappingWeapon-\u0026gt;ShowPickUpWidget(true); } if(LastWeapon){ LastWeapon-\u0026gt;ShowPickUpWidget(false); } } 处理复制过程中的压缩导致的范围变化问题 对于如Rotator中的变量，UE引擎在进行复制的时候，会对其中的浮点数进行压缩，在这个过程中，可能会发生预料之外的情况，比如将一个小于0的角度映射为接近360度的角度，在这种情况下，我们需要再代码中重新将相关范围调整回负数.\n1 2 3 4 5 6 7 8 AO_Pitch = GetBaseAimRotation().Pitch; // 在传输过程中，角度会被缩放到[0, 360]之间，因此需要将其转换为原本设定的区间 if(AO_Pitch \u0026gt; 90.f \u0026amp;\u0026amp; !IsLocallyControlled()) { FVector2D InRange(270.f, 360.f); FVector2D OutRange(-90.f, 0.f); AO_Pitch = FMath::GetMappedRangeValueClamped(InRange, OutRange, AO_Pitch); } 实现射击功能 对于多人游戏中的设计功能，主要有以下几项需要实现：\n射击时，需要记录发射者屏幕的中心点，并且以此为目标位置发射子弹 发射时，需要有枪口火焰动画，还需要子弹轨迹、抛射弹壳动画等 对于第一种，必须由服务器进行执行，并且使用多播在各台机器上执行\n实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // CombatComponent.h // ... protected: void FireButtonPressed(bool bPressed); UFUNCTION(Server, Reliable) void ServerFire(const FVector_NetQuantize\u0026amp; TraceHitTarget); UFUNCTION(NetMulticast, Reliable) void MulticastFire(const FVector_NetQuantize\u0026amp; TraceHitTarget); void TraceUnderCrosshairs(FHitResult\u0026amp; TraceHitResult); private: class ABlasterCharacter* Character; UPROPERTY(ReplicatedUsing=OnRep_EquippedWeapon) AWeapon* EquippedWeapon; UPROPERTY(Replicated) bool bAiming; bool bFireButtonPressed; // CombatComponent.cpp void UCombatComponent::FireButtonPressed(bool bPressed) { bFireButtonPressed = bPressed; if(bFireButtonPressed) { FHitResult HitResult; TraceUnderCrosshairs(HitResult); ServerFire(HitResult.ImpactPoint); } } void UCombatComponent::TraceUnderCrosshairs(FHitResult\u0026amp; TraceHitResult) { FVector2D ViewportSize; if(GEngine \u0026amp;\u0026amp; GEngine-\u0026gt;GameViewport) { GEngine-\u0026gt;GameViewport-\u0026gt;GetViewportSize(ViewportSize); } FVector2D CrosshairLocation(ViewportSize.X / 2.f, ViewportSize.Y / 2.f); FVector CrosshairWorldPosition; FVector CrosshairWorldDirection; bool bScreenToWorld = UGameplayStatics::DeprojectScreenToWorld( UGameplayStatics::GetPlayerController(this, 0), CrosshairLocation, CrosshairWorldPosition, CrosshairWorldDirection ); if(bScreenToWorld) { FVector Start = CrosshairWorldPosition; FVector End = Start + CrosshairWorldDirection * TRACE_LENGTH; GetWorld()-\u0026gt;LineTraceSingleByChannel( TraceHitResult, Start, End, ECC_Visibility ); if(!TraceHitResult.bBlockingHit) { TraceHitResult.ImpactPoint = End; } } } void UCombatComponent::ServerFire_Implementation(const FVector_NetQuantize\u0026amp; TraceHitTarget) { MulticastFire(TraceHitTarget); } void UCombatComponent::MulticastFire_Implementation(const FVector_NetQuantize\u0026amp; TraceHitTarget) { if(EquippedWeapon == nullptr || Character == nullptr) return; Character-\u0026gt;PlayFireMontage(bAiming); EquippedWeapon-\u0026gt;Fire(TraceHitTarget); } 多播函数的作用是：如果在服务端运行，则会在服务端和客户端所有机器上调用（如果在客户端，那么只在调用的机器上执行），这种通过多播执行了播放开火动画的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void AWeapon::Fire(const FVector\u0026amp; HitTarget) { if(FireAnimation) WeaponMesh-\u0026gt;PlayAnimation(FireAnimation, false); if (CasingClass) { const USkeletalMeshSocket* AmmoEjectSocket = WeaponMesh-\u0026gt;GetSocketByName(FName(\u0026#34;AmmoEject\u0026#34;)); if (AmmoEjectSocket) { FTransform SocketTransform = AmmoEjectSocket-\u0026gt;GetSocketTransform(WeaponMesh); UWorld* World = GetWorld(); if (World) { World-\u0026gt;SpawnActor\u0026lt;ACasing\u0026gt;( CasingClass, SocketTransform.GetLocation(), SocketTransform.GetRotation().Rotator() ); } } } } 这个函数的作用也是在多播中被调用，执行抛射弹壳等效果动画。\n同时，实际进行设计的武器继承了该类，并且重写了Fire函数，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void AProjectileWeapon::Fire(const FVector\u0026amp; HitTarget) { Super::Fire(HitTarget); if(!HasAuthority()) return; APawn* InstigatorPawn = Cast\u0026lt;APawn\u0026gt;(GetOwner()); const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()-\u0026gt;GetSocketByName(FName(\u0026#34;MuzzleFlash\u0026#34;)); if(MuzzleFlashSocket) { FTransform SocketTransform = MuzzleFlashSocket-\u0026gt;GetSocketTransform(GetWeaponMesh()); // From muzzle flash socket to hit location from TraceUnderCrosshairs FVector ToTarget = HitTarget - SocketTransform.GetLocation(); FRotator TargetRotation = ToTarget.Rotation(); if(ProjectileClass \u0026amp;\u0026amp; InstigatorPawn) { FActorSpawnParameters SpawnParameters; SpawnParameters.Owner = GetOwner(); SpawnParameters.Instigator = InstigatorPawn; if(UWorld* World = GetWorld()) World-\u0026gt;SpawnActor\u0026lt;AProjectile\u0026gt;(ProjectileClass, SocketTransform.GetLocation(), TargetRotation, SpawnParameters); } } } 该函数只在服务端上执行有效功能：发射弹丸\n播放动画Montage 首先创建一个动画Montage 创建一个新的Anim Slot，并修改Default Slot\n在动画蓝图中应用Slot\n随后在代码中设置相关的函数和Montange\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // BlasterCharacter.h UPROPERTY(EditAnywhere, Category = Combat) UAnimMontage* ElimMontage; void PlayElimMontage(); // BlasterCharacter.cpp void ABlasterCharacter::PlayElimMontage() { UAnimInstance* AnimInstance = GetMesh()-\u0026gt;GetAnimInstance(); if(AnimInstance \u0026amp;\u0026amp; ElimMontage) { AnimInstance-\u0026gt;Montage_Play(ElimMontage); } } 要实现同时在客户端和主机播放动画，需要使用多播。\n首先，片段角色是否死亡，以及是否播放动画位置在主机端，但是实际调用播放动画函数需要在所有段上执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // BlasterCharacter.h void Elim(); UFUNCTION(NetMulticast, Reliable) void MulticastElim(); // BlasterCharacter.cpp void ABlasterCharacter::Elim() { if(Combat \u0026amp;\u0026amp; Combat-\u0026gt;EquippedWeapon) { Combat-\u0026gt;EquippedWeapon-\u0026gt;Dropped(); } MulticastElim(); GetWorldTimerManager().SetTimer( ElimTimer, this, \u0026amp;ABlasterCharacter::ElimTimerFinished, ElimDelay ); } void ABlasterCharacter::MulticastElim_Implementation() { bElimmed = true; PlayElimMontage(); if(DissolveMaterialInstance) { DynamicDissolveMaterialInstance = UMaterialInstanceDynamic::Create(DissolveMaterialInstance, this); GetMesh()-\u0026gt;SetMaterial(0, DynamicDissolveMaterialInstance); DynamicDissolveMaterialInstance-\u0026gt;SetScalarParameterValue(TEXT(\u0026#34;Dissolve\u0026#34;), 0.55f); DynamicDissolveMaterialInstance-\u0026gt;SetScalarParameterValue(TEXT(\u0026#34;Glow\u0026#34;), 200.f); } StartDissolve(); // Disable character movement GetCharacterMovement()-\u0026gt;DisableMovement(); GetCharacterMovement()-\u0026gt;StopMovementImmediately(); if(BlasterPlayerController) { DisableInput(BlasterPlayerController); } // Disable collision GetCapsuleComponent()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); GetMesh()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); // Spawn elim bot if (ElimBotEffect) { FVector ElimBotSpawnPoint(GetActorLocation().X, GetActorLocation().Y, GetActorLocation().Z + 200.f); ElimBotComponent = UGameplayStatics::SpawnEmitterAtLocation( GetWorld(), ElimBotEffect, ElimBotSpawnPoint, GetActorRotation() ); } if (ElimBotSound) { UGameplayStatics::SpawnSoundAtLocation( this, ElimBotSound, GetActorLocation() ); } } 除此之外，也可以在变量被改变的时候播放动画，实现在所有机器上播放的效果，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // BlasterCharacter.cpp void ABlasterCharacter::ReceiveDamage(AActor* DamagedActor, float Damage, const UDamageType* DamageType, class AController* InstigatorController, AActor* DamageCauser) { Health = FMath::Clamp(Health - Damage, 0.f, MaxHealth); UpdateHUDHealth(); PlayHitReactMontage(); if(Health \u0026lt;= 0.f) { ABlasterGameMode* BlasterGameMode = GetWorld()-\u0026gt;GetAuthGameMode\u0026lt;ABlasterGameMode\u0026gt;(); if(BlasterGameMode) { BlasterPlayerController = BlasterPlayerController == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(Controller) : BlasterPlayerController; ABlasterPlayerController* AttackerController = Cast\u0026lt;ABlasterPlayerController\u0026gt;(InstigatorController); BlasterGameMode-\u0026gt;PlayerEliminated(this, BlasterPlayerController, AttackerController); } } } void ABlasterCharacter::OnRep_Health() { UpdateHUDHealth(); PlayHitReactMontage(); } 实现击杀计分 当服务器上角色生命值小于0时，会调用BlasterGameMode-\u0026gt;PlayerEliminated(this, BlasterPlayerController, AttackerController);方法，之所以不直接在角色上调用是因为之后可能会删除角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void ABlasterGameMode::PlayerEliminated(ABlasterCharacter* ElimmedCharacter, ABlasterPlayerController* VictimController, ABlasterPlayerController* AttackerController) { if(AttackerController == nullptr || AttackerController-\u0026gt;PlayerState == nullptr) return; if(VictimController == nullptr || VictimController-\u0026gt;PlayerState == nullptr) return; ABlasterPlayerState* AttackerPlayerState = AttackerController ? Cast\u0026lt;ABlasterPlayerState\u0026gt;(AttackerController-\u0026gt;PlayerState) : nullptr; ABlasterPlayerState* VictimPlayerState = VictimController ? Cast\u0026lt;ABlasterPlayerState\u0026gt;(VictimController-\u0026gt;PlayerState) : nullptr; if(AttackerPlayerState \u0026amp;\u0026amp; AttackerPlayerState != VictimPlayerState) { AttackerPlayerState-\u0026gt;AddToScore(1.f); } if(VictimPlayerState) { VictimPlayerState-\u0026gt;AddToDefeats(1); } if(ElimmedCharacter) { ElimmedCharacter-\u0026gt;Elim(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void ABlasterPlayerState::AddToScore(float ScoreAmount) { SetScore(GetScore() + ScoreAmount); Character = Character == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetPawn()) : Character; if(Character) { Controller = Controller == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(Character-\u0026gt;Controller) : Controller; if(Controller) { Controller-\u0026gt;SetHUDScore(GetScore()); } } } void ABlasterPlayerState::AddToDefeats(int32 DefeatsAmount) { Defeats += DefeatsAmount; Character = Character == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetPawn()) : Character; if(Character) { Controller = Controller == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(Character-\u0026gt;Controller) : Controller; if(Controller) { Controller-\u0026gt;SetHUDDefeats(Defeats); } } } 代码中的Score是PlayerState自带的复制变量，而Defeats是自定义变量，需要手动声明复制以及实现OnRep函数，而Score在复制时的操作也可以进行重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void ABlasterPlayerState::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); DOREPLIFETIME(ABlasterPlayerState, Defeats); } void ABlasterPlayerState::OnRep_Score() { Super::OnRep_Score(); Character = Character == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetPawn()) : Character; if(Character) { Controller = Controller == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(Character-\u0026gt;Controller) : Controller; if(Controller) { Controller-\u0026gt;SetHUDScore(GetScore()); } } } void ABlasterPlayerState::OnRep_Defeats() { Character = Character == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetPawn()) : Character; if(Character \u0026amp;\u0026amp; Character-\u0026gt;Controller) { Controller = Controller == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(Character-\u0026gt;Controller) : Controller; if(Controller) { Controller-\u0026gt;SetHUDDefeats(Defeats); } } } 击杀回调函数与重生 在角色死亡后，一般不会离开重生，因此需要调用回调函数（见播放动画Montage），回调函数中会进行重生相关实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void ABlasterCharacter::ElimTimerFinished() { ABlasterGameMode* BlasterGameMode = GetWorld()-\u0026gt;GetAuthGameMode\u0026lt;ABlasterGameMode\u0026gt;(); if(BlasterGameMode) { BlasterGameMode-\u0026gt;RequestRespawn(this, Controller); } } void ABlasterGameMode::RequestRespawn(ACharacter* ElimmedCharacter, AController* ElimmedController) { if(ElimmedCharacter) { ElimmedCharacter-\u0026gt;Reset(); ElimmedCharacter-\u0026gt;Destroy(); } if(ElimmedController) { TArray\u0026lt;AActor*\u0026gt; PlayerStarts; UGameplayStatics::GetAllActorsOfClass(this, APlayerStart::StaticClass(), PlayerStarts); int32 Selection = FMath::RandRange(0, PlayerStarts.Num() - 1); RestartPlayerAtPlayerStart(ElimmedController, PlayerStarts[Selection]); } } 客户端服务器同步倒计时 在服务器和客户端上，都可以通过 GetWorld()-\u0026gt;GetTimeSeconds()获得时间，以此可以获得倒计时\n1 SetHUDMatchCountdown(MatchTime - GetWorld()-\u0026gt;GetTimeSeconds()); 但是，由于服务器和客户端加载时间不同，即使不存在网络延迟，倒计时也不一致\n解决的方法是：\n客户端向服务器发送请求服务器时间的请求，参数为客户端当前时间； 服务器调用客户端上的函数，参数为当前时间和客户端传来的时间 客户端根据参数中的客户端时间，可以估算出RTT时间，以一半的RTT加上服务器的时间，可以估算当前服务器时间 实际操作中，客户端在游戏开始时和间隔若干秒时间调用一次操作，以保证和服务器的时间同步，具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // BlasterPlayerController.cpp float ABlasterPlayerController::GetServerTime() { if(HasAuthority()) return GetWorld()-\u0026gt;GetTimeSeconds(); return GetWorld()-\u0026gt;GetTimeSeconds() + ClientServerDelta; } void ABlasterPlayerController::ReceivedPlayer() { Super::ReceivedPlayer(); if(IsLocalController()) { ServerRequestServerTime(GetWorld()-\u0026gt;GetTimeSeconds()); } } void ABlasterPlayerController::Tick(float DeltaTime) { Super::Tick(DeltaTime); SetHUDTime(); CheckTimeSync(DeltaTime); } void ABlasterPlayerController::CheckTimeSync(float DeltaTime) { TimeSyncRunningTime += DeltaTime; if (IsLocalController() \u0026amp;\u0026amp; TimeSyncRunningTime \u0026gt; TimeSyncFrequency) { ServerRequestServerTime(GetWorld()-\u0026gt;GetTimeSeconds()); TimeSyncRunningTime = 0.f; } } void ABlasterPlayerController::ServerRequestServerTime_Implementation(float TimeOfClientRequest) { float ServerTimeOfReceipt = GetWorld()-\u0026gt;GetTimeSeconds(); ClientReportServerTime(TimeOfClientRequest, ServerTimeOfReceipt); } void ABlasterPlayerController::ClientReportServerTime_Implementation(float TimeOfClientRequest, float TimeServerReceivedClientRequest) { float RoundTripTime = GetWorld()-\u0026gt;GetTimeSeconds() - TimeOfClientRequest; float CurrentServerTime = TimeServerReceivedClientRequest + (0.5f * RoundTripTime); ClientServerDelta = CurrentServerTime - GetWorld()-\u0026gt;GetTimeSeconds(); } GameMode和MatchState UE中，每个关卡可以设定GameMode，其中，GameModeBase可以设定Player Controller, Pawn等关卡默认内容，也可以通过继承处理与游戏关卡有关的逻辑，比如记录时间等；GameMode继承自GameModeBase，额外包含了MatchState有关内容。\nMatchState命名空间中包含了各种游戏状态，包括在Gamemode.h中的\n1 2 3 4 5 6 7 8 9 10 11 12 namespace MatchState { extern ENGINE_API const FName EnteringMap;\t// We are entering this map, actors are not yet ticking extern ENGINE_API const FName WaitingToStart;\t// Actors are ticking, but the match has not yet started extern ENGINE_API const FName InProgress;\t// Normal gameplay is occurring. Specific games will have their own state machine inside this state extern ENGINE_API const FName WaitingPostMatch;\t// Match has ended so we aren\u0026#39;t accepting new players, but actors are still ticking extern ENGINE_API const FName LeavingMap;\t// We are transitioning out of the map to another location extern ENGINE_API const FName Aborted;\t// Match has failed due to network issues or other problems, cannot continue // If a game needs to add additional states, you may need to override HasMatchStarted and HasMatchEnded to deal with the new states // Do not add any states before WaitingToStart or after WaitingPostMatch } 除此之外，我们还可以自定义MatchState，不过，我们只能在WaitingToStart之后WaitingPostMatch之前添加自定义状态。\n自定义的方法如下：\n1 2 3 4 5 6 7 8 9 10 11 // BlasterGameMode.h namespace MatchState { extern BLASTERS_API const FName Cooldown; // Match duration has been reached. Display winner and begin cooldown timer. } // BlasterGameMode.cpp namespace MatchState { const FName Cooldown = FName(\u0026#34;Cooldown\u0026#34;); } 由于Gamemode只存在于主机上，因此可以通过调用每个Player Controller中的自定义MatchState变量，通过将controller上的MatchState变量声明为复制，并且添加相应的回调函数，使得每个玩家都获取到相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // BlasterGameMode.h virtual void OnMatchStateSet() override; // BlasterGameMode.cpp void ABlasterGameMode::OnMatchStateSet() { Super::OnMatchStateSet(); for(FConstPlayerControllerIterator It = GetWorld()-\u0026gt;GetPlayerControllerIterator(); It; ++It) { ABlasterPlayerController* BlasterPlayer = Cast\u0026lt;ABlasterPlayerController\u0026gt;(*It); if(BlasterPlayer) { BlasterPlayer-\u0026gt;OnMatchStateSet(MatchState); } } } // BlasterPlayerController.cpp void ABlasterPlayerController::OnMatchStateSet(FName State) { MatchState = State; if(MatchState == MatchState::InProgress) { HandleMatchHasStarted(); } else if(MatchState == MatchState::Cooldown) { HandleCooldown(); } } 以下是客户端中途加入时获取MatchState等GameMode中存储信息的方法，采用ServerRPC和ClientRPC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // BlasterPlayerController.h UFUNCTION(Server, Reliable) void ServerCheckMatchState(); UFUNCTION(Client, Reliable) void ClientJoinMidgame(FName StateOfMatch, float Warmup, float Match, float Cooldown, float StartingTime); // BlasterPlayerController.cpp void ABlasterPlayerController::BeginPlay() { Super::BeginPlay(); BlasterHUD = Cast\u0026lt;ABlasterHUD\u0026gt;(GetHUD()); ServerCheckMatchState(); } void ABlasterPlayerController::ServerCheckMatchState_Implementation() { ABlasterGameMode* GameMode = Cast\u0026lt;ABlasterGameMode\u0026gt;(UGameplayStatics::GetGameMode(this)); if(GameMode) { WarmupTime = GameMode-\u0026gt;WarmupTime; MatchTime = GameMode-\u0026gt;MatchTime; CooldownTime = GameMode-\u0026gt;CooldownTime; LevelStartingTime = GameMode-\u0026gt;LevelStartingTime; MatchState = GameMode-\u0026gt;GetMatchState(); ClientJoinMidgame(MatchState, WarmupTime, MatchTime, CooldownTime, LevelStartingTime); } } void ABlasterPlayerController::ClientJoinMidgame_Implementation(FName StateOfMatch, float Warmup, float Match, float Cooldown, float StartingTime) { WarmupTime = Warmup; MatchTime = Match; LevelStartingTime = StartingTime; MatchState = StateOfMatch; CooldownTime = Cooldown; OnMatchStateSet(MatchState); if(BlasterHUD \u0026amp;\u0026amp; MatchState == MatchState::WaitingToStart) { BlasterHUD-\u0026gt;AddAnnouncement(); } } GameState 类似于PlayerState，可以创建一个GameState保存一句游戏中的关键信息，比如最高分数，获胜玩家。\n通常GameMode对应GameState，GameModeBase对应GameStateBase.\nGameState和GameMode不同之处在于，GameState可以被复制到客户端，比如记录最高分玩家（可能有多个）的数组，可以通过常用的方法被复制：\n1 2 3 4 5 6 7 8 9 10 11 // BlasterGameMode.h virtual void GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const override; UPROPERTY(Replicated) TArray\u0026lt;ABlasterPlayerState*\u0026gt; TopScoringPlayers; // BlasterGameMode.cpp void ABlasterGameState::GetLifetimeReplicatedProps(TArray\u0026lt;FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); DOREPLIFETIME(ABlasterGameState, TopScoringPlayers); } Ping 可以通过自带的函数获得Ping\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void ABlasterPlayerController::CheckPing(float DeltaTime) { HighPingRunningTime += DeltaTime; if(HighPingRunningTime \u0026gt; CheckPingFrequency) { if (!PlayerState) PlayerState = GetPlayerState\u0026lt;APlayerState\u0026gt;(); if(PlayerState) { if(PlayerState-\u0026gt;GetPingInMilliseconds() \u0026gt; HighPingThreshold) { HighPingWarning(); PingAnimationRunningTime = 0.f; } } HighPingRunningTime = 0.f; } bool bHighPingAnimationPlaying = BlasterHUD \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;HighPingAnimation \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;IsAnimationPlaying(BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;HighPingAnimation); if(bHighPingAnimationPlaying) { PingAnimationRunningTime += DeltaTime; if(PingAnimationRunningTime \u0026gt; HighPingDuration) { StopHighPingWarning(); } } } 这里的获得Ping的用法有几种：\n1 float APlayerState::GetPingInMilliseconds() 该函数作用是将压缩的Ping乘以4\n以及\n1 uint8 APlayerState::GetCompressedPing() 是获得压缩后的Ping\n以上两种方法获得的Ping精度都相对较差，因此要同步时间还是应该使用RTT估算。\n更低延迟的射击实现（客户端预测技术） 为了让客户端在进行射击的时候可以忽略延迟，可以通过重新修改射击流程以进行实现，下面以霰弹枪为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void UCombatComponent::Fire() { if(CanFire()) { if(EquippedWeapon) { CrosshairShootingFactor = .75f; switch(EquippedWeapon-\u0026gt;FireType) { case EFireType::EFT_Projectile: FireProjectileWeapon(); break; case EFireType::EFT_HitScan: FireHitScanWeapon(); break; case EFireType::EFT_Shotgun: FireShotgun(); break; } } StartFireTimer(); } } 1 2 3 4 5 6 7 8 9 10 11 void UCombatComponent::FireShotgun() { AShotgun* Shotgun = Cast\u0026lt;AShotgun\u0026gt;(EquippedWeapon); if(Shotgun) { TArray\u0026lt;FVector_NetQuantize\u0026gt; HitTargets; Shotgun-\u0026gt;ShotgunTraceEndWithScatter(HitTarget, HitTargets); ShotgunLocalFire(HitTargets); ServerShotgunFire(HitTargets); } } 以上两个函数，都在本地进行执行，Shotgun-\u0026gt;ShotgunTraceEndWithScatter(HitTarget, HitTargets);的目的是为了获取霰弹枪的所有射击方向，从而让本地生成弹丸方向。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void AShotgun::ShotgunTraceEndWithScatter(const FVector\u0026amp; HitTarget, TArray\u0026lt;FVector_NetQuantize\u0026gt;\u0026amp; HitTargets) { const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()-\u0026gt;GetSocketByName(\u0026#34;MuzzleFlash\u0026#34;); if(MuzzleFlashSocket == nullptr) return; const FTransform SocketTransform = MuzzleFlashSocket-\u0026gt;GetSocketTransform(GetWeaponMesh()); const FVector TraceStart = SocketTransform.GetLocation(); const FVector ToTargetNormalized = (HitTarget - TraceStart).GetSafeNormal(); const FVector SphereCenter = TraceStart + ToTargetNormalized * DistanceToSphere; for(uint32 i = 0; i \u0026lt; NumberOfPellets; i++) { const FVector RandVec = UKismetMathLibrary::RandomUnitVector() * FMath::FRandRange(0.f, SphereRadius); const FVector EndLoc = SphereCenter + RandVec; FVector ToEndLoc = EndLoc - TraceStart; ToEndLoc = TraceStart + ToEndLoc * TRACE_LENGTH / ToEndLoc.Size(); HitTargets.Add(ToEndLoc); } } 最后的ServerShotgunFire(HitTargets);的作用就是让服务端执行多播函数，注意在多播函数中，已经执行了LocalFire函数的本机（包括服务端）不需要再执行。\n1 2 3 4 5 6 7 8 9 10 void UCombatComponent::ServerShotgunFire_Implementation(const TArray\u0026lt;FVector_NetQuantize\u0026gt;\u0026amp; TraceHitTargets) { MulticastShotgunFire(TraceHitTargets); } void UCombatComponent::MulticastShotgunFire_Implementation(const TArray\u0026lt;FVector_NetQuantize\u0026gt;\u0026amp; TraceHitTargets) { if(Character \u0026amp;\u0026amp; Character-\u0026gt;IsLocallyControlled()) return; ShotgunLocalFire(TraceHitTargets); } ShotgunLocalFire(HitTargets);的作用是执行实际的射击内容，包括动画、子弹效果和造成伤害，其中，只有主机才有权限造成实际伤害\n1 2 3 4 5 6 7 8 9 10 11 void UCombatComponent::ShotgunLocalFire(const TArray\u0026lt;FVector_NetQuantize\u0026gt;\u0026amp; TraceHitTargets) { AShotgun* Shotgun = Cast\u0026lt;AShotgun\u0026gt;(EquippedWeapon); if(Shotgun == nullptr || Character == nullptr) return; if(CombatState == ECombatState::ECS_Reloading || CombatState == ECombatState::ECS_Unoccupied) { Character-\u0026gt;PlayFireMontage(bAiming); Shotgun-\u0026gt;FireShotgun(TraceHitTargets); CombatState = ECombatState::ECS_Unoccupied; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 void AShotgun::FireShotgun(const TArray\u0026lt;FVector_NetQuantize\u0026gt;\u0026amp; HitTargets) { AWeapon::Fire(FVector()); APawn* OwnerPawn = Cast\u0026lt;APawn\u0026gt;(GetOwner()); if(OwnerPawn == nullptr) return; AController* InstigatorController = OwnerPawn-\u0026gt;GetController(); const USkeletalMeshSocket* MuzzleFlashSocket = GetWeaponMesh()-\u0026gt;GetSocketByName(\u0026#34;MuzzleFlash\u0026#34;); if(MuzzleFlashSocket) { const FTransform SocketTransform = MuzzleFlashSocket-\u0026gt;GetSocketTransform(GetWeaponMesh()); const FVector Start = SocketTransform.GetLocation(); // Maps hit character to number of times hit TMap\u0026lt;ABlasterCharacter*, uint32\u0026gt; HitMap; for(FVector_NetQuantize HitTarget : HitTargets) { FHitResult FireHit; WeaponTraceHit(Start, HitTarget, FireHit); ABlasterCharacter* BlasterCharacter = Cast\u0026lt;ABlasterCharacter\u0026gt;(FireHit.GetActor()); if(BlasterCharacter) { if(HitMap.Contains(BlasterCharacter)) { HitMap[BlasterCharacter]++; } else { HitMap.Emplace(BlasterCharacter, 1); } if(ImpactParticles) { UGameplayStatics::SpawnEmitterAtLocation( GetWorld(), ImpactParticles, FireHit.ImpactPoint, FireHit.ImpactNormal.Rotation() ); } if(HitSound) { UGameplayStatics::PlaySoundAtLocation( this, HitSound, FireHit.ImpactPoint, .5f, FMath::FRandRange(-.5f, .5f) ); } } } for(auto HitPair : HitMap) { if(HitPair.Key \u0026amp;\u0026amp; HasAuthority() \u0026amp;\u0026amp; InstigatorController) { UGameplayStatics::ApplyDamage( HitPair.Key, // Character that was hit Damage * HitPair.Value, // Multiply Damage by number of times hit InstigatorController, this, UDamageType::StaticClass() ); } } } } 客户端预测在HUD上的实现 为了让客户端在射击的时候可以立即观察到HUD上子弹的变化，而不是等到服务器回传才看到变化，需要使用客户端预测技术。\n以下是具体实现：\n当用户点击开火的时候，首先调用CombatComponent(角色上的一个Actor Component)：\n1 2 3 4 5 6 7 8 9 void UCombatComponent::FireProjectileWeapon() { if (EquippedWeapon) { HitTarget = EquippedWeapon-\u0026gt;bUseScatter ? EquippedWeapon-\u0026gt;TraceEndWithScatter(HitTarget) : HitTarget; LocalFire(HitTarget); ServerFire(HitTarget, EquippedWeapon-\u0026gt;FireDelay); } } 其中ServerFire是一个Server的可靠带验证函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 UFUNCTION(Server, Reliable, WithValidation) void ServerFire(const FVector_NetQuantize\u0026amp; TraceHitTarget, float FireDelay); UFUNCTION(NetMulticast, Reliable) void MulticastFire(const FVector_NetQuantize\u0026amp; TraceHitTarget); void UCombatComponent::ServerFire_Implementation(const FVector_NetQuantize\u0026amp; TraceHitTarget, float FireDelay) { MulticastFire(TraceHitTarget); } bool UCombatComponent::ServerFire_Validate(const FVector_NetQuantize\u0026amp; TraceHitTarget, float FireDelay) { if (EquippedWeapon) { bool bNearlyEqual = FMath::IsNearlyEqual(EquippedWeapon-\u0026gt;FireDelay, FireDelay, 0.001f); return bNearlyEqual; } return true; } 这里验证的目的是为了FireDelay数据没有被篡改。确保多播函数对非本地的客户端或者服务器调用LocalFire\n1 2 3 4 5 void UCombatComponent::MulticastFire_Implementation(const FVector_NetQuantize\u0026amp; TraceHitTarget) { if (Character \u0026amp;\u0026amp; Character-\u0026gt;IsLocallyControlled()) return; LocalFire(TraceHitTarget); } LocalCastFire中，调用角色动画以及调用武器的Fire函数：\n1 2 3 4 5 6 7 8 9 10 11 12 void UCombatComponent::LocalFire(const FVector_NetQuantize\u0026amp; TraceHitTarget) { if (EquippedWeapon == nullptr || Character == nullptr) { return; } if (CombatState == ECombatState::ECS_Unoccupied) { Character-\u0026gt;PlayFireMontage(bAiming); EquippedWeapon-\u0026gt;Fire(TraceHitTarget); } } 武器的Fire函数是普通函数，该函数执行播放动画，消耗弹药量（SpendRound）等函数，具体的伤害实现是由子类实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 virtual void Fire(const FVector\u0026amp; HitTarget); void AWeapon::Fire(const FVector\u0026amp; HitTarget) { if(FireAnimation) { WeaponMesh-\u0026gt;PlayAnimation(FireAnimation, false); } if(CasingClass) { const USkeletalMeshSocket* AmmoEjectSocket = WeaponMesh-\u0026gt;GetSocketByName(FName(\u0026#34;AmmoEject\u0026#34;)); if(AmmoEjectSocket) { FTransform SocketTransform = AmmoEjectSocket-\u0026gt;GetSocketTransform(WeaponMesh); UWorld* World = GetWorld(); if(World) { World-\u0026gt;SpawnActor\u0026lt;ACasing\u0026gt;( CasingClass, SocketTransform.GetLocation(), SocketTransform.GetRotation().Rotator() ); } } } SpendRound(); } SpendRound中，对于客户端，相关的操作包括修改弹药量、更新HUD，对于本机客户端，还要增加当前状态的编号；对于服务端，除了更新弹药和HUD，还要将更新的结果返回客户端，让本机客户端修正HUD\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void AWeapon::SpendRound() { Ammo = FMath::Clamp(Ammo - 1, 0, MagCapacity); SetHUDAmmo(); if (HasAuthority()) { ClientUpdateAmmo(Ammo); } else if (BlasterOwnerCharacter \u0026amp;\u0026amp; BlasterOwnerCharacter-\u0026gt;IsLocallyControlled()) { ++Sequence; } } void AWeapon::ClientUpdateAmmo_Implementation(int32 ServerAmmo) { if(HasAuthority()) return; Ammo = ServerAmmo; --Sequence; Ammo -= Sequence; SetHUDAmmo(); } 以上的程序解决了用户在延迟较高的时候不能够及时发射子弹的问题，但是依然存在以下问题：\n假如客户端和服务端的消耗子弹数量不一致，在HUD上以及实际的弹药中会被修正，但是已经发射出去的子弹不会被消除，也包括造成的相关伤害也不会被修正。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 sequenceDiagram autonumber actor Player as 玩家输入 participant OC as 本机客户端(Owner) participant CC as 其他客户端 participant SV as 服务器 participant CCmp as UCombatComponent participant Wpn as AWeapon participant Char as Character participant HUD as HUD Player-\u0026gt;\u0026gt;OC: 点击开火 OC-\u0026gt;\u0026gt;CCmp: FireProjectileWeapon() alt EquippedWeapon 存在 CCmp-\u0026gt;\u0026gt;CCmp: bUseScatter ? TraceEndWithScatter : HitTarget CCmp-\u0026gt;\u0026gt;CCmp: LocalFire(HitTarget) CCmp-\u0026gt;\u0026gt;Char: PlayFireMontage(bAiming) CCmp-\u0026gt;\u0026gt;Wpn: Fire(HitTarget) Wpn-\u0026gt;\u0026gt;Wpn: WeaponMesh-\u0026gt;PlayAnimation() Wpn-\u0026gt;\u0026gt;Wpn: Spawn Casing (AmmoEject Socket) Wpn-\u0026gt;\u0026gt;Wpn: SpendRound() Note over OC,HUD: （本机立刻看到开火与HUD变化，降低高延迟体感） CCmp-\u0026gt;\u0026gt;SV: ServerFire(HitTarget, FireDelay) [Server,Reliable,WithValidation] SV-\u0026gt;\u0026gt;SV: ServerFire_Validate(FireDelay≈EquippedWeapon-\u0026gt;FireDelay?) alt 校验通过 SV-\u0026gt;\u0026gt;OC: MulticastFire(HitTarget) [NetMulticast,Reliable] SV-\u0026gt;\u0026gt;CC: MulticastFire(HitTarget) note over OC: IsLocallyControlled()==true → 跳过本机重复播放 alt CC 端 CC-\u0026gt;\u0026gt;CC: MulticastFire_Implementation() CC-\u0026gt;\u0026gt;CC: LocalFire(HitTarget) CC-\u0026gt;\u0026gt;Char: PlayFireMontage() CC-\u0026gt;\u0026gt;Wpn: Fire(HitTarget) Wpn-\u0026gt;\u0026gt;Wpn: WeaponMesh-\u0026gt;PlayAnimation() Wpn-\u0026gt;\u0026gt;Wpn: Spawn Casing Wpn-\u0026gt;\u0026gt;Wpn: SpendRound() end else 校验失败 SV--\u0026gt;\u0026gt;OC: 拒绝(不多播) end else 无武器 CCmp--\u0026gt;\u0026gt;OC: 返回(不处理) end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 flowchart LR %% ---------- Local Client ---------- subgraph LC[Local Client] A[\u0026#34;Click Fire\u0026#34;] --\u0026gt; B[\u0026#34;CombatComponent::FireProjectileWeapon()\u0026#34;] B --\u0026gt;|\u0026#34;bUseScatter\u0026#34;| BS[\u0026#34;HitTarget = TraceEndWithScatter(HitTarget)\u0026#34;] BS --\u0026gt; C[\u0026#34;LocalFire(HitTarget)\u0026#34;] B --\u0026gt;|\u0026#34;else\u0026#34;| C B --\u0026gt; D[\u0026#34;ServerFire(HitTarget, FireDelay)\u0026#34;] C --\u0026gt; C1[\u0026#34;Character::PlayFireMontage(bAiming)\u0026#34;] C --\u0026gt; C2[\u0026#34;EquippedWeapon::Fire(HitTarget)\u0026#34;] C2 --\u0026gt; W1[\u0026#34;AWeapon::Fire()\u0026#34;] W1 --\u0026gt; W1a[\u0026#34;PlayAnimation(FireAnimation)\u0026#34;] W1 --\u0026gt; W1b[\u0026#34;Spawn Casing if CasingClass\u0026#34;] W1 --\u0026gt; W2[\u0026#34;SpendRound()\u0026#34;] W2 --\u0026gt; W2a[\u0026#34;Ammo--, Clamp, SetHUDAmmo\u0026#34;] W2 --\u0026gt;|\u0026#34;Client and LocallyControlled\u0026#34;| W2b[\u0026#34;++Sequence\u0026#34;] end %% ---------- Server ---------- subgraph SV[Server] D --\u0026gt; V[\u0026#34;ServerFire_Validate\u0026#34;] V --\u0026gt;|\u0026#34;Not NearlyEqual(FireDelay)\u0026#34;| RJ[\u0026#34;Reject\u0026#34;] V --\u0026gt;|\u0026#34;NearlyEqual\u0026#34;| IMPL[\u0026#34;ServerFire_Implementation\u0026#34;] IMPL --\u0026gt; MCast[\u0026#34;MulticastFire(HitTarget)\u0026#34;] MCast --\u0026gt; MS[\u0026#34;MulticastFire_Implementation\u0026#34;] MS --\u0026gt;|\u0026#34;IsLocallyControlled\u0026#34;| RET[\u0026#34;return\u0026#34;] end %% ---------- Remote Clients ---------- subgraph RC[Remote Clients] MCast --\u0026gt; RM0[\u0026#34;MulticastFire_Implementation\u0026#34;] RM0 --\u0026gt; RM1[\u0026#34;LocalFire(HitTarget)\u0026#34;] RM1 --\u0026gt; RM2[\u0026#34;Character::PlayFireMontage(bAiming)\u0026#34;] RM1 --\u0026gt; RM3[\u0026#34;EquippedWeapon::Fire(HitTarget)\u0026#34;] RM3 --\u0026gt; RM4[\u0026#34;SpendRound()\u0026#34;] RM4 --\u0026gt; RM5[\u0026#34;Ammo--, Clamp, SetHUDAmmo\u0026#34;] end %% ---------- Ammo/HUD Sync ---------- subgraph Sync[Ammo/HUD Sync] W2 --\u0026gt;|\u0026#34;Server Authority\u0026#34;| RPC[\u0026#34;ClientUpdateAmmo(Ammo)\u0026#34;] RPC --\u0026gt; CU[\u0026#34;AWeapon::ClientUpdateAmmo_Implementation\u0026#34;] CU --\u0026gt; CU1[\u0026#34;Ammo = ServerAmmo; --Sequence; Ammo -= Sequence; SetHUDAmmo\u0026#34;] end 服务器回滚（延迟补偿技术） 在存在延迟的情况下，当客户端击中了某个对象时，在服务器上实际并未击中。为了让高延迟玩家在击中对方时拥有比较好的体验，可以引入服务器回滚技术。\n服务器回滚技术在主机端存储所有角色（的碰撞箱）的短时间内的历史记录，客户端在击中对象之后，将击中对象的信息，击中时间（客户端估计的服务器时间）等信息发送给服务器（使用Server RPC）； 服务器使用一个双向链表（UE中的TDoubleLinkedList\u0026lt;\u0026gt;）存储每个玩家在某个时间的信息，并且将玩家显示的击中时间和对应的碰撞箱子进行匹配（我认为在服务器帧率够高的情况下可以不进行插值以简化计算），选择两个最接近的帧进行插值，得到这个时间所对应的Box。 将现在的Box替换成回滚的Box，进行射线检测，如果击中则判定造成伤害，没有击中则不造成伤害。（这里根据不同部位造成的不同伤害进行多次判定，比如只将头部的Box设置为有碰撞进行检测，然后再将所有Box进行检测） 将现在的Box替换回来，取消掉碰撞检测。 服务器回滚的优点在于当玩家延迟较高时，不会产生客户端看上去击中，但是实际没有命中的现象，缺点在于当客户端玩家延迟过高时，其他玩家会发现自己进入掩体后仍然会受到伤害，这明显降低了其他玩家的体验，所以需要进行权衡。\n一种解决方案是服务器控制存储的历史记录的范围，当客户端传来的命中纪录超出该范围后就不进行回滚，这时玩家需要根据根据自己的延迟进行预判射击。\n下面是实现例子：\n首先是存储每一帧的数据结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 USTRUCT(BlueprintType) struct FBoxInformation { GENERATED_BODY() UPROPERTY() FVector Location; UPROPERTY() FRotator Rotation; UPROPERTY() FVector BoxExtent; }; USTRUCT(BlueprintType) struct FFramePackage { GENERATED_BODY() UPROPERTY() float Time; UPROPERTY() TMap\u0026lt;FName, FBoxInformation\u0026gt; HitBoxInfo; }; 然后是返回的命中结果（区分爆头和普通命中）\n1 2 3 4 5 6 7 8 9 10 11 USTRUCT(BlueprintType) struct FServerSideRewindResult { GENERATED_BODY() UPROPERTY() bool bHitConfirmed; UPROPERTY() bool bHeadShot; }; 接下来是相应的实现，放在一个Actor Component中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void ULagCompensationComponent::ServerScoreRequest_Implementation(ABlasterCharacter* HitCharacter, const FVector_NetQuantize\u0026amp; TraceStart, const FVector_NetQuantize\u0026amp; HitLocation, float HitTime, class AWeapon* DamageCauser) { FServerSideRewindResult Confirm = ServerSideRewind(HitCharacter, TraceStart, HitLocation, HitTime); if (Character \u0026amp;\u0026amp; HitCharacter \u0026amp;\u0026amp; DamageCauser \u0026amp;\u0026amp; Confirm.bHitConfirmed) { UGameplayStatics::ApplyDamage( HitCharacter, DamageCauser-\u0026gt;GetDamage(), Character-\u0026gt;Controller, DamageCauser, UDamageType::StaticClass() ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 FServerSideRewindResult ULagCompensationComponent::ServerSideRewind(class ABlasterCharacter* HitCharacter, const FVector_NetQuantize\u0026amp; TraceStart, const FVector_NetQuantize\u0026amp; HitLocation, float HitTime) { bool bReturn = HitCharacter == nullptr || HitCharacter-\u0026gt;GetLagCompensation() == nullptr || HitCharacter-\u0026gt;GetLagCompensation()-\u0026gt;FrameHistory.GetHead() == nullptr || HitCharacter-\u0026gt;GetLagCompensation()-\u0026gt;FrameHistory.GetTail() == nullptr; if (bReturn) return FServerSideRewindResult(); // Frame package that we check to verify a hit FFramePackage FrameToCheck; bool bShouldInterpolate = true; // Frame history of the HitCharacter const TDoubleLinkedList\u0026lt;FFramePackage\u0026gt;\u0026amp; History = HitCharacter-\u0026gt;GetLagCompensation()-\u0026gt;FrameHistory; const float OldestHistoryTime = History.GetTail()-\u0026gt;GetValue().Time; const float NewestHistoryTime = History.GetHead()-\u0026gt;GetValue().Time; if (OldestHistoryTime \u0026gt; HitTime) { // too far back - too laggy to do SSR return FServerSideRewindResult(); } if (OldestHistoryTime == HitTime) { FrameToCheck = History.GetTail()-\u0026gt;GetValue(); bShouldInterpolate = false; } if (NewestHistoryTime \u0026lt;= HitTime) { FrameToCheck = History.GetHead()-\u0026gt;GetValue(); bShouldInterpolate = false; } TDoubleLinkedList\u0026lt;FFramePackage\u0026gt;::TDoubleLinkedListNode* Younger = History.GetHead(); TDoubleLinkedList\u0026lt;FFramePackage\u0026gt;::TDoubleLinkedListNode* Older = Younger; while (Older-\u0026gt;GetValue().Time \u0026gt; HitTime) // is Older still younger than HitTime? { // March back until: OlderTime \u0026lt; HitTime \u0026lt; YoungerTime if (Older-\u0026gt;GetNextNode() == nullptr) break; Older = Older-\u0026gt;GetNextNode(); if (Older-\u0026gt;GetValue().Time \u0026gt; HitTime) { Younger = Older; } } if (Older-\u0026gt;GetValue().Time == HitTime) // highly unlikely, but we found our frame to check { FrameToCheck = Older-\u0026gt;GetValue(); bShouldInterpolate = false; } if (bShouldInterpolate) { // Interpolate between Younger and Older FrameToCheck = InterpBetweenFrames(Older-\u0026gt;GetValue(), Younger-\u0026gt;GetValue(), HitTime); } return ConfirmHit(FrameToCheck, HitCharacter, TraceStart, HitLocation); } FFramePackage ULagCompensationComponent::InterpBetweenFrames(const FFramePackage\u0026amp; OlderFrame, const FFramePackage\u0026amp; YoungerFrame, float HitTime) { const float Distance = YoungerFrame.Time - OlderFrame.Time; const float InterpFraction = FMath::Clamp((HitTime - OlderFrame.Time) / Distance, 0.f, 1.f); FFramePackage InterpFramePackage; InterpFramePackage.Time = HitTime; for (auto\u0026amp; YoungerPair : YoungerFrame.HitBoxInfo) { const FName\u0026amp; BoxInfoName = YoungerPair.Key; const FBoxInformation\u0026amp; OlderBox = OlderFrame.HitBoxInfo[BoxInfoName]; const FBoxInformation\u0026amp; YoungerBox = YoungerFrame.HitBoxInfo[BoxInfoName]; FBoxInformation InterpBoxInfo; InterpBoxInfo.Location = FMath::Lerp(OlderBox.Location, YoungerBox.Location, InterpFraction); // 用Quat插值Rotation FQuat QuatA = OlderBox.Rotation.Quaternion(); FQuat QuatB = YoungerBox.Rotation.Quaternion(); InterpBoxInfo.Rotation = FQuat::Slerp(QuatA, QuatB, InterpFraction).Rotator(); InterpBoxInfo.BoxExtent = YoungerBox.BoxExtent; InterpFramePackage.HitBoxInfo.Add(BoxInfoName, InterpBoxInfo); } return InterpFramePackage; } 以下是检查命中的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 FServerSideRewindResult ULagCompensationComponent::ConfirmHit(const FFramePackage\u0026amp; Package, ABlasterCharacter* HitCharacter, const FVector_NetQuantize\u0026amp; TraceStart, const FVector_NetQuantize\u0026amp; HitLocation) { if (HitCharacter == nullptr) return FServerSideRewindResult(); FFramePackage CurrentFrame; CacheBoxPositions(HitCharacter, CurrentFrame); MoveBoxes(HitCharacter, Package); EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::NoCollision); // Enable collision for the head first UBoxComponent* HeadBox = HitCharacter-\u0026gt;HitCollisionBoxes[FName(\u0026#34;head\u0026#34;)]; HeadBox-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); HeadBox-\u0026gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block); FHitResult ConfirmHitResult; const FVector TraceEnd = TraceStart + (HitLocation - TraceStart) * 1.25f; UWorld* World = GetWorld(); if (World) { World-\u0026gt;LineTraceSingleByChannel( ConfirmHitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility ); if (ConfirmHitResult.bBlockingHit) // we hit the head, return early { ResetHitBoxes(HitCharacter, CurrentFrame); EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics); return FServerSideRewindResult{true, true}; } else // didn\u0026#39;t hit head, check the rest of the boxes { for (auto\u0026amp; HitBoxPair : HitCharacter-\u0026gt;HitCollisionBoxes) { if (HitBoxPair.Value != nullptr) { HitBoxPair.Value-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); HitBoxPair.Value-\u0026gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Block); } } World-\u0026gt;LineTraceSingleByChannel( ConfirmHitResult, TraceStart, TraceEnd, ECollisionChannel::ECC_Visibility ); if (ConfirmHitResult.bBlockingHit) { ResetHitBoxes(HitCharacter, CurrentFrame); EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics); return FServerSideRewindResult{true, false}; } } } ResetHitBoxes(HitCharacter, CurrentFrame); EnableCharacterMeshCollision(HitCharacter, ECollisionEnabled::QueryAndPhysics); return FServerSideRewindResult{false, false}; } 下面是工具函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 void ULagCompensationComponent::CacheBoxPositions(ABlasterCharacter* HitCharacter, FFramePackage\u0026amp; OutFramePackage) { if (HitCharacter == nullptr) return; for (auto\u0026amp; HitBoxPair : HitCharacter-\u0026gt;HitCollisionBoxes) { if (HitBoxPair.Value != nullptr) { FBoxInformation BoxInfo; BoxInfo.Location = HitBoxPair.Value-\u0026gt;GetComponentLocation(); BoxInfo.Rotation = HitBoxPair.Value-\u0026gt;GetComponentRotation(); BoxInfo.BoxExtent = HitBoxPair.Value-\u0026gt;GetScaledBoxExtent(); OutFramePackage.HitBoxInfo.Add(HitBoxPair.Key, BoxInfo); } } } void ULagCompensationComponent::MoveBoxes(ABlasterCharacter* HitCharacter, const FFramePackage\u0026amp; Package) { if (HitCharacter == nullptr) return; for (auto\u0026amp; HitBoxPair : HitCharacter-\u0026gt;HitCollisionBoxes) { if (HitBoxPair.Value != nullptr) { HitBoxPair.Value-\u0026gt;SetWorldLocation(Package.HitBoxInfo[HitBoxPair.Key].Location); HitBoxPair.Value-\u0026gt;SetWorldRotation(Package.HitBoxInfo[HitBoxPair.Key].Rotation); HitBoxPair.Value-\u0026gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent); } } } void ULagCompensationComponent::ResetHitBoxes(ABlasterCharacter* HitCharacter, const FFramePackage\u0026amp; Package) { if (HitCharacter == nullptr) return; for (auto\u0026amp; HitBoxPair : HitCharacter-\u0026gt;HitCollisionBoxes) { if (HitBoxPair.Value != nullptr) { HitBoxPair.Value-\u0026gt;SetWorldLocation(Package.HitBoxInfo[HitBoxPair.Key].Location); HitBoxPair.Value-\u0026gt;SetWorldRotation(Package.HitBoxInfo[HitBoxPair.Key].Rotation); HitBoxPair.Value-\u0026gt;SetBoxExtent(Package.HitBoxInfo[HitBoxPair.Key].BoxExtent); HitBoxPair.Value-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } } } 服务器回滚技术在投射类武器的实现 假如需要对发射的子弹使用服务器回滚技术来提升玩家体验，我们需要两种ProjectTile：复制的和不复制的.\n修正：对于上图中Server-Not Locally Controlled的情况，在武器使用SSR技术的时候，也需要发射SSR的子弹，并在击中目标时进行条件判断自己是否通过造成伤害。\n限制服务器回滚 假设根据变量float HighPingThreshold = 50.f;来修改是否限制服务器回滚，超过该限制则禁用，否则打开服务器回滚\n设置武器回调函数 ​\t由于是否使用服务器回滚技术目前是绑定武器的，所以首先要将武器是否使用回滚技术设置为复制变量，并且设置为复制到武器拥有者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY(Replicated, EditAnywhere) bool bUseServerSideRewind = false; UFUNCTION() void OnPingTooHigh(bool bPingTooHigh); void AWeapon::GetLifetimeReplicatedProps(TArray\u0026lt;class FLifetimeProperty\u0026gt;\u0026amp; OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps); DOREPLIFETIME(AWeapon, WeaponState); DOREPLIFETIME_CONDITION(AWeapon, bUseServerSideRewind, COND_OwnerOnly); } void AWeapon::OnPingTooHigh(bool bPingTooHigh) { bUseServerSideRewind = !bPingTooHigh; } 设置Controller代理以及广播条件 1 2 3 4 5 6 7 8 9 10 11 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FHighPingDelegate, bool, bPingTooHigh); UCLASS() class BLASTERS_API ABlasterPlayerController : public APlayerController { GENERATED_BODY() FHighPingDelegate HighPingDelegate; UFUNCTION(Server, Reliable) void ServerReportPingStatus(bool bHighPing); } 在装备或者丢下武器时，绑定或者解绑回调函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 void AWeapon::OnEquipped() { ShowPickUpWidget(false); AreaSphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); WeaponMesh-\u0026gt;SetSimulatePhysics(false); WeaponMesh-\u0026gt;SetEnableGravity(false); WeaponMesh-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); if(WeaponType == EWeaponType::EWT_SubmachineGun) { WeaponMesh-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); WeaponMesh-\u0026gt;SetEnableGravity(true); WeaponMesh-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); } EnableCustomDepth(false); BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetOwner()) : BlasterOwnerCharacter; if (BlasterOwnerCharacter \u0026amp;\u0026amp; bUseServerSideRewind) { BlasterOwnerController = BlasterOwnerController == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(BlasterOwnerCharacter-\u0026gt;Controller) : BlasterOwnerController; if (BlasterOwnerController \u0026amp;\u0026amp; HasAuthority() \u0026amp;\u0026amp; !BlasterOwnerController-\u0026gt;HighPingDelegate.IsBound()) { BlasterOwnerController-\u0026gt;HighPingDelegate.AddDynamic(this, \u0026amp;AWeapon::OnPingTooHigh); } } } void AWeapon::OnEquippedSecondary() { ShowPickUpWidget(false); AreaSphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); WeaponMesh-\u0026gt;SetSimulatePhysics(false); WeaponMesh-\u0026gt;SetEnableGravity(false); WeaponMesh-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); if(WeaponType == EWeaponType::EWT_SubmachineGun) { WeaponMesh-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); WeaponMesh-\u0026gt;SetEnableGravity(true); WeaponMesh-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Ignore); } EnableCustomDepth(true); if(WeaponMesh) { WeaponMesh-\u0026gt;SetCustomDepthStencilValue(CUSTOM_DEPTH_TAN); WeaponMesh-\u0026gt;MarkRenderStateDirty(); } BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetOwner()) : BlasterOwnerCharacter; if (BlasterOwnerCharacter) { BlasterOwnerController = BlasterOwnerController == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(BlasterOwnerCharacter-\u0026gt;Controller) : BlasterOwnerController; if (BlasterOwnerController \u0026amp;\u0026amp; HasAuthority() \u0026amp;\u0026amp; BlasterOwnerController-\u0026gt;HighPingDelegate.IsBound()) { BlasterOwnerController-\u0026gt;HighPingDelegate.RemoveDynamic(this, \u0026amp;AWeapon::OnPingTooHigh); } } } void AWeapon::OnDropped() { if(HasAuthority()) { AreaSphere-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryOnly); } WeaponMesh-\u0026gt;SetSimulatePhysics(true); WeaponMesh-\u0026gt;SetEnableGravity(true); WeaponMesh-\u0026gt;SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics); WeaponMesh-\u0026gt;SetCollisionResponseToAllChannels(ECollisionResponse::ECR_Block); WeaponMesh-\u0026gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Pawn, ECollisionResponse::ECR_Ignore); WeaponMesh-\u0026gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Camera, ECollisionResponse::ECR_Ignore); WeaponMesh-\u0026gt;SetCustomDepthStencilValue(CUSTOM_DEPTH_BLUE); WeaponMesh-\u0026gt;MarkRenderStateDirty(); EnableCustomDepth(true); BlasterOwnerCharacter = BlasterOwnerCharacter == nullptr ? Cast\u0026lt;ABlasterCharacter\u0026gt;(GetOwner()) : BlasterOwnerCharacter; if (BlasterOwnerCharacter) { BlasterOwnerController = BlasterOwnerController == nullptr ? Cast\u0026lt;ABlasterPlayerController\u0026gt;(BlasterOwnerCharacter-\u0026gt;Controller) : BlasterOwnerController; if (BlasterOwnerController \u0026amp;\u0026amp; HasAuthority() \u0026amp;\u0026amp; BlasterOwnerController-\u0026gt;HighPingDelegate.IsBound()) { BlasterOwnerController-\u0026gt;HighPingDelegate.RemoveDynamic(this, \u0026amp;AWeapon::OnPingTooHigh); } } } 此外每隔固定时间也要进行Ping检查，并且调用Server RPC来进行广播\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void ABlasterPlayerController::CheckPing(float DeltaTime) { if (HasAuthority()) { return; } HighPingRunningTime += DeltaTime; if (HighPingRunningTime \u0026gt; CheckPingFrequency) { if (!PlayerState) { PlayerState = GetPlayerState\u0026lt;APlayerState\u0026gt;(); } if (PlayerState) { if (PlayerState-\u0026gt;GetPingInMilliseconds() \u0026gt; HighPingThreshold) { HighPingWarning(); PingAnimationRunningTime = 0.f; ServerReportPingStatus(true); } else { ServerReportPingStatus(false); } } HighPingRunningTime = 0.f; } bool bHighPingAnimationPlaying = BlasterHUD \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;HighPingAnimation \u0026amp;\u0026amp; BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;IsAnimationPlaying(BlasterHUD-\u0026gt;CharacterOverlay-\u0026gt;HighPingAnimation); if (bHighPingAnimationPlaying) { PingAnimationRunningTime += DeltaTime; if (PingAnimationRunningTime \u0026gt; HighPingDuration) { StopHighPingWarning(); } } } void ABlasterPlayerController::ServerReportPingStatus_Implementation(bool bHighPing) { HighPingDelegate.Broadcast(bHighPing); } ","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unrealonline/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e相关课程：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/\"\u003ehttps://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这篇笔记简单介绍如何在UE5.5中建立一个在线链接，包含OnlineSubsystem的使用方法，自定义代理的建立等内容。\u003c/p\u003e\n\u003cp\u003e效果如下：\u003c/p\u003e\n\u003c!-- raw HTML omitted --\u003e\n\u003cp\u003e在steam登录的情况下，在2台不同的主机上可以建立链接，在一个大厅中进行游玩（注意需要不同的账号，以及相同的地域）。\u003c/p\u003e\n\u003ch2 id=\"配置文件设置\"\u003e配置文件设置\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003eDefaultEngine.ini\u003c/code\u003e中，添加以下内容：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-ini\" data-lang=\"ini\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e[/Script/Engine.GameEngine]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003e+NetDriverDefinitions\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e(DefName=\u0026#34;GameNetDriver\u0026#34;,DriverClassName=\u0026#34;OnlineSubsystemSteam.SteamNetDriver\u0026#34;,DriverClassNameFallback=\u0026#34;OnlineSubsystemUtils.IpNetDriver\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e[OnlineSubsystem]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003eDefaultPlatformService\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003eSteam\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e[OnlineSubsystemSteam]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003ebEnabled\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003eSteamDevAppId\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e480\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003ebInitServerOnClient\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e[/Script/OnlineSubsystemSteam.SteamNetDriver]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003eNetConnectionClassName\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;OnlineSubsystemSteam.SteamNetConnection\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e480是一个公用的游戏id\u003c/p\u003e\n\u003cp\u003e在\u003ccode\u003eDefaultGame.ini\u003c/code\u003e中添加\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-ini\" data-lang=\"ini\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003e[/Script/Engine.GameSession]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"na\"\u003eMaxPlayers\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e100\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e规定了最大玩家数量。\u003c/p\u003e\n\u003ch2 id=\"插件创建\"\u003e插件创建\u003c/h2\u003e\n\u003cp\u003e在编辑器的插件设置中可以创建相应的插件，并且在游戏中利用这些插件，以实现代码或者蓝图的复用。插件和游戏存在以下的单项依赖关系：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250519182751415\" loading=\"lazy\" src=\"/posts/unrealengine/unrealonline/image-20250519182751415.png\"\u003e\u003c/p\u003e\n\u003cp\u003e例如，游戏模块可以依赖于游戏插件或者其他模块，但是插件不可依赖于游戏模块。\u003c/p\u003e\n\u003cp\u003e在创建插件时，选择\u003ccode\u003eBlank\u003c/code\u003e模板，创建后在\u003ccode\u003eMultiplayerSessions.uplugin\u003c/code\u003e中添加依赖：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"err\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026#34;Modules\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;MultiplayerSessions\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Type\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Runtime\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;LoadingPhase\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;Default\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nt\"\u003e\u0026#34;Plugins\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:[\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;OnlineSubsystem\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Enabled\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;OnlineSubsystemSteam\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nt\"\u003e\u0026#34;Enabled\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003ccode\u003eMultiplayerSessions.Build.cs\u003c/code\u003e\u003c/p\u003e","title":"UnrealOnline"},{"content":"介绍UnrealEngine C++常用的调试方法\nUE_LOG 打印的格式如下：\n1 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 如果使用FString格式如下\n1 2 FString Name = GetName(); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name); 在已经打包好的游戏中要看到log，可以在exe所在的位置开启命令行，输入\n1 MenuSystem.exe -log 表示开启log同时运行游戏\n绘制调试射线、球 1 #include \u0026#34;Engine/World.h\u0026#34; 引入该头文件获得UWorld\n1 2 3 4 #include \u0026#34;DrawDebugHelpers.h\u0026#34; DrawDebugLine(GetWorld(), Start, End, FColor::Red); DrawDebugSphere(GetWorld(), End, 10, 10, FColor::Blue, false, 5); 绘制调试摄像机 在枪械开火时，从玩家视点绘制调试摄像机图形\n1 2 3 4 5 6 7 8 9 APawn* OwnerPawn = Cast\u0026lt;APawn\u0026gt;(GetOwner()); if(OwnerPawn == nullptr) return; AController* OwnerController = OwnerPawn-\u0026gt;GetController; if(OwnerController == nullptr) return; FVector Location; FRotator Rotation; OwnerController-\u0026gt;GetPlayerViewPoint(Location, Rotation); DrawDebugCamera(GetWorld(), Location, Rotation, 90, 2, FColor::Red, true); 在屏幕上绘制调试信息 1 2 3 4 5 6 7 8 9 if(GEngine) { GEngine-\u0026gt;AddOnScreenDebugMessage( -1, 15.f, FColor::Cyan, FString::Printf(TEXT(\u0026#34;Joining Match Type: %s\u0026#34;), *MatchType) ); } -1表示这条调试信息不会被覆盖，15.f表示在屏幕持续时间为15秒，FColor::Cyan表示调试信息的颜色，FString::Printf(TEXT(\u0026quot;Joining Match Type: %s\u0026quot;), *MatchType)用于进行输出内容的格式化\n绘制某枪管指向的射线 1 2 3 4 5 6 7 if(bWeaponEquipped \u0026amp;\u0026amp; EquippedWeapon \u0026amp;\u0026amp; EquippedWeapon-\u0026gt;GetWeaponMesh() \u0026amp;\u0026amp; BlasterCharacter-\u0026gt;GetMesh()){ FTransform MuzzleTipTransform = EquippedWeapon-\u0026gt;GetWeaponMesh()-\u0026gt;GetSocketTransform(FName(\u0026#34;MuzzleFlash\u0026#34;), RTS_World); FVector MuzzleX(FRotationMatrix(MuzzleTipTransform.GetRotation().Rotator()).GetUnitAxis(EAxis::X)); DrawDebugLine(GetWorld(), MuzzleTipTransform.GetLocation(), MuzzleTipTransform.GetLocation() + MuzzleX * 1000.f, FColor::Red); DrawDebugLine(GetWorld(), MuzzleTipTransform.GetLocation(), BlasterCharacter-\u0026gt;GetHitTarget(), FColor::Orange); } 首先，获取武器骨骼上的某个Socket的transform 确保该Socket的X轴指向朝枪口前方，随后可以使用FVector MuzzleX(FRotationMatrix(MuzzleTipTransform.GetRotation().Rotator()).GetUnitAxis(EAxis::X));获取指向X轴正方向的单位向量 最后绘制调试射线 ","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unrealdebug/","summary":"\u003cp\u003e介绍UnrealEngine C++常用的调试方法\u003c/p\u003e\n\u003ch2 id=\"ue_log\"\u003eUE_LOG\u003c/h2\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果使用\u003ccode\u003eFString\u003c/code\u003e格式如下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eFString Name = GetName();\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在已经打包好的游戏中要看到log，可以在exe所在的位置开启命令行，输入\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eMenuSystem.exe -log\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e表示开启log同时运行游戏\u003c/p\u003e\n\u003ch2 id=\"绘制调试射线球\"\u003e绘制调试射线、球\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026#34;Engine/World.h\u0026#34;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e引入该头文件获得UWorld\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026#34;DrawDebugHelpers.h\u0026#34;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eDrawDebugLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetWorld\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003eStart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eEnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFColor\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eRed\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eDrawDebugSphere\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetWorld\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003eEnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFColor\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eBlue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"绘制调试摄像机\"\u003e绘制调试摄像机\u003c/h2\u003e\n\u003cp\u003e在枪械开火时，从玩家视点绘制调试摄像机图形\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eAPawn\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eOwnerPawn\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAPawn\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetOwner\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOwnerPawn\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eAController\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eOwnerController\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eOwnerPawn\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetController\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOwnerController\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"k\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFVector\u003c/span\u003e \u003cspan class=\"n\"\u003eLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFRotator\u003c/span\u003e \u003cspan class=\"n\"\u003eRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eOwnerController\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPlayerViewPoint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eDrawDebugCamera\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetWorld\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003eLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e90\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFColor\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eRed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"在屏幕上绘制调试信息\"\u003e在屏幕上绘制调试信息\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGEngine\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eGEngine\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAddOnScreenDebugMessage\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"mf\"\u003e15.f\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eFColor\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eCyan\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eFString\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTEXT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Joining Match Type: %s\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eMatchType\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e-1表示这条调试信息不会被覆盖，15.f表示在屏幕持续时间为15秒，\u003ccode\u003eFColor::Cyan\u003c/code\u003e表示调试信息的颜色，\u003ccode\u003eFString::Printf(TEXT(\u0026quot;Joining Match Type: %s\u0026quot;), *MatchType)\u003c/code\u003e用于进行输出内容的格式化\u003c/p\u003e","title":"UnrealDebug"},{"content":"坦克大战 基于UE5的坦克射击游戏，来自教程 udemy.com/course/unrealcourse/\n下载 https://github.com/wstfdxfh/Oddtanks\n和原教程中最终成品的主要区别在于：\n炮塔转动或者坦克移动时，发射的炮弹会发生随机偏差，更难瞄准敌人 使用一个射灯照出我方坦克的可能落弹点 其中，炮弹散射的实现方法如下：\n首先，在BasePawn.h中加入相关变量：\n1 2 3 4 5 6 7 8 9 10 // 记录最大偏移角度 UPROPERTY(EditAnywhere, Category=\u0026#34;Combat\u0026#34;) float MaxSpreadAngle=5.f; // 当前实时最大偏转角度（度数），由 Tick 更新 UPROPERTY(VisibleAnywhere, Category=\u0026#34;Combat\u0026#34;) float CurrentMaxSpread = 0.f; FTransform LastTransform; bool IsMoving = false; 随后在BasePawn的Tick函数中，检测有没有发生移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ABasePawn::Tick(float DeltaTime) { Super::Tick(DeltaTime); // 判断当前炮塔或者本体是否在移动或者转动 FTransform TurretMeshTransform = TurretMesh-\u0026gt;GetComponentTransform(); IsMoving = !TurretMeshTransform.GetRotation().Equals(LastTransform.GetRotation(), 0.2*DeltaTime) || !TurretMeshTransform.GetLocation().Equals(LastTransform.GetLocation(), 1*DeltaTime); LastTransform = TurretMeshTransform; if(IsMoving) { CurrentMaxSpread = FMath::FInterpTo(CurrentMaxSpread, MaxSpreadAngle, DeltaTime, 2); } else { CurrentMaxSpread = FMath::FInterpTo(CurrentMaxSpread, 0, DeltaTime, 1); } if(Cast\u0026lt;ATank\u0026gt;(this)) { UE_LOG(LogTemp, Display, TEXT(\u0026#34;CurrentMaxSpread: %f\u0026#34;), CurrentMaxSpread) } } 这里Equals函数就是指出两个变量是否小到了一定的误差，第二个参数就是相应的误差，这里不使用==运算符的原因是，因为采用了插值处理炮塔的旋转，所以在鼠标不移动后的很长时间内，炮塔都不会完全停止转动。\n最后是改变Fire函数的细节：\n1 2 3 4 5 FVector Location = ProjectileSpawnPoint-\u0026gt;GetComponentLocation(); FRotator Rotation = ProjectileSpawnPoint-\u0026gt;GetComponentRotation(); FRotator RotationOffset(FMath::RandRange(-CurrentMaxSpread, CurrentMaxSpread), FMath::RandRange(-CurrentMaxSpread, CurrentMaxSpread), 0); auto Projectile= GetWorld()-\u0026gt;SpawnActor\u0026lt;AProjectile\u0026gt;(ProjectileClass, Location, Rotation + RotationOffset); Projectile-\u0026gt;SetOwner(this); ","permalink":"https://wstfdxfh.github.io/posts/myworks/oddtanks/","summary":"\u003ch2 id=\"坦克大战\"\u003e坦克大战\u003c/h2\u003e\n\u003cp\u003e基于UE5的坦克射击游戏，来自教程 udemy.com/course/unrealcourse/\u003c/p\u003e\n\u003cp\u003e下载 \u003ca href=\"https://github.com/wstfdxfh/Oddtanks\"\u003ehttps://github.com/wstfdxfh/Oddtanks\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e和原教程中最终成品的主要区别在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e炮塔转动或者坦克移动时，发射的炮弹会发生随机偏差，更难瞄准敌人\u003c/li\u003e\n\u003cli\u003e使用一个射灯照出我方坦克的可能落弹点\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250428230817419\" loading=\"lazy\" src=\"/posts/myworks/oddtanks/image-20250428230817419.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，炮弹散射的实现方法如下：\u003c/p\u003e\n\u003cp\u003e首先，在BasePawn.h中加入相关变量：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 记录最大偏移角度\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eUPROPERTY\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eEditAnywhere\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCategory\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Combat\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxSpreadAngle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e5.f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 当前实时最大偏转角度（度数），由 Tick 更新 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eUPROPERTY\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eVisibleAnywhere\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCategory\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Combat\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFTransform\u003c/span\u003e \u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e随后在\u003ccode\u003eBasePawn\u003c/code\u003e的Tick函数中，检测有没有发生移动\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eABasePawn\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 判断当前炮塔或者本体是否在移动或者转动\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eFTransform\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMesh\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetComponentTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.2\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFMath\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFInterpTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxSpreadAngle\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFMath\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFInterpTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eATank\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eUE_LOG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLogTemp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDisplay\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTEXT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;CurrentMaxSpread: %f\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这里Equals函数就是指出两个变量是否小到了一定的误差，第二个参数就是相应的误差，这里不使用\u003ccode\u003e==\u003c/code\u003e运算符的原因是，因为采用了插值处理炮塔的旋转，所以在鼠标不移动后的很长时间内，炮塔都不会完全停止转动。\u003c/p\u003e","title":"OddTanks"},{"content":"udemy.com/course/unrealcourse/ 以及部分https://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/的课程笔记\n常见技巧 防止速度过快导致的平台位置偏移 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AMovingPlatform::Tick(float DeltaTime){ Super::Tick(DeltaTime); FVector CurrentLocation = GetActorLocation(); CurrentLocation = CurrentLocation + (PlatformVelocity*DeltaTime); SetActorLocation(CurrentLocation); float DistanceMoved = FVector::Dist(StartLocation, CurrentLocation); if(DistanceMoved \u0026gt; MoveDistance){ // 获得速度的单位向量 FVector MoveDirection = PlatformVelocty.GetSafeNormal(); StartLocation = StartLocation+ MoveDirection*MoveDistance; SetActorLocation(StartLocation); PlatformVelocty = -PlatformVelocty; } } 解决被方块撞击时人物视角异常的问题 这是因为只有角色默认只有在移动时才会检查碰撞\n解决方法：使用蓝图中的MoveUpdatedComponent，在每一帧都移动一个小距离再反向移动\n可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n背对光源时场景过暗的问题 在场景中加入PostProcessVolume，在Lens-Exposure-Metering Mode中，将选项改为Auto Exposure Basic，然后修改Brush中的x,y,z，令其覆盖整个场景。\n不同的灯光类型 名称 解释 Point Light 从一个点向外发射的光源 Spot Light 聚光灯，有方向性地发出光线 Rect Light 方形的有方向性光源 Directional Light 太阳光（只有方向，没有位置的光） Sky Light 将远处的场景作为光源 将SceneComponent添加到角色后，角色旋转和组件旋转的差异 1 2 3 4 5 6 7 8 9 10 11 void UGrabber::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) { Super::TickComponent(DeltaTime, TickType, ThisTickFunction); auto Rotator = GetOwner()-\u0026gt;GetActorRotation(); auto MyRotation = GetComponentRotation(); auto RotatorString = Rotator.ToCompactString(); auto MyRotationString = MyRotation.ToCompactString(); // LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75) // 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转 UE_LOG(LogTemp, Display, TEXT(\u0026#34;Owner Rotation: %s, Component Rotation: %s\u0026#34;), *RotatorString, *MyRotationString); } 其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。\n如何创建一个摄像头投射并且和特定物品交互(Grabber) 首先新建一个Trace Channel\n前往Project Settings-Engine-Collision在Trace Channels中新建Channel，取名叫做Grabber，默认ignore。重启编辑器\n1 2 3 4 5 6 7 8 9 10 bool UGrabber::GetGrabableInReach(FHitResult\u0026amp; OutHitResult) const { FVector Start = GetComponentLocation(); FVector End = Start + GetForwardVector()*MaxGrabDistance; DrawDebugLine(GetWorld(), Start, End, FColor::Red); FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius); bool HasHit = GetWorld()-\u0026gt;SweepSingleByChannel( OutHitResult, Start, End,FQuat::Identity, ECC_GameTraceChannel2,Sphere); return HasHit; } 这里的ECC_GameTraceChannel2就是Grabber通道，具体需要在项目目录下的/config/DefaultEngine.ini查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void UGrabber::Grab() { UPhysicsHandleComponent *PhysicsHandle = GetPhysicsHandle(); FHitResult HitResult; bool HasHit = GetGrabableInReach(HitResult); if(PhysicsHandle \u0026amp;\u0026amp; HasHit) { AActor *HitActor = HitResult.GetActor(); HitActor-\u0026gt;Tags.Add(\u0026#34;Grabbed\u0026#34;); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;The raycast has hit %s\u0026#34;), *HitActor-\u0026gt;GetActorNameOrLabel()); UPrimitiveComponent * HitComponent = HitResult.GetComponent(); HitComponent-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;GrabComponentAtLocationWithRotation( HitComponent, NAME_None, HitResult.ImpactPoint, GetComponentRotation() ); } } 其中，HitComponent-\u0026gt;WakeAllRigidBodies();的目的是为了防止部分静止时间较长的物体不在模拟物理效果，而手动进行唤醒\n要放开物品的时候代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void UGrabber::Release() { UPhysicsHandleComponent* PhysicsHandle = GetPhysicsHandle(); if(PhysicsHandle \u0026amp;\u0026amp; PhysicsHandle-\u0026gt;GetGrabbedComponent()!=nullptr) { AActor* GrabbedActor = PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;GetOwner(); GrabbedActor-\u0026gt;Tags.Remove(\u0026#34;Grabbed\u0026#34;); PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;ReleaseComponent(); } } 物体碰撞关系 两个物体之间的碰撞关系依赖于两者的collision的组合：\nIgnore Overlap Block Ignore Ignore Ignore Ignore Overlap Ignore Overlap Overlap Block Ignore Overlap Block 除此以外，还需要在碰撞双方的选项中启用Generate overlap events\n强制转换与组件接触 Unreal中，UPrimitiveComponent是包含了物理性质的组件，而USceneComponent是其父组件，为了可以获取Actor的可能的UPrimitiveComponent，可以使用指针强制类型转换。完整强制转换与组件接触代码如下：\n1 2 3 4 5 6 7 UPrimitiveComponent* Component = Cast\u0026lt;UPrimitiveComponent\u0026gt;(Actor-\u0026gt;GetRootComponent()); if(Component!=nullptr) { Component-\u0026gt;SetSimulatePhysics(false); } Actor-\u0026gt;AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform); Mover-\u0026gt;SetShouldMove(true); Cast\u0026lt;\u0026gt;() 用于将 UObject 或其子类指针安全转换为子类类型。\n1 2 3 4 5 AActor* Actor = GetOwner(); AMyCharacter* MyChar = Cast\u0026lt;AMyCharacter\u0026gt;(Actor); if (MyChar) { // 转换成功，可安全使用 } 失败时返回 nullptr 仅适用于 UObject 派生类 比 dynamic_cast 更高效 角色常用组件以及相关类简介 1. USceneComponent Transform: 具有变换（位置、旋转、缩放）功能。 Attachment: 可以附加到其他组件上。 视觉内容: 没有视觉内容，主要用于场景中的逻辑组织。 2. UCapsuleComponent 继承自: USceneComponent 作用: 主要用于处理碰撞检测。 3. UStaticMeshComponent 继承自: USceneComponent 作用: 主要用于视觉展示，可以加载静态网格体。 4. Actor 及其子类 包括: Pawn, Character 等。 RootComponent: 类型为 USceneComponent*，是 Actor 的根组件。 修改 RootComponent: 可以通过修改 RootComponent 来改变其类型，例如将其设置为 UCapsuleComponent。 5.USpringArmComponent 作为摄像机的支架（“弹簧臂”），用于设置摄像机与角色或物体之间的距离与角度；自动处理摄像机的碰撞检测和视野遮挡问题。 6.UCameraComponent 提供游戏视角，定义玩家视野范围、视野角度（FOV）及视图旋转等参数。通常配合USpringArmComponent使用，实现第三人称视角。 通常在第三人称游戏中，将USpringArmComponent的bUsePawnControlRotation设为true，同时将UCameraComponent的同名属性设为false，以便更灵活地调整视野。 7. Actor Component (生命值组件) 为了在多个Actor上实现类似的功能，可以建立一个ActorComponent组件，它是SceneComponent的父类，不包含坐标等信息。\n创建一个HealthComponent作为Actor Component的子组件，加上最大生命值、生命值等变量。关键是，当Owner受到伤害时，需要进行相应的操作。\n要将ActorComponent的函数在Actor受到伤害时调用，需要实现以下步骤：\n在头文件中声明回调函数\n1 2 3 UFUNCTION() void DamageTaken(AActor* DamagedActor, float Damage, const UDamageType* Damagetype, AController* Instigator, AActor* DamageCauser); Beginplay函数中添加\n1 GetOwner()-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;UHealthComponent::DamageTaken); 实现DamageTaken\n在造成伤害的Actor中实现HitEvent\n前向声明 仅在 .cpp 中包含实际使用的内容 在 .h 中应尽量少包含 声明指针时无需包含对应头文件 构造对象时需要包含对应头文件 访问成员时需要包含对应头文件 继承时需要包含对应头文件 UE5 C++ 输入绑定与移动实现 Pawn示例（如坦克）： 1. 设置输入（在 Project Settings → Input 中） 添加 Axis Mappings： MoveForward → W/S 或 Up/Down Turn → A/D 或 Left/Right 添加Action Mapping 2. C++ 输入绑定声明 在 ATank 类头文件中添加：\n1 virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override; 3. 输入绑定 1 2 3 4 5 6 7 void ATank::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveForward\u0026#34;), this, \u0026amp;ATank::Move); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Turn\u0026#34;), this, \u0026amp;ATank::Turn); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Fire\u0026#34;),IE_Pressed, this, \u0026amp;ATank::Fire); } 4. 移动旋转函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 void ATank::Move(float Value) { FVector DeltaLocation = FVector::ZeroVector; DeltaLocation.X = Value * Speed * UGameplayStatics::GetWorldDeltaSeconds(this); AddActorLocalOffset(DeltaLocation, true); } void ATank::Turn(float Value) { FRotator DeltaRotation = FRotator::ZeroRotator; DeltaRotation.Yaw = Value * TurnRate * UGameplayStatics::GetWorldDeltaSeconds(this); AddActorLocalRotation(DeltaRotation, true); } 说明 TEXT(\u0026quot;MoveForward\u0026quot;) 对应输入设置中定义的名称 this 为当前对象 \u0026amp;ATank::Move 为响应函数地址 UGameplayStatics::GetWorldDeltaSeconds(this) 获取每帧的时间差，确保帧率无关的平滑移动 Character示例（比如手持枪械的人类）与手柄绑定： 首先在设置中设置移动和视角移动对应的映射\n这里将使用手柄控制和使用鼠标控制视角移动采用不同映射的目的是，使用鼠标移动视角的时候，鼠标的移动距离会和帧数同步变化，而手柄不会。\n接下来实现Charactor中的绑定函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Called to bind functionality to input void AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveForward\u0026#34;), this, \u0026amp;AShooterCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUp\u0026#34;), this, \u0026amp;APawn::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveRight\u0026#34;), this, \u0026amp;AShooterCharacter::MoveRight); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRight\u0026#34;), this, \u0026amp;APawn::AddControllerYawInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUpRate\u0026#34;), this, \u0026amp;AShooterCharacter::LookUpRate); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRightRate\u0026#34;), this, \u0026amp;AShooterCharacter::LookRightRate); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Jump\u0026#34;), IE_Pressed, this, \u0026amp;ACharacter::Jump); } 因为在Pawn中有现成的函数，所以LookUp和LookRight直接调用AddControllerPitchInput函数和AddControllerYawInput函数，而对于手柄输入，则需要乘以额外的DeltaTime和Rate，其他实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void AShooterCharacter::MoveForward(float AxisValue) { AddMovementInput(GetActorForwardVector() * AxisValue); } void AShooterCharacter::MoveRight(float AxisValue) { AddMovementInput(GetActorRightVector() * AxisValue); } void AShooterCharacter::LookUpRate(float AxisValue) { AddControllerPitchInput(AxisValue * RotationRate * GetWorld()-\u0026gt;GetDeltaSeconds()); } void AShooterCharacter::LookRightRate(float AxisValue) { AddControllerYawInput(AxisValue * RotationRate * GetWorld()-\u0026gt;GetDeltaSeconds()); } Timer简介 Timer用于定时执行函数\n对于要定时执行任务的类（比如炮塔），首先在头文件中\n1 2 FTimerHandle FireRateTimerHandle; float FireRate = 2.f; 随后在BeginPlay中\n1 GetWorldTimerManager().SetTimer(FireRateTimerHandle, this, \u0026amp;ATower::CheckFireCondition, FireRate, true); 参数名 含义 FireRateTimerHandle FTimerHandle 类型变量，用于标识并控制该定时器（可用于清除等操作） this 当前对象指针，表示调用者为当前类实例（如 ATower） \u0026amp;ATower::CheckFireCondition 定时器触发时要执行的成员函数（此处为 CheckFireCondition 方法） FireRate 时间间隔（float 类型），单位为秒，表示每次触发之间的间隔 true 是否循环执行；true 表示循环触发，false 表示只触发一次 每隔 FireRate 秒循环调用一次 CheckFireCondition 方法。 可以通过 FireRateTimerHandle 来暂停、重启或清除该定时器。 这里的Timer可以一定程度上代替Unity的协程功能\nHitEvent和多播代理 实现HitEvent事件绑定步骤如下：\n使用 UStaticMeshComponent* 触发碰撞事件时，需依赖其父类 UPrimitiveComponent 的功能。\nOnComponentHit 是一个 Multicast Delegate，可绑定多个函数，在组件发生碰撞后依次触发。\n添加回调函数（头文件中）\n1 2 3 UFUNCTION() void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit); HitComp: 当前发生碰撞的组件 OtherActor: 被碰撞的 Actor OtherComp: 被碰撞的组件 NormalImpulse: 冲击力 Hit: 碰撞信息结构体 在 BeginPlay 中绑定事件 1 ProjectileMesh-\u0026gt;OnComponentHit.AddDynamic(this, \u0026amp;AProjectile::OnHit); AddDynamic(对象, 回调函数) 实现动态绑定 实现函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 void AProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit) { auto Owner = GetOwner(); if(Owner == nullptr) return; auto Instigator = Owner-\u0026gt;GetInstigatorController(); auto DamageTypeClass = UDamageType::StaticClass(); if(OtherActor \u0026amp;\u0026amp; OtherActor!=this \u0026amp;\u0026amp; OtherActor!=Owner) { UGameplayStatics::ApplyDamage(OtherActor, Damage, Instigator, this, DamageTypeClass); Destroy(); } } 角色死亡实现 组件调用流程\nProjectile 调用 ApplyDamage() 到 HealthComponent HealthComponent.DamageTaken() 当生命值 ≤ 0 时触发 ActorDied() GameMode.ActorDied() 在 Pawn.HandleDestruction() 中执行销毁逻辑 实现步骤\n在 Pawn 类中创建 HandleDestruction() 函数 在 GameMode（或 HealthComponent）中创建 ActorDied() 函数 在 ActorDied() 内调用 HandleDestruction() 在 HealthComponent.DamageTaken() 中判断生命值 ≤ 0，调用 ActorDied() 带参数函数Timer回调绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void AToonTanksGameMode::HandleGameStart() { Tank = Cast\u0026lt;ATank\u0026gt;(UGameplayStatics::GetPlayerPawn(this, 0)); ToonTanksPlayerController = Cast\u0026lt;AToonTanksPlayerController\u0026gt;( UGameplayStatics::GetPlayerController(this,0)); if(ToonTanksPlayerController) { ToonTanksPlayerController-\u0026gt;SetPlayerEnabledState(false); FTimerHandle PlayerEnableTimerHandle; FTimerDelegate PlayerenableTimerDelegate = FTimerDelegate::CreateUObject( ToonTanksPlayerController, \u0026amp;AToonTanksPlayerController::SetPlayerEnabledState, true ); GetWorldTimerManager().SetTimer( PlayerEnableTimerHandle, PlayerenableTimerDelegate, StartDelay, false ); } } 其中，FTimerDelegate::CreateUObject用于创建代理，参数分别为 InUserObject：函数所在的对象，这里是ToonTanksPlayerController，函数指针，这里是\u0026amp;AToonTanksPlayerController::SetPlayerEnabledState，函数的参数，这里是true\n游戏倒计时 在GameMode.h中，实现\n1 2 UFUNCTION(BlueprintImplementableEvent) void StartGame(); 随后实现一个WBP：\n在Character类代码中生成蓝图Actor 首先在Character头文件中进行声明：\n1 2 3 4 5 UPROPERTY(EditDefaultOnly) TSubClassOf\u0026lt;AGun\u0026gt; GunClass; UPROPERTY() AGun* Gun; 然后在BeginPlay中：\n1 Gun = GetWorld()-\u0026gt;SpawnActor\u0026lt;AGun\u0026gt;(GunClass); 然后在蓝图中设置Character所需要绑定的Actor蓝图 如果原本角色的Skeletal Mesh上有这个Actor(比如枪械)，则可以使用\n1 GetMesh()-\u0026gt;HideBoneByName(TEXT(\u0026#34;weapon_r\u0026#34;), EPhysOp::PBO_None); 来隐藏原本的模型。\n现在在Skeleton蓝图中添加Socket来将新生成的Actor附加到某个骨骼上，并且命名（比如WeaponSocket）。\n1 2 Gun-\u0026gt;AttachToComponent(GetMesh(), FAttchmentTransformRules::KeepRelativeTransform, TEXT(\u0026#34;WeaponSocket\u0026#34;)); 造成伤害 首先在Gun.h中声明伤害等变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY(EditAnywhere) USceneComponent* Root; UPROPERTY(EditAnywhere) USkeletalMeshComponent* Mesh; UPROPERTY(EditAnywhere) UParticleSystem* MuzzleFlash; UPROPERTY(EditAnywhere) UParticleSystem* ImpactEffect; UPROPERTY(EditAnywhere) float MaxRange = 1000.f; UPROPERTY(EditAnywhere) float Damage = 10.f; 随后实现PullTrigger函数中的造成伤害部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 FVector Location; FRotator Rotation; OwnerController-\u0026gt;GetPlayerViewPoint(Location, Rotation); FVector End = Location + Rotation.Vector()*MaxRange; FHitResult Hit; // 在进行检测时忽视枪械本身以及所属角色 FCollisionQueryparams Params; Params.AddIgnoredActor(this); Params.AddIgnoredActor(getOwner()); bool bSuccess = GetWorld()-\u0026gt;LineTraceByChannel(Hit, Location, End, ECollisionChannel::ECC_GameTraceChannel1, Params); if(bSuccess){ FVector ShotDirection = -Rotation.Vector(); UGameplayStatics::SpawnEmittertAtLocation(GetWorld(), ImpactEffect, Hit.Location, ShotDirection); if(Hit.GetActor()!=nullptr){ FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); Hit.GetActor()-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); } } 1. FPointDamageEvent 构造函数参数 1 FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); 参数 类型 作用 Damage float 伤害值（如 10.0f）。目标 Actor 的 TakeDamage 方法会接收此值。 Hit FHitResult 射线检测的命中结果，包含： • 命中位置 (Hit.Location) • 命中法线 (Hit.Normal) • 命中的 Actor (Hit.GetActor())。 ShotDirection FVector 伤害来源方向（归一化向量）。用于计算击退、伤害角度修正等逻辑。 （此处取 -Rotation.Vector() 表示子弹从玩家指向命中点） nullptr UClass* （可选）伤害类型（UDamageType 子类）。 如果为 nullptr，则使用默认伤害类型。 2. TakeDamage 方法参数 1 Hit.GetActor()-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); 参数 类型 作用 Damage float 同 FPointDamageEvent 中的伤害值，实际传递给目标的伤害逻辑。 DamageEvent FDamageEvent\u0026amp; 伤害事件数据（此处是 FPointDamageEvent），包含伤害来源、方向等上下文信息。 OwnerController AController* 伤害的责任控制器（如玩家控制器或 AI 控制器）。 • 用于统计击杀/助攻。 • 可被 nullptr。 this AActor* 直接造成伤害的 Actor（如子弹或武器）。 • 用于触发 OnTakeDamage 事件时的来源判断。 • 可被 nullptr。 3. 覆写 TakeDamage 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 float TakeDamage ( float DamageAmount, struct FDamageEvent const \u0026amp; DamageEvent, class AController * EventInstigator, AActor * DamageCauser ){ float DamageToApply = Super::TakeDamage(DamageAmount, DamageEvent, EventInstigator, DamageCauser); DamageToApply = FMath::Min(Health, DamageToApply); Health -= DamageToApply; // 如果死亡，就令控制器失效，并且使胶囊碰撞体也失效 if(IsDead()){ DetachFromControllerPendingDestroy(); GetCapsulecomponent()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } return DamageToApply; } 创建AI敌人 1. 创建AI Controller C++创建一个继承AIController的子类\n使用蓝图创建一个基于这个C++类的子类\n将角色的AI Controller Class 改为蓝图创建的Controller\n2. 令AI可以进行视线跟随以及寻路 在场景中放置一个角色，其会被默认为AI控制的角色\n使用Nav Mesh并将其覆盖到整个地图（可以将Nav Mesh在地图中可视化），随后使用AIController的MoveTo函数进行跟随实现\n在BeginPlay，中通过\n1 2 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); SetFocus(PlayerPawn); 实现视线跟随。\n在Tick中，\n1 2 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); MoveToActor(PlayerPawn, 200); 实现跟踪\n3. 实现条件跟踪与取消跟踪 假如要在无法直接查看到玩家的情况下进行或者取消跟踪，可以使用LineOfSight方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void AShooterAIController::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (LineOfSightTo(PlayerPawn)) { SetFocus(PlayerPawn); MoveToActor(PlayerPawn, 200); } else { ClearFocus(EAIFocusPriority::Gameplay); StopMovement(); } } 行为树 首先在编辑器中创建行为树和Blackboard，如果名字后缀相同，两者会自动连接，否则需要在行为树蓝图中手动操作；\n随后，在AIController蓝图中，将行为树进行绑定，\n并且在AIControllerC++进行声明\n1 2 UPROPERTY(EditAnywhere) class UBehaviorTree* AIBehavior; 随后在Beginplay中，进行行为树的使用\n1 2 3 if(AIBehavior){ RunBehaviorTree(AIBehavior); } 黑板变量绑定 使用黑板创建一个变量，进行取名，并且在Beginplay中进行变量绑定\n1 2 3 4 5 6 7 if(AIBehavior){ RunBehaviorTree(AIBehavior); // 进行角色变量绑定 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); GetBlackboardController()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;PlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); GetBlackboardController()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;StartLocation\u0026#34;), GetPawn()-\u0026gt;GetActorLocation()); } Sequence和Selector 进行行为树的设置之后，如果没有出现错误，则sequence节点就会依次执行行为，并重复。\nSelector\n从左到右依次检查子节点。 一旦某个子节点返回 Success，停止后续检查。 用于实现行为优先级控制。 Sequence\n顺序执行所有子节点。 一旦某个子节点 Fails，整个序列 Fails。 用于实现一系列必须连续成功的子行为。 “Can See Player?” Decorator\n条件：黑板中的 PlayerLocation 被设置。 加了 Observer Aborts: Both，用于动态中断行为（详见下文）。 MoveTo: PlayerLocation / LastKnownPlayerLocation\n让 AI 移动到指定黑板位置。 特性 Selector Sequence 执行逻辑 直到某个子节点成功为止 所有子节点需按顺序全部成功 中途停止 遇到成功立即返回成功 遇到失败立即返回失败 用途 行为选择（如：追 or 查） 行为流程（如：锁定 → 移动） Observer Aborts 设置说明：\n设置类型 含义 None 条件变化不会中断任何行为。 Self 条件变化时会中断当前节点及其子树行为。 Lower Priority 条件变化时会中断右边的兄弟节点及其子树（优先级更低者）。 Both 条件变化时中断当前节点和所有右边兄弟节点，实现动态行为切换。 示例：“Can See Player?” 设置为 Abort: Both，使得看到玩家时中断 Investigate 行为，反之亦然。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AShooterAIController::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (LineOfSightTo(PlayerPawn)) { GetBlackboardComponent()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;PlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); GetBlackboardComponent()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;LastKnownPlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); } else { GetBlackboardComponent()-\u0026gt;ClearValue(TEXT(\u0026#34;PlayerLocation\u0026#34;)); } } 创建自定义C++行为树任务 如果需要创建一个自定义任务，最常见的父类包含BTTaskNode和BTTask_BlackBoardBase\n其中，BTTask_BlackBoardBase可以选择一个Blackboard key作为参数，可以在蓝图中进行指定。\n创建这个的时候，需要在SimpleShooter.Build.cs中添加\u0026quot;GamePlayTasks\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public SimpleShooter(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] { \u0026#34;Core\u0026#34;, \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;InputCore\u0026#34;, \u0026#34;GameplayTasks\u0026#34; }); PrivateDependencyModuleNames.AddRange(new string[] { }); } 使用BTTask_BlackBoardBase作为父类进行创建之后，在构造函数中取一个名称作为蓝图现实的名字\n1 2 3 4 UBTTask_ClearBlackboardValue::UBTTask_ClearBlackboardValue() { NodeName = \u0026#34;Clear Blackboard Value\u0026#34;; } 随后执行任务，假设这里的目的是清除一个变量，那么只需要覆写ExecuteTask函数\n1 2 3 4 5 6 7 EBTNodeResult::Type UBTTask_ClearBlackboardValue::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint32* NodeMemory) { Super::ExecuteTask(OwnerComp, NodeMemory); OwnerComp.GetBlackboardComponent()-\u0026gt;ClearValue(GetSelectedBlackboardKey()); return EBTNodeResult::Succeeded; } 最后行为树设置如下：\n实现射击行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 UBTTask_Shoot::UBTTask_Shoot() { NodeName = \u0026#34;Shoot\u0026#34;; } EBTNodeResult::Type UBTTask_Shoot::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) { Super::ExecuteTask(OwnerComp, NodeMemory); if (OwnerComp.GetAIOwner() == nullptr){ return EBTNodeResult::Failed; } AShooterCharacter* Character = Cast\u0026lt;AShooterCharacter\u0026gt;(OwnerComp.GetAIOwner()-\u0026gt;GetPawn()); if (Character == nullptr){ return EBTNodeResult::Failed; } Character-\u0026gt;Shoot(); return EBTNodeResult::Succeeded; } BTService 行为树服务 在AI跟踪玩家的时候，我们希望时刻知道玩家的位置并且让AI移动到该位置，之前该功能在Tick中实现，但实际上可以使用行为树的Service实现。使用Service实现的原因包括：\n简化Tick函数中的代码，并且只在某个节点执行对应代码，减少了计算量 我们有时只希望在行为树的某个状态下实行某种更新 有许多默认服务，比如SetDefaultFocus可以让AI朝向某处（比如玩家位置）\n要实现自定义服务，使用C++继承BTService或者BTService_BlackboardBase，它们的区别和之前的Task相同。\n1 2 3 4 5 6 7 8 9 10 11 12 UBTService_PlayerLocation::UBTService_PlayerLocation() { NodeName = \u0026#34;Update Player Location\u0026#34;; } void UBTService_PlayerLocation::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (PlayerPawn == nullptr) { return; } OwnerComp.GetBlackboardComponent()-\u0026gt;SetValueAsVector(GetSelectedBlackboardKey(), PlayerPawn-\u0026gt;GetActorLocation()); } 最后的行为树如下所示：\n游戏结束处理 游戏结束时的流程如下：\n当一个Character受到伤害而且HP为0时，它会调用一个自定义GameMode的行为，并令其判断如何结束游戏；\n这个GameMode核实游戏结果之后，调用对应的Controller的GameHasended方法。这里的GameMode和Controller都需要重新设置C++子类和对应蓝图，以提升灵活性，具体如下图所示：\nShooterCharacter.cpp的IsDead部分改写如下：\n1 2 3 4 5 6 7 8 if (IsDead()) { ASimpleShooterGameModeBase* GameMode = GetWorld() -\u0026gt; GetAuthGameMode\u0026lt;ASimpleShooterGameModeBase\u0026gt;(); if (GameMode != nullptr) { GameMode-\u0026gt;PawnKilled(this); } DetachFromControllerPendingDestroy(); GetCapsuleComponent()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } PawnKilled函数实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 void AKillEmAllGameMode::PawnKilled(APawn* PawnKilled) { Super::PawnKilled(PawnKilled); APlayerController* PlayerController = Cast\u0026lt;APlayerController\u0026gt;(PawnKilled-\u0026gt;GetController()); if(PlayerController != nullptr) { EndGame(false); } for(AShooterAIController* Controller : TActorRange\u0026lt;AShooterAIController\u0026gt;(GetWorld())) { if(!Controller-\u0026gt;IsDead()) return; EndGame(true); } } 这里的Controller-\u0026gt;IsDead()实现如下：\n1 2 3 4 5 6 7 bool AShooterAIController::IsDead() const{ AShooterCharacter* ControlledCharacter = Cast\u0026lt;AShooterCharacter\u0026gt;(GetPawn()); if(ControlledCharacter != nullptr) { return ControlledCharacter-\u0026gt;IsDead(); } return true; } EndGame实现如下：\n1 2 3 4 5 6 void AKillEmAllGameMode::EndGame(bool bIsPlayerWinner) { for (AController* Controller : TActorRange\u0026lt;AController\u0026gt;(GetWorld())) { bool bIsWinner = Controller-\u0026gt;IsPlayerController() == bIsPlayerWinner; Controller-\u0026gt;GameHasEnded(Controller-\u0026gt;GetPawn(), bIsWinner); } } 其中，TActorRange\u0026lt;Type\u0026gt; 是一个模板类，用于遍历当前世界中所有类型为 Type 的 Actor；\n失败/胜利提示UI 创建蓝图UI空间，并将UMG添加到SimpleShooter.Build.cs中\n1 2 3 4 5 6 7 8 9 10 11 12 13 public SimpleShooter(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] { \u0026#34;Core\u0026#34;, \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;InputCore\u0026#34;, \u0026#34;GameplayTasks\u0026#34;, \u0026#34;UMG\u0026#34; }); PrivateDependencyModuleNames.AddRange(new string[] { }); } GameHasended实现如下：\n1 2 3 4 5 6 7 8 9 10 // ShooterPlayerController.h private: UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;class UUserWidget\u0026gt; LoseScreenClass; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;class UUserWidget\u0026gt; WinScreenClass; UPROPERTY(EditAnywhere) float RestartDelay = 5; FTimerHandle RestartTimer; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ShooterPlayerController.cpp void AShooterPlayerController::GameHasEnded(class AActor *EndGameFocus, bool bIsWinner){ Super::GameHasEnded(EndGameFocus,bIsWinner); if(bIsWinner){ UUserWidget *WinScreen = CreateWidget(this , WinScreenClass ); if(WinScreen!=nullptr){ LoseScreen-\u0026gt;AddToViewport(); } } else{ UUserWidget *LoseScreen=CreateWidget(this,LoseScreenClass ); if(LoseScreen!=nullptr){ LoseScreen-\u0026gt;AddToViewport(); } } } 准心UI创建与销毁 首先使用蓝图创建一个UI Widget\n随后在PlayerController中进行声明和创建\n1 2 3 4 5 UPROPERTY(EditAnywhere) TSubClassOf\u0026lt;class UUserWidget\u0026gt; HUDClass; UPROPERTY() UUSerWidget* HUD; 这里的HUD需要使用UPROPERTY()是因为需要Unreal系统对其进行销毁。\n在BeginPlay中对其进行创建\n1 2 3 4 5 6 7 void AShooterPlayerController::BeginPlay(){ Super::BeginPlay(); HUD = CreateWidget(this, HUDClass); if (HUD != nullptr){ HUD-\u0026gt;AddToViewport(); } } 随后在GameHasEnded中移除\n1 HUD-\u0026gt;RemoveFromViewport(); 音效 当需要在部件上发出音效时，使用SpawnSoundAttached函数，而某个特定位置发出音效时，使用PlaySoundAtLocation函数。\n生成音效的函数的参数包括USoundBase指针，它是USoundWave和USoundCue的基类。\n1 2 3 4 5 UPROPERTY(EditAnywhere) USoundBase* MuzzleSound; UPROPERTY(EditAnywhere) USoundBase* ImpactSound; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void AGun::PullTrigger() { UGameplayStatics::SpawnEmitterAttached(MuzzleFlash, Mesh, TEXT(\u0026#34;MuzzleFlashSocket\u0026#34;)); UGameplayStatics::SpawnSoundAttached(MuzzleSound, Mesh, TEXT(\u0026#34;MuzzleFlashSocket\u0026#34;)); FHitResult Hit; FVector ShotDirection; bool bSuccess = GunTrace(Hit, ShotDirection); if (bSuccess) { UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactEffect, Hit.Location, ShotDirection.Rotation()); UGameplayStatics::PlaySoundAtLocation(GetWorld(), ImpactSound, Hit.Location); AActor* HitActor = Hit.GetActor(); if (HitActor != nullptr) { FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); AController* OwnerController = GetOwnerController(); HitActor-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); } } } 选择声音的时候，可以选择单个声音，也可以从SoundCue中选择多种音效进行随机处理，比如可以使用下图中的方法进行随机音效选择和随机音量和音高\n对于背景声音，可以使用Ambient Sound Actor，将其添加到场景并且选择合适的背景音乐。\n动画实现 混合空间 通过BlendSpace可以实现动画的插值，比如将x轴作为方向（Angle），y轴作为速度，并且在相应方向放置对应动画，就可以创建一个Blend Space.\n叠加动画 对于局部不同的动作，可以使用叠加动画（Additive），如图所示：\n设计俯仰角的时候，需要使用控制器和角色俯仰角的差值\n动画状态机 当我们需要在角色的不同状态下使用不同的动画类型，可以使用动画状态机，比如从在地面的动作切换到在跳跃时的动作，可以通过状态机进行流畅的切换\n在切换状态的时候，可以选择当动画播放完后就切换，比如下图中选择Translation - Automatic Rule Based on Sequence Player in State，也可以使用bool值进行设置，比如通过是否在地面决定播放起跳或者落地动画。\n状态机种可以内嵌其他的状态机。\n实现编辑器中的数值跟随变化 对于设置了UPROPERTY(EditAnywhere)的样本来说，其在构造函数中设置的初始值会被蓝图中的设置覆盖。可以通过条件编译预处理指令和有关函数，来控制这种覆盖。\n1 2 3 #if WITH_EDITOR virtual void PostEditChangeProperty(struct FPropertyChangedEvent\u0026amp; Event) override; #endif 以上函数覆盖了当标记为UPROPERTY()的变量在编辑器中被修改时的回调函数，预编译指令表明只有在PIE模式中，这个函数才会生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #if WITH_EDITOR void AProjectileBullet::PostEditChangeProperty(FPropertyChangedEvent\u0026amp; Event) { Super::PostEditChangeProperty(Event); FName PropertyName = Event.Property != nullptr ? Event.Property-\u0026gt;GetFName() : NAME_None; if (PropertyName == GET_MEMBER_NAME_CHECKED(AProjectileBullet, InitialSpeed)) { if (ProjectileMovementComponent) { ProjectileMovementComponent-\u0026gt;InitialSpeed = InitialSpeed; ProjectileMovementComponent-\u0026gt;MaxSpeed = InitialSpeed; } } } #endif 该函数的定义也被预编译指令包围，表示程序打包时不会加入该函数。\n该函数的作用是，当发现修改的UPROPERTY类型和InitialSpeed（构造函数中用于给ProjectileMovementComponent-\u0026gt;InitialSpeed 和ProjectileMovementComponent-\u0026gt;MaxSpeed赋值）相同的时候，就将上述两个变量的值使用InitialSpeed覆盖。\n经过实测，该方法在编辑器中确实改变了InitialSpeed的时候，对应的两个值才会发生改变，而非一开始就是同步的状态，因此我认为该方法并非最好解决方案。\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unrealcoursenotes/","summary":"\u003cp\u003e\u003ca href=\"\"\u003eudemy.com/course/unrealcourse/\u003c/a\u003e 以及部分\u003ca href=\"\"\u003ehttps://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/\u003c/a\u003e的课程笔记\u003c/p\u003e\n\u003ch2 id=\"常见技巧\"\u003e常见技巧\u003c/h2\u003e\n\u003ch3 id=\"防止速度过快导致的平台位置偏移\"\u003e防止速度过快导致的平台位置偏移\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eAMovingPlatform\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePlatformVelocity\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDistanceMoved\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eDist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDistanceMoved\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDistance\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 获得速度的单位向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDirection\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetSafeNormal\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDirection\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eMoveDistance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"解决被方块撞击时人物视角异常的问题\"\u003e解决被方块撞击时人物视角异常的问题\u003c/h3\u003e\n\u003cp\u003e这是因为只有角色默认只有在移动时才会检查碰撞\u003c/p\u003e\n\u003cp\u003e解决方法：使用蓝图中的\u003ccode\u003eMoveUpdatedComponent\u003c/code\u003e，在每一帧都移动一个小距离再反向移动\u003c/p\u003e\n\u003cp\u003e可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003ch3 id=\"背对光源时场景过暗的问题\"\u003e背对光源时场景过暗的问题\u003c/h3\u003e\n\u003cp\u003e在场景中加入\u003ccode\u003ePostProcessVolume\u003c/code\u003e，在\u003ccode\u003eLens-Exposure-Metering Mode\u003c/code\u003e中，将选项改为\u003ccode\u003eAuto Exposure Basic\u003c/code\u003e，然后修改\u003ccode\u003eBrush\u003c/code\u003e中的x,y,z，令其覆盖整个场景。\u003c/p\u003e\n\u003ch2 id=\"不同的灯光类型\"\u003e不同的灯光类型\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e名称\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e解释\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePoint Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e从一个点向外发射的光源\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSpot Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e聚光灯，有方向性地发出光线\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eRect Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e方形的有方向性光源\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDirectional Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e太阳光（只有方向，没有位置的光）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSky Light\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e将远处的场景作为光源\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"将scenecomponent添加到角色后角色旋转和组件旋转的差异\"\u003e将SceneComponent添加到角色后，角色旋转和组件旋转的差异\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eUGrabber\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTickComponent\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eELevelTick\u003c/span\u003e \u003cspan class=\"n\"\u003eTickType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFActorComponentTickFunction\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eThisTickFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTickComponent\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTickType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eThisTickFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eRotator\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetOwner\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetActorRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eMyRotation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetComponentRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eRotatorString\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eRotator\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eToCompactString\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003eMyRotationString\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eMyRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eToCompactString\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"c1\"\u003e// LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"c1\"\u003e// 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\t\u003cspan class=\"n\"\u003eUE_LOG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLogTemp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDisplay\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTEXT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Owner Rotation: %s, Component Rotation: %s\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eRotatorString\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eMyRotationString\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。\u003c/strong\u003e\u003c/p\u003e","title":"Unreal Course Notes"},{"content":"这篇文章介绍了几种常见的和游戏开发、计算机图形学密切相关的算法题\n一个点是否在三角形内部 可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; struct Point { double x, y; }; // 向量叉积：计算向量a × 向量b的值 double crossProduct(const Point\u0026amp; a, const Point\u0026amp; b) { return a.x * b.y - a.y * b.x; } // 检查点p1和p2是否在边a-b的同一侧（包含边上的点） bool isSameSide(const Point\u0026amp; p1, const Point\u0026amp; p2, const Point\u0026amp; a, const Point\u0026amp; b) { Point ab = {b.x - a.x, b.y - a.y}; // 边a→b的向量 Point ap1 = {p1.x - a.x, p1.y - a.y}; Point ap2 = {p2.x - a.x, p2.y - a.y}; double cp1 = crossProduct(ab, ap1); // 计算叉积AB × AP1 double cp2 = crossProduct(ab, ap2); // 计算叉积AB × AP2 return (cp1 * cp2) \u0026gt;= 0; // 符号相同或其中一个为0（点在线段上） } // 判断点P是否在三角形ABC内 bool isInsideTriangle(const Point\u0026amp; A, const Point\u0026amp; B, const Point\u0026amp; C, const Point\u0026amp; P) { return isSameSide(P, C, A, B) \u0026amp;\u0026amp; // P和C在AB同侧 isSameSide(P, A, B, C) \u0026amp;\u0026amp; // P和A在BC同侧 isSameSide(P, B, C, A); // P和B在CA同侧 } int main() { Point A = {0, 0}; Point B = {3, 0}; Point C = {1.5, 2.5}; Point P = {1.5, 10}; // 待检测点 if (isInsideTriangle(A, B, C, P)) { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形内部\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形外部\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } 欧拉路径 问题本质 题目要求“是否存在一条路径恰好经过所有有向边一次”，其实就是有向欧拉路径 (Eulerian Path) / 欧拉回路 (Eulerian Circuit) 的判定与构造问题。\n欧拉路径：一条路径，经过每一条边且恰好一次。 欧拉回路：欧拉路径同时是一个环，即起点 = 终点。 判定条件（有向图） 对于一个有向图存在欧拉路径，需要满足以下条件：\n度条件 至多一个点满足：出度 = 入度 + 1 → 可能的起点。 至多一个点满足：入度 = 出度 + 1 → 可能的终点。 其他所有点必须满足：入度 = 出度。 如果所有点都是 入度 = 出度，那说明存在欧拉回路。 连通性条件 把所有边当作无向边忽略方向，所有度 \u0026gt; 0 的节点必须在同一个连通分量中。否则不可能走完所有边。 这两个条件必须同时成立。\n构造方法（Hierholzer 算法） 在判定条件成立后，我们需要输出路径。这里用 Hierholzer 算法：\n原理： 从起点开始走，每次选择一条未走过的边前进，直到走不动为止（得到一条子回路）。 如果图中还有没走过的边，就在当前路径中找一个还有出边未用完的节点，从那里继续走，形成新的子回路。 不断拼接这些子回路，最终形成完整的欧拉路径。 时间复杂度：O(n + m)，只遍历所有边一次。 最终输出 如果条件不满足 → 输出 \u0026quot;no path\u0026quot;。\n如果条件满足 → 输出一条长度为 m+1 的节点序列（因为 m 条边对应 m+1 个节点）。\n两条线段是否相交 数学方法\n把起点—终点记为线段 $AB$，墙记为线段 $CD$。\n设二维叉积\n$$ \\operatorname{cross}(\\vec{u},\\vec{v}) = u_x v_y - u_y v_x. $$\n定义三点 $P,Q,R$ 的有向面积（朝向）：\n$$ \\operatorname{orient}(P,Q,R)=\\operatorname{cross}(Q-P,;R-P). $$\n线段相交（含重合/端点接触）充要条件 两线段 $AB$ 与 $CD$ 相交当且仅当：\n$\\operatorname{orient}(A,B,C)$ 与 $\\operatorname{orient}(A,B,D)$ 异号或为 0，且 $\\operatorname{orient}(C,D,A)$ 与 $\\operatorname{orient}(C,D,B)$ 异号或为 0， 共线（orient=0）时，再检查投影是否在各自的包围盒内有重叠。 用符号表示就是：\n令：\n$$ o_1 = \\operatorname{orient}(A,B,C), \\quad o_2 = \\operatorname{orient}(A,B,D) $$\n$$ o_3 = \\operatorname{orient}(C,D,A), \\quad o_4 = \\operatorname{orient}(C,D,B) $$\n若：\n$$ \\operatorname{sgn}(o_1) \\cdot \\operatorname{sgn}(o_2) \\le 0 $$\n且\n$$ \\operatorname{sgn}(o_3) \\cdot \\operatorname{sgn}(o_4) \\le 0 $$\n并且在任一 $o_i=0$ 的情况下满足包围盒重叠，则两段相交。\n“重合也算挡住”，因此只要判定为相交（包括端点接触与部分/全部重合）就视为被挡住。 C++ 简洁实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct Pt { double x, y; }; static const double EPS = 1e-9; int sgn(double x) { return (x \u0026gt; EPS) - (x \u0026lt; -EPS); } double cross(const Pt\u0026amp; a, const Pt\u0026amp; b, const Pt\u0026amp; c) { // cross((b-a), (c-a)) return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x); } bool onSegment(const Pt\u0026amp; a, const Pt\u0026amp; b, const Pt\u0026amp; p) { // p 与 ab 共线且落在包围盒内 if (sgn(cross(a, b, p)) != 0) return false; return (min(a.x, b.x) - EPS \u0026lt;= p.x \u0026amp;\u0026amp; p.x \u0026lt;= max(a.x, b.x) + EPS \u0026amp;\u0026amp; min(a.y, b.y) - EPS \u0026lt;= p.y \u0026amp;\u0026amp; p.y \u0026lt;= max(a.y, b.y) + EPS); } bool segIntersect(const Pt\u0026amp; a, const Pt\u0026amp; b, const Pt\u0026amp; c, const Pt\u0026amp; d) { // 处理退化：若墙或路径为点 bool ab_point = (sgn(a.x - b.x) == 0 \u0026amp;\u0026amp; sgn(a.y - b.y) == 0); bool cd_point = (sgn(c.x - d.x) == 0 \u0026amp;\u0026amp; sgn(c.y - d.y) == 0); if (ab_point \u0026amp;\u0026amp; cd_point) return (sgn(a.x - c.x) == 0 \u0026amp;\u0026amp; sgn(a.y - c.y) == 0); if (ab_point) return onSegment(c, d, a); if (cd_point) return onSegment(a, b, c); double o1 = cross(a, b, c); double o2 = cross(a, b, d); double o3 = cross(c, d, a); double o4 = cross(c, d, b); int s1 = sgn(o1), s2 = sgn(o2), s3 = sgn(o3), s4 = sgn(o4); if (s1 == 0 \u0026amp;\u0026amp; onSegment(a, b, c)) return true; if (s2 == 0 \u0026amp;\u0026amp; onSegment(a, b, d)) return true; if (s3 == 0 \u0026amp;\u0026amp; onSegment(c, d, a)) return true; if (s4 == 0 \u0026amp;\u0026amp; onSegment(c, d, b)) return true; return (s1 * s2 \u0026lt; 0) \u0026amp;\u0026amp; (s3 * s4 \u0026lt; 0); } // 是否被墙挡住（含重合/接触） bool blocked(double xs, double ys, double xe, double ye, double x1, double y1, double x2, double y2) { Pt A{xs, ys}, B{xe, ye}, C{x1, y1}, D{x2, y2}; return segIntersect(A, B, C, D); } // 示例 int main() { // 起点-终点 double xs = 0, ys = 0, xe = 4, ye = 0; // 墙：横跨 (2,-1) 到 (2,1)，显然与路径相交 double x1 = 2, y1 = -1, x2 = 2, y2 = 1; cout \u0026lt;\u0026lt; (blocked(xs, ys, xe, ye, x1, y1, x2, y2) ? \u0026#34;BLOCKED\u0026#34; : \u0026#34;CLEAR\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 一个不相交的例子 cout \u0026lt;\u0026lt; (blocked(0,0,4,0, 5,-1,6,1) ? \u0026#34;BLOCKED\u0026#34; : \u0026#34;CLEAR\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 重合的例子（共线且重叠） cout \u0026lt;\u0026lt; (blocked(0,0,4,0, 1,0,3,0) ? \u0026#34;BLOCKED\u0026#34; : \u0026#34;CLEAR\u0026#34;) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } 说明\nEPS 处理浮点误差；sgn 给出三态比较结果。 cross(a,b,c) 是 $\\operatorname{orient}(a,b,c)$。 onSegment 在共线前提下检查是否落在包围盒里。 segIntersect 覆盖了普通相交、端点接触、共线重叠，以及退化为点的情况。 blocked 即为“从起点到终点是否被墙挡住”的答案函数。 三角形内部随机采样 问题描述：假设你有一个二维平面上的三角形，由三个顶点A(x1, y1)、B(x2, y2)、C(x3, y3)组成。请设计一种方法，在这个三角形内部随机均匀地采样一个点。\n正确答案： 随机均匀地在一个三角形内采样一个点的方法之一是使用重心坐标法（Barycentric Coordinates）。具体步骤如下：\n生成两个在[0,1]区间内的随机数u和v。 如果u + v \u0026gt; 1，则将其映射到三角形内部：令u = 1 - u，v = 1 - v。 计算第三个参数w = 1 - u - v。 最终采样点P的坐标为：P = uA + vB + w*C。 ","permalink":"https://wstfdxfh.github.io/posts/cheetsheets/cgalgos/","summary":"\u003cp\u003e这篇文章介绍了几种常见的和游戏开发、计算机图形学密切相关的算法题\u003c/p\u003e\n\u003ch3 id=\"一个点是否在三角形内部\"\u003e一个点是否在三角形内部\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003ePoint\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 向量叉积：计算向量a × 向量b的值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"nf\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 检查点p1和p2是否在边a-b的同一侧（包含边上的点）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eab\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 边a→b的向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eap1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eap2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ecp1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eab\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eap1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 计算叉积AB × AP1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ecp2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eab\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eap2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 计算叉积AB × AP2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecp1\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecp2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e             \u003cspan class=\"c1\"\u003e// 符号相同或其中一个为0（点在线段上）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 判断点P是否在三角形ABC内\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003eisInsideTriangle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                      \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// P和C在AB同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e         \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// P和A在BC同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e         \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// P和B在CA同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e2.5\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 待检测点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eisInsideTriangle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;点P在三角形内部\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;点P在三角形外部\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"欧拉路径\"\u003e欧拉路径\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e问题本质\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e题目要求“是否存在一条路径恰好经过所有有向边一次”，其实就是\u003cstrong\u003e有向欧拉路径 (Eulerian Path) / 欧拉回路 (Eulerian Circuit)\u003c/strong\u003e 的判定与构造问题。\u003c/p\u003e","title":"CGAlgos"}]