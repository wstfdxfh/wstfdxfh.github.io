[{"content":"针对Unreal文档的摘录\nUnreal 反射系统 https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4\nUnreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C++类、函数和变量。\nUnreal 中所有对象的基类是 UObject。 TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。 类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。 Unreal 智能指针库是对 C++11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。 接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。 元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。 UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。 Objects UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。 虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。 一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C++代码中可用的普通 C++函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。 UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。 UObject 不支持构造函数参数。所有 C++ UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。 UOBJECT支持以下广泛的功能：\nReflection 反射 Serialization 序列化 Automatic updating of default property changes 默认属性变更的自动更新 Automatic property initialization 自动属性初始化 Automatic editor integration 自动编辑器集成 Type information available at runtime 运行时可用的类型信息 Network replication 网络复制 The Unreal Header Tool 要利用 UObject 派生类型提供的功能，需要对这些类型的头文件运行预处理步骤以收集所需信息。该预处理步骤由 UnrealHeaderTool（简称 UHT）执行。UObject 派生类型需遵循特定的结构规范。\n假设 UObject 派生类名为 UMyObject，创建它的项目名为 MyProject，其基础头文件可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 #pragma once #include \u0026#39;Object.h\u0026#39; // 这一行预期是该文件中最后一个 #include 指令。如果此头文件需要了解其他类，可以在文件任意位置前向声明它们，或在 MyObject.generated.h 上方包含相关文件。 #include \u0026#39;MyObject.generated.h\u0026#39; // UCLASS 宏使 UMyObject 对 Unreal Engine 可见。该宏支持多种 Class Specifiers（类说明符），用于决定为类启用或禁用哪些功能。 UCLASS() // 如果 MyProject 希望将 UMyObject 类暴露给其他模块，则必须指定 MYPROJECT_API 。这对于将被游戏项目包含的模块或插件最为有用。 class MYPROJECT_API UMyObject : public UObject { // GENERATED_BODY 宏不接收任何参数，但会设置类以支持引擎所需的基础设施。所有 UCLASS 和 USTRUCT 都需要它。 GENERATED_BODY() }; 更新对象 “Tick”（帧更新）指的是虚幻引擎中对象的更新机制。所有 Actor 都具备每帧被更新的能力，这为执行必要的计算或操作提供了途径。\n当注册启用时，Actor 和 ActorComponent 会自动调用其 Tick 函数，但 UObjects 并不具备内置的更新功能。若项目需要，可通过继承 FTickableGameObject 类（使用 inherits 类说明符）来添加此功能。随后它们可实现 Tick() 函数，该函数将由引擎每帧调用。\n销毁对象 对象销毁由垃圾回收系统在对象不再被引用时自动处理。这意味着不应有任何 UPROPERTY 指针、引擎容器、 TStrongObjectPtr 或类实例对它们持有强引用。 当垃圾收集器运行时，未被引用的对象会被从内存中移除。此外，可以直接在对象上调用函数 MarkPendingKill() 。此函数会将所有指向该对象的指针设为 NULL ，并将该对象从全局搜索中移除。该对象将在下一次垃圾回收过程中被完全删除。 对于 Actor 而言，即使对其调用了 Destroy() 并将其从关卡中移除，只要仍存在对它的引用，该 Actor 就不会被垃圾回收。 NewObject 1 2 3 4 template\u0026lt; class T \u0026gt; T* NewObject ( UObject* Outer=(UObject*)GetTransientPackage(), UClass* Class=T::StaticClass() ) NewNamedObject NewNamedObject() 在 NewObject() 的基础上进行了扩展，允许为新实例指定名称，同时还能通过参数设置对象标志和模板对象。\n1 2 3 4 5 6 template\u0026lt; class TClass \u0026gt; TClass* NewNamedObject( UObject* Outer, FName Name, EObjectFlags Flags = RF_NoFlags, UObject const* Template=NULL ) ConstructObject 为实现完全灵活性，可使用 ConstructObject() 函数创建 UObjects 的新实例。该函数会调用 StaticConstructObject() 来分配对象、执行 ClassConstructor ，并执行诸如加载配置属性、加载本地化属性及实例化组件等初始化操作。\nObject Flags EObjectFlags 枚举用于快速简洁地描述一个对象。它包含多种标志来描述对象的类型、垃圾回收处理方式、对象生命周期的当前阶段等。此外，还提供了特殊的全选或全不选掩码以及预定义的标志组。\n引用自动更新 **当一个 AActor 或 UActorComponent 被销毁或以其他方式从游戏中移除时，反射系统可见的所有对其引用（如 UProperty 指针和存储在 Unreal Engine 容器类如 TArray 中的指针）会自动置空。**这样做的好处是防止悬空指针持续存在并引发后续问题，但也意味着如果其他代码销毁了它们， AActor 和 UActorComponent 指针可能会变为空值。这一机制的最终优势在于空值检查更加可靠，因为它既能检测标准情况下的空指针，也能检测非空指针指向已删除内存的情况。 **需要注意的是，此特性仅适用于标记为 UActorComponent 或 AActor 的引用，或存储在 Unreal Engine 容器类中的引用。存储在原始指针中的对象引用对 Unreal Engine 而言是未知的，既不会自动置空，也不会阻止垃圾回收。**请注意，这并不意味着所有 UObject* 变量都必须 UProperties 。如果你需要一个非 UProperty 的对象指针，可以考虑使用 TWeakObjectPtr 。这是一种\u0026quot;弱\u0026quot;指针，意味着它不会阻止垃圾回收，但在访问前可以查询其有效性，并且如果指向的对象被销毁，它会被置空。 另一种被引用 UObject UProperty 会被自动置空的情况是在编辑器中对资源使用\u0026rsquo;强制删除\u0026rsquo;操作。因此，所有操作作为资源的 UObject 的代码都必须处理这些指针变为空的情况。 序列化 当 UObject 被序列化时，除非显式标记为\u0026quot;transient\u0026quot;或保持构造后默认值未变，否则所有 UProperty 值都会自动写入或读取。例如，您可以在关卡中放置一个 AEnemy 实例，将其生命值设为 500，保存后无需在 UClass 定义之外编写任何代码即可成功重新加载。 当 UProperty 被添加或移除时，系统会无缝处理已有内容的加载。新增属性会从新的类默认对象(CDO)中复制默认值，被移除的属性则会被静默忽略。 如需自定义行为，可重写 UObject::Serialize 函数。这对于检测数据错误、检查版本号，或在数据格式变更时执行自动转换或更新非常有用。 属性值更新 当一个类的类默认对象（CDO）发生变更时，引擎会在加载该类的所有实例时尝试应用这些变更。对于给定的对象实例，如果更新变量的值与旧 CDO 中的值匹配，则该值会被更新为新 CDO 中的值。如果变量具有其他任何值，则假定该值是故意设置的，这些变更将被保留。（就是说，如果在实例中修改了这些值，即使修改类默认值也不会修改这些内容） 运行时类型信息与类型转换 由于 UObjects 属于虚幻引擎的反射系统，它们始终知晓自身的 UClass 类型，因此可以在运行时进行类型相关决策和类型转换。 在原生代码中，每个 UObject 类都有一个自定义的 Super 类型定义指向其父类，这使得行为重写控制更加便捷。 此外，你可以安全地使用模板化的 Cast 函数将对象从基类转换为更派生的类，或者使用 IsA 查询对象是否属于特定类。 1 2 3 4 5 6 7 8 9 10 11 class ALegendaryWeapon : public AWeapon { void SlayMegaBoss() { TArray\u0026lt;AEnemy\u0026gt; EnemyList = GetEnemyListFromSomewhere(); // The legendary weapon is only effective against the MegaBoss for (AEnemy Enemy : EnemyList) { AMegaBoss* MegaBoss = Cast\u0026lt;AMegaBoss\u0026gt;(Enemy); if (MegaBoss) Incinerate(MegaBoss); } } }; 垃圾回收 虚幻引擎采用一套垃圾回收机制，当 UObjects 不再被引用或已被显式标记为待销毁时，系统会定期清理这些对象。**引擎通过构建引用关系图来判定哪些 UObjects 仍在使用中，哪些已成为孤立对象。**该图的根部是一组被指定为\u0026quot;根集\u0026quot;的 UObjects 。任何 UObject 都可被添加至根集中。当垃圾回收触发时，引擎能够通过从根集出发遍历已知 UObject 引用树，追踪所有被引用的 UObjects 。那些未被引用到的 UObjects （即在树搜索中未找到的对象）将被判定为不再需要，并予以移除。 这里的一个实际含义是，你通常需要维护一个 UPROPERTY 引用以保持任何你想保留的 Object 存活，无论它是一个简单的 Object 指针还是包含 Object 指针类型的 Unreal Engine 容器类，例如 TArray\u0026lt;UObject*\u0026gt; 。Actors 及其 Components 通常是这一规则的例外，因为 Actors 通常被链接回根集的 Object 引用，例如它们所属的 Level，而 Actor 的 Components 则由 Actor 自身引用。可以通过调用 Actors 的 Destroy 函数显式标记它们为销毁状态，这是从进行中的游戏中移除 Actor 的标准方法。Components 可以通过 DestroyComponent 函数显式销毁，但它们通常在其所属的 Actor 从游戏中移除时被销毁。 此外还可调整其他功能来更精确地控制垃圾回收的执行时机与方式，这些设置大多位于项目设置的\u0026quot;Engine - Garbage Collection\u0026ldquo;分类下。 Incremental Garbage Collection 增量垃圾回收 Improved garbage collection system for UObjects.\n虚幻引擎(UE)采用标记-清除垃圾回收机制来管理 UObject 内存。对于软实时应用而言，垃圾回收器历来存在一个主要缺陷**：在执行可达性分析确定哪些对象内存可回收时，可能导致游戏卡顿。**在 UE 中，这一过程称为可达性分析。**UE 始终要求垃圾回收的这一阶段必须在一帧内完成，期间会暂时停止所有 UObject 处理（尤其是游戏逻辑）。需要扫描的可达对象越多，暂停时间就越长，通常很容易因此引发明显的游戏卡顿。**程序员可通过多种方式规避此问题，例如：\n严格控制 UObject 数量 使用 UObject 对象池 在常规游戏过程中禁用垃圾回收 UE 通过增量可达性分析对此进行了改进。用户现在能够将垃圾回收器的可达性分析阶段分散到多个帧中完成，并配置每帧的软性时间限制。引擎通过 TObjectPtr 属性跟踪可达性分析迭代间的 UObject 引用。即，在垃圾回收进行期间，任何对 TObjectPtr 暴露的 UPROPERTY 的赋值都会立即将该对象标记为可达。这也被称为垃圾回收写屏障。\n引擎已全面改用 TObjectPtr 替代原始 C++指针，所有向垃圾回收器暴露 UObject 的场景（包括 UObject 或 FGCObject AddReferencedObjects 函数）均已适配。要在基于虚幻引擎构建的项目中使用增量可达性分析，必须将所有 UPROPERTY 实例转换为使用 TObjectPtr 而非原始 C++指针，否则垃圾回收可能过早释放某些 UObject 的内存。该功能目前作为实验性功能发布，因为可达性分析阶段仍有可能超出规定的时间限制。\nProperties Int类型 整数数据类型的命名惯例是 \u0026ldquo;int\u0026rdquo; 或 \u0026ldquo;uint\u0026rdquo; 后跟以位为单位的长度，比如 int32, uint8。 整型属性现在可以作为位掩码暴露给编辑器。要将整型属性标记为位掩码，只需在元数据部分添加\u0026quot;bitmask\u0026rdquo;，如下所示： 1 2 3 4 5 6 7 /*~ BasicBits appears as a list of generic flags in the editor, instead of an integer field. */ UPROPERTY(EditAnywhere, Meta = (Bitmask)) int32 BasicBits; /*~ You can set MyFunction using a generic list of flags instead of typing in an integer value. */ UFUNCTION(BlueprintCallable) void MyFunction(UPARAM(meta=(Bitmask)) int32 BasicBitsParam) 为了自定义位标志的名称，我们首先需要创建一个带有\u0026quot;bitflags\u0026quot;元标签的 UENUM： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 UENUM(Meta = (Bitflags)) enum class EColorBits { ECB_Red, ECB_Green, ECB_Blue }; /*~ This property lists flags matching the names of values from EColorBits. */ UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = \u0026#34;EColorBits\u0026#34;)) int32 ColorFlags; /*~ MyOtherFunction shows flags named after the values from EColorBits. */ UFUNCTION(BlueprintCallable) void MyOtherFunction(UPARAM(meta=(Bitmask, BitmaskEnum = \u0026#34;EColorBits\u0026#34;)) int32 ColorFlagsParam) Float类型 Unreal 使用标准的 C++浮点类型，包括 float 和 double。\nBool类型 1 2 uint32 bIsHungry : 1; bool bIsThirsty; 字符串类型 UE支持3种字符串类型：\nFString 类型是一个变长的字符串 FName是固定长度的字符串 FText更加复杂，是支持本地化的字符串 UE的字符类型为TCHAR，可以使用TEXT宏来表示字面量\nUPROPERTY属性说明符 在声明属性时，可以添加属性说明符（Property Specifiers）来控制该属性在引擎和编辑器各个方面的行为表现。 详见 https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-uproperties?application_version=5.4\nUPROPERTY元数据说明符 在声明类、接口、结构体、枚举、枚举值、函数或属性时，可以添加元数据说明符以控制它们与引擎及编辑器各部分的交互方式。每种数据结构或成员类型都有其专属的元数据说明符列表。\n元数据仅存在于编辑器中；不要编写访问元数据的游戏逻辑。\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/","summary":"\u003cp\u003e针对Unreal文档的摘录\u003c/p\u003e\n\u003ch2 id=\"unreal-反射系统\"\u003eUnreal 反射系统\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4\"\u003ehttps://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eUnreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C++类、函数和变量。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnreal 中所有对象的基类是 UObject。\u003c/li\u003e\n\u003cli\u003eTSubclassOf 是一个模板类，提供 \u003ccode\u003eUClass\u003c/code\u003e 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。\u003c/li\u003e\n\u003cli\u003e类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 \u003ccode\u003eUSTRUCT()\u003c/code\u003e 宏单独定义。\u003c/li\u003e\n\u003cli\u003eUnreal 智能指针库是对 C++11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。\u003c/li\u003e\n\u003cli\u003e接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。\u003c/li\u003e\n\u003cli\u003e元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。\u003c/li\u003e\n\u003cli\u003eUFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"objects\"\u003e\u003cstrong\u003eObjects\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUCLASS\u003c/code\u003e 宏为 \u003ccode\u003eUObject\u003c/code\u003e 提供了一个指向描述其 Unreal 类型信息的 \u003ccode\u003eUCLASS\u003c/code\u003e 引用。\u003cstrong\u003e每个 \u003ccode\u003eUCLASS\u003c/code\u003e 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 \u003ccode\u003eGetClass()\u003c/code\u003e 函数访问。\u003c/li\u003e\n\u003cli\u003e一个 \u003ccode\u003eUCLASS\u003c/code\u003e 包含一组定义类的属性和函数。这些是标准 C++代码中可用的普通 C++函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUObject\u003c/code\u003e 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUObject\u003c/code\u003e 不支持构造函数参数。所有 C++ UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。\u003cstrong\u003eUObject 在运行时应当仅通过 \u003ccode\u003eNewObject\u003c/code\u003e 创建，或在构造函数中使用 \u003ccode\u003eCreateDefaultSubobject\u003c/code\u003e。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eUOBJECT\u003c/code\u003e支持以下广泛的功能：\u003c/p\u003e","title":"UnrealDocu"},{"content":"坦克大战 基于UE5的坦克射击游戏，来自教程 udemy.com/course/unrealcourse/\n下载 https://github.com/wstfdxfh/Oddtanks\n和原教程中最终成品的主要区别在于：\n炮塔转动或者坦克移动时，发射的炮弹会发生随机偏差，更难瞄准敌人 使用一个射灯照出我方坦克的可能落弹点 其中，炮弹散射的实现方法如下：\n首先，在BasePawn.h中加入相关变量：\n1 2 3 4 5 6 7 8 9 10 // 记录最大偏移角度 UPROPERTY(EditAnywhere, Category=\u0026#34;Combat\u0026#34;) float MaxSpreadAngle=5.f; // 当前实时最大偏转角度（度数），由 Tick 更新 UPROPERTY(VisibleAnywhere, Category=\u0026#34;Combat\u0026#34;) float CurrentMaxSpread = 0.f; FTransform LastTransform; bool IsMoving = false; 随后在BasePawn的Tick函数中，检测有没有发生移动\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void ABasePawn::Tick(float DeltaTime) { Super::Tick(DeltaTime); // 判断当前炮塔或者本体是否在移动或者转动 FTransform TurretMeshTransform = TurretMesh-\u0026gt;GetComponentTransform(); IsMoving = !TurretMeshTransform.GetRotation().Equals(LastTransform.GetRotation(), 0.2*DeltaTime) || !TurretMeshTransform.GetLocation().Equals(LastTransform.GetLocation(), 1*DeltaTime); LastTransform = TurretMeshTransform; if(IsMoving) { CurrentMaxSpread = FMath::FInterpTo(CurrentMaxSpread, MaxSpreadAngle, DeltaTime, 2); } else { CurrentMaxSpread = FMath::FInterpTo(CurrentMaxSpread, 0, DeltaTime, 1); } if(Cast\u0026lt;ATank\u0026gt;(this)) { // UE_LOG(LogTemp, Display, TEXT(\u0026#34;GetRotation: %s\u0026#34;), *TurretMeshTransform.GetRotation().ToString()) // UE_LOG(LogTemp, Display, TEXT(\u0026#34;GetLocation: %s\u0026#34;), *TurretMeshTransform.GetLocation().ToString()) // UE_LOG(LogTemp, Display, TEXT(\u0026#34;IsMoving: %d\u0026#34;), IsMoving) UE_LOG(LogTemp, Display, TEXT(\u0026#34;CurrentMaxSpread: %f\u0026#34;), CurrentMaxSpread) } } 这里Equals函数就是指出两个变量是否小到了一定的误差，第二个参数就是相应的误差，这里不使用==运算符的原因是，因为采用了插值处理炮塔的旋转，所以在鼠标不移动后的很长时间内，炮塔都不会完全停止转动。\n最后是改变Fire函数的细节：\n1 2 3 4 5 FVector Location = ProjectileSpawnPoint-\u0026gt;GetComponentLocation(); FRotator Rotation = ProjectileSpawnPoint-\u0026gt;GetComponentRotation(); FRotator RotationOffset(FMath::RandRange(-CurrentMaxSpread, CurrentMaxSpread), FMath::RandRange(-CurrentMaxSpread, CurrentMaxSpread), 0); auto Projectile= GetWorld()-\u0026gt;SpawnActor\u0026lt;AProjectile\u0026gt;(ProjectileClass, Location, Rotation + RotationOffset); Projectile-\u0026gt;SetOwner(this); ","permalink":"https://wstfdxfh.github.io/posts/gamedev/oddtanks/","summary":"\u003ch2 id=\"坦克大战\"\u003e坦克大战\u003c/h2\u003e\n\u003cp\u003e基于UE5的坦克射击游戏，来自教程 udemy.com/course/unrealcourse/\u003c/p\u003e\n\u003cp\u003e下载 \u003ca href=\"https://github.com/wstfdxfh/Oddtanks\"\u003ehttps://github.com/wstfdxfh/Oddtanks\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e和原教程中最终成品的主要区别在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e炮塔转动或者坦克移动时，发射的炮弹会发生随机偏差，更难瞄准敌人\u003c/li\u003e\n\u003cli\u003e使用一个射灯照出我方坦克的可能落弹点\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg alt=\"image-20250428230817419\" loading=\"lazy\" src=\"/posts/gamedev/oddtanks/image-20250428230817419.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，炮弹散射的实现方法如下：\u003c/p\u003e\n\u003cp\u003e首先，在BasePawn.h中加入相关变量：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 记录最大偏移角度\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eUPROPERTY\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eEditAnywhere\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCategory\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Combat\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxSpreadAngle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mf\"\u003e5.f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 当前实时最大偏转角度（度数），由 Tick 更新 \n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eUPROPERTY\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eVisibleAnywhere\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCategory\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Combat\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.f\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eFTransform\u003c/span\u003e \u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e随后在\u003ccode\u003eBasePawn\u003c/code\u003e的Tick函数中，检测有没有发生移动\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eABasePawn\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 判断当前炮塔或者本体是否在移动或者转动\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"n\"\u003eFTransform\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMesh\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetComponentTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRotation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.2\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eEquals\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eLastTransform\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTurretMeshTransform\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIsMoving\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFMath\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFInterpTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxSpreadAngle\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFMath\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFInterpTo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eATank\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       \u003cspan class=\"c1\"\u003e// UE_LOG(LogTemp, Display, TEXT(\u0026#34;GetRotation: %s\u0026#34;), *TurretMeshTransform.GetRotation().ToString())\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// UE_LOG(LogTemp, Display, TEXT(\u0026#34;GetLocation: %s\u0026#34;), *TurretMeshTransform.GetLocation().ToString())\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// UE_LOG(LogTemp, Display, TEXT(\u0026#34;IsMoving: %d\u0026#34;), IsMoving)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e       \u003cspan class=\"n\"\u003eUE_LOG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLogTemp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDisplay\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTEXT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;CurrentMaxSpread: %f\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentMaxSpread\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这里Equals函数就是指出两个变量是否小到了一定的误差，第二个参数就是相应的误差，这里不使用\u003ccode\u003e==\u003c/code\u003e运算符的原因是，因为采用了插值处理炮塔的旋转，所以在鼠标不移动后的很长时间内，炮塔都不会完全停止转动。\u003c/p\u003e","title":"OddTanks"},{"content":"udemy.com/course/unrealcourse/ 的课程笔记\n常见技巧 防止速度过快导致的平台位置偏移 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AMovingPlatform::Tick(float DeltaTime){ Super::Tick(DeltaTime); FVector CurrentLocation = GetActorLocation(); CurrentLocation = CurrentLocation + (PlatformVelocity*DeltaTime); SetActorLocation(CurrentLocation); float DistanceMoved = FVector::Dist(StartLocation, CurrentLocation); if(DistanceMoved \u0026gt; MoveDistance){ // 获得速度的单位向量 FVector MoveDirection = PlatformVelocty.GetSafeNormal(); StartLocation = StartLocation+ MoveDirection*MoveDistance; SetActorLocation(StartLocation); PlatformVelocty = -PlatformVelocty; } } 解决被方块撞击时人物视角异常的问题 这是因为只有角色默认只有在移动时才会检查碰撞\n解决方法：使用蓝图中的MoveUpdatedComponent，在每一帧都移动一个小距离再反向移动\n可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n背对光源时场景过暗的问题 在场景中加入PostProcessVolume，在Lens-Exposure-Metering Mode中，将选项改为Auto Exposure Basic，然后修改Brush中的x,y,z，令其覆盖整个场景。\n调试方法 UE_LOG 打印的格式如下：\n1 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 如果使用FString格式如下\n1 2 FString Name = GetName(); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name); 绘制调试射线、球 1 #include \u0026#34;Engine/World.h\u0026#34; 引入该头文件获得UWorld\n1 2 3 4 #include \u0026#34;DrawDebugHelpers.h\u0026#34; DrawDebugLine(GetWorld(), Start, End, FColor::Red); DrawDebugSphere(GetWorld(), End, 10, 10, FColor::Blue, false, 5); 绘制调试摄像机 在枪械开火时，从玩家视点绘制调试摄像机图形\n1 2 3 4 5 6 7 8 9 APawn* OwnerPawn = Cast\u0026lt;APawn\u0026gt;(GetOwner()); if(OwnerPawn == nullptr) return; AController* OwnerController = OwnerPawn-\u0026gt;GetController; if(OwnerController == nullptr) return; FVector Location; FRotator Rotation; OwnerController-\u0026gt;GetPlayerViewPoint(Location, Rotation); DrawDebugCamera(GetWorld(), Location, Rotation, 90, 2, FColor::Red, true); 不同的灯光类型 名称 解释 Point Light 从一个点向外发射的光源 Spot Light 聚光灯，有方向性地发出光线 Rect Light 方形的有方向性光源 Directional Light 太阳光（只有方向，没有位置的光） Sky Light 将远处的场景作为光源 将SceneComponent添加到角色后，角色旋转和组件旋转的差异 1 2 3 4 5 6 7 8 9 10 11 void UGrabber::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) { Super::TickComponent(DeltaTime, TickType, ThisTickFunction); auto Rotator = GetOwner()-\u0026gt;GetActorRotation(); auto MyRotation = GetComponentRotation(); auto RotatorString = Rotator.ToCompactString(); auto MyRotationString = MyRotation.ToCompactString(); // LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75) // 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转 UE_LOG(LogTemp, Display, TEXT(\u0026#34;Owner Rotation: %s, Component Rotation: %s\u0026#34;), *RotatorString, *MyRotationString); } 其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。\n如何创建一个摄像头投射并且和特定物品交互(Grabber) 首先新建一个Trace Channel\n前往Project Settings-Engine-Collision在Trace Channels中新建Channel，取名叫做Grabber，默认ignore。重启编辑器\n1 2 3 4 5 6 7 8 9 10 bool UGrabber::GetGrabableInReach(FHitResult\u0026amp; OutHitResult) const { FVector Start = GetComponentLocation(); FVector End = Start + GetForwardVector()*MaxGrabDistance; DrawDebugLine(GetWorld(), Start, End, FColor::Red); FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius); bool HasHit = GetWorld()-\u0026gt;SweepSingleByChannel( OutHitResult, Start, End,FQuat::Identity, ECC_GameTraceChannel2,Sphere); return HasHit; } 这里的ECC_GameTraceChannel2就是Grabber通道，具体需要在项目目录下的/config/DefaultEngine.ini查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void UGrabber::Grab() { UPhysicsHandleComponent *PhysicsHandle = GetPhysicsHandle(); FHitResult HitResult; bool HasHit = GetGrabableInReach(HitResult); if(PhysicsHandle \u0026amp;\u0026amp; HasHit) { AActor *HitActor = HitResult.GetActor(); HitActor-\u0026gt;Tags.Add(\u0026#34;Grabbed\u0026#34;); UE_LOG(LogTemp, Warning, TEXT(\u0026#34;The raycast has hit %s\u0026#34;), *HitActor-\u0026gt;GetActorNameOrLabel()); UPrimitiveComponent * HitComponent = HitResult.GetComponent(); HitComponent-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;GrabComponentAtLocationWithRotation( HitComponent, NAME_None, HitResult.ImpactPoint, GetComponentRotation() ); } } 其中，HitComponent-\u0026gt;WakeAllRigidBodies();的目的是为了防止部分静止时间较长的物体不在模拟物理效果，而手动进行唤醒\n要放开物品的时候代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void UGrabber::Release() { UPhysicsHandleComponent* PhysicsHandle = GetPhysicsHandle(); if(PhysicsHandle \u0026amp;\u0026amp; PhysicsHandle-\u0026gt;GetGrabbedComponent()!=nullptr) { AActor* GrabbedActor = PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;GetOwner(); GrabbedActor-\u0026gt;Tags.Remove(\u0026#34;Grabbed\u0026#34;); PhysicsHandle-\u0026gt;GetGrabbedComponent()-\u0026gt;WakeAllRigidBodies(); PhysicsHandle-\u0026gt;ReleaseComponent(); } } 物体碰撞关系 两个物体之间的碰撞关系依赖于两者的collision的组合：\nIgnore Overlap Block Ignore Ignore Ignore Ignore Overlap Ignore Overlap Overlap Block Ignore Overlap Block 除此以外，还需要在碰撞双方的选项中启用Generate overlap events\n强制转换与组件接触 Unreal中，UPrimitiveComponent是包含了物理性质的组件，而USceneComponent是其父组件，为了可以获取Actor的可能的UPrimitiveComponent，可以使用指针强制类型转换。完整强制转换与组件接触代码如下：\n1 2 3 4 5 6 7 UPrimitiveComponent* Component = Cast\u0026lt;UPrimitiveComponent\u0026gt;(Actor-\u0026gt;GetRootComponent()); if(Component!=nullptr) { Component-\u0026gt;SetSimulatePhysics(false); } Actor-\u0026gt;AttachToComponent(this, FAttachmentTransformRules::KeepWorldTransform); Mover-\u0026gt;SetShouldMove(true); Cast\u0026lt;\u0026gt;() 用于将 UObject 或其子类指针安全转换为子类类型。\n1 2 3 4 5 AActor* Actor = GetOwner(); AMyCharacter* MyChar = Cast\u0026lt;AMyCharacter\u0026gt;(Actor); if (MyChar) { // 转换成功，可安全使用 } 失败时返回 nullptr 仅适用于 UObject 派生类 比 dynamic_cast 更高效 角色常用组件以及相关类简介 1. USceneComponent Transform: 具有变换（位置、旋转、缩放）功能。 Attachment: 可以附加到其他组件上。 视觉内容: 没有视觉内容，主要用于场景中的逻辑组织。 2. UCapsuleComponent 继承自: USceneComponent 作用: 主要用于处理碰撞检测。 3. UStaticMeshComponent 继承自: USceneComponent 作用: 主要用于视觉展示，可以加载静态网格体。 4. Actor 及其子类 包括: Pawn, Character 等。 RootComponent: 类型为 USceneComponent*，是 Actor 的根组件。 修改 RootComponent: 可以通过修改 RootComponent 来改变其类型，例如将其设置为 UCapsuleComponent。 5.USpringArmComponent 作为摄像机的支架（“弹簧臂”），用于设置摄像机与角色或物体之间的距离与角度；自动处理摄像机的碰撞检测和视野遮挡问题。 6.UCameraComponent 提供游戏视角，定义玩家视野范围、视野角度（FOV）及视图旋转等参数。通常配合USpringArmComponent使用，实现第三人称视角。 通常在第三人称游戏中，将USpringArmComponent的bUsePawnControlRotation设为true，同时将UCameraComponent的同名属性设为false，以便更灵活地调整视野。 7. Actor Component (生命值组件) 为了在多个Actor上实现类似的功能，可以建立一个ActorComponent组件，它是SceneComponent的父类，不包含坐标等信息。\n创建一个HealthComponent作为Actor Component的子组件，加上最大生命值、生命值等变量。关键是，当Owner受到伤害时，需要进行相应的操作。\n要将ActorComponent的函数在Actor受到伤害时调用，需要实现以下步骤：\n在头文件中声明回调函数\n1 2 3 UFUNCTION() void DamageTaken(AActor* DamagedActor, float Damage, const UDamageType* Damagetype, AController* Instigator, AActor* DamageCauser); Beginplay函数中添加\n1 GetOwner()-\u0026gt;OnTakeAnyDamage.AddDynamic(this, \u0026amp;UHealthComponent::DamageTaken); 实现DamageTaken\n在造成伤害的Actor中实现HitEvent\n前向声明 仅在 .cpp 中包含实际使用的内容 在 .h 中应尽量少包含 声明指针时无需包含对应头文件 构造对象时需要包含对应头文件 访问成员时需要包含对应头文件 继承时需要包含对应头文件 UE5 C++ 输入绑定与移动实现 Pawn示例（如坦克）： 1. 设置输入（在 Project Settings → Input 中） 添加 Axis Mappings： MoveForward → W/S 或 Up/Down Turn → A/D 或 Left/Right 添加Action Mapping 2. C++ 输入绑定声明 在 ATank 类头文件中添加：\n1 virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override; 3. 输入绑定 1 2 3 4 5 6 7 void ATank::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveForward\u0026#34;), this, \u0026amp;ATank::Move); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Turn\u0026#34;), this, \u0026amp;ATank::Turn); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Fire\u0026#34;),IE_Pressed, this, \u0026amp;ATank::Fire); } 4. 移动旋转函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 void ATank::Move(float Value) { FVector DeltaLocation = FVector::ZeroVector; DeltaLocation.X = Value * Speed * UGameplayStatics::GetWorldDeltaSeconds(this); AddActorLocalOffset(DeltaLocation, true); } void ATank::Turn(float Value) { FRotator DeltaRotation = FRotator::ZeroRotator; DeltaRotation.Yaw = Value * TurnRate * UGameplayStatics::GetWorldDeltaSeconds(this); AddActorLocalRotation(DeltaRotation, true); } 说明 TEXT(\u0026quot;MoveForward\u0026quot;) 对应输入设置中定义的名称 this 为当前对象 \u0026amp;ATank::Move 为响应函数地址 UGameplayStatics::GetWorldDeltaSeconds(this) 获取每帧的时间差，确保帧率无关的平滑移动 Character示例（比如手持枪械的人类）与手柄绑定： 首先在设置中设置移动和视角移动对应的映射\n这里将使用手柄控制和使用鼠标控制视角移动采用不同映射的目的是，使用鼠标移动视角的时候，鼠标的移动距离会和帧数同步变化，而手柄不会。\n接下来实现Charactor中的绑定函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Called to bind functionality to input void AShooterCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveForward\u0026#34;), this, \u0026amp;AShooterCharacter::MoveForward); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUp\u0026#34;), this, \u0026amp;APawn::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;MoveRight\u0026#34;), this, \u0026amp;AShooterCharacter::MoveRight); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRight\u0026#34;), this, \u0026amp;APawn::AddControllerYawInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUpRate\u0026#34;), this, \u0026amp;AShooterCharacter::LookUpRate); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRightRate\u0026#34;), this, \u0026amp;AShooterCharacter::LookRightRate); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Jump\u0026#34;), IE_Pressed, this, \u0026amp;ACharacter::Jump); } 因为在Pawn中有现成的函数，所以LookUp和LookRight直接调用AddControllerPitchInput函数和AddControllerYawInput函数，而对于手柄输入，则需要乘以额外的DeltaTime和Rate，其他实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void AShooterCharacter::MoveForward(float AxisValue) { AddMovementInput(GetActorForwardVector() * AxisValue); } void AShooterCharacter::MoveRight(float AxisValue) { AddMovementInput(GetActorRightVector() * AxisValue); } void AShooterCharacter::LookUpRate(float AxisValue) { AddControllerPitchInput(AxisValue * RotationRate * GetWorld()-\u0026gt;GetDeltaSeconds()); } void AShooterCharacter::LookRightRate(float AxisValue) { AddControllerYawInput(AxisValue * RotationRate * GetWorld()-\u0026gt;GetDeltaSeconds()); } Timer简介 Timer用于定时执行函数\n对于要定时执行任务的类（比如炮塔），首先在头文件中\n1 2 FTimerHandle FireRateTimerHandle; float FireRate = 2.f; 随后在BeginPlay中\n1 GetWorldTimerManager().SetTimer(FireRateTimerHandle, this, \u0026amp;ATower::CheckFireCondition, FireRate, true); 参数名 含义 FireRateTimerHandle FTimerHandle 类型变量，用于标识并控制该定时器（可用于清除等操作） this 当前对象指针，表示调用者为当前类实例（如 ATower） \u0026amp;ATower::CheckFireCondition 定时器触发时要执行的成员函数（此处为 CheckFireCondition 方法） FireRate 时间间隔（float 类型），单位为秒，表示每次触发之间的间隔 true 是否循环执行；true 表示循环触发，false 表示只触发一次 每隔 FireRate 秒循环调用一次 CheckFireCondition 方法。 可以通过 FireRateTimerHandle 来暂停、重启或清除该定时器。 HitEvent和多播代理 实现HitEvent事件绑定步骤如下：\n使用 UStaticMeshComponent* 触发碰撞事件时，需依赖其父类 UPrimitiveComponent 的功能。\nOnComponentHit 是一个 Multicast Delegate，可绑定多个函数，在组件发生碰撞后依次触发。\n添加回调函数（头文件中）\n1 2 3 UFUNCTION() void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit); HitComp: 当前发生碰撞的组件 OtherActor: 被碰撞的 Actor OtherComp: 被碰撞的组件 NormalImpulse: 冲击力 Hit: 碰撞信息结构体 在 BeginPlay 中绑定事件 1 ProjectileMesh-\u0026gt;OnComponentHit.AddDynamic(this, \u0026amp;AProjectile::OnHit); AddDynamic(对象, 回调函数) 实现动态绑定 实现函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 void AProjectile::OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult\u0026amp; Hit) { auto Owner = GetOwner(); if(Owner == nullptr) return; auto Instigator = Owner-\u0026gt;GetInstigatorController(); auto DamageTypeClass = UDamageType::StaticClass(); if(OtherActor \u0026amp;\u0026amp; OtherActor!=this \u0026amp;\u0026amp; OtherActor!=Owner) { UGameplayStatics::ApplyDamage(OtherActor, Damage, Instigator, this, DamageTypeClass); Destroy(); } } 角色死亡实现 组件调用流程\nProjectile 调用 ApplyDamage() 到 HealthComponent HealthComponent.DamageTaken() 当生命值 ≤ 0 时触发 ActorDied() GameMode.ActorDied() 在 Pawn.HandleDestruction() 中执行销毁逻辑 实现步骤\n在 Pawn 类中创建 HandleDestruction() 函数 在 GameMode（或 HealthComponent）中创建 ActorDied() 函数 在 ActorDied() 内调用 HandleDestruction() 在 HealthComponent.DamageTaken() 中判断生命值 ≤ 0，调用 ActorDied() 带参数函数Timer回调绑定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void AToonTanksGameMode::HandleGameStart() { Tank = Cast\u0026lt;ATank\u0026gt;(UGameplayStatics::GetPlayerPawn(this, 0)); ToonTanksPlayerController = Cast\u0026lt;AToonTanksPlayerController\u0026gt;( UGameplayStatics::GetPlayerController(this,0)); if(ToonTanksPlayerController) { ToonTanksPlayerController-\u0026gt;SetPlayerEnabledState(false); FTimerHandle PlayerEnableTimerHandle; FTimerDelegate PlayerenableTimerDelegate = FTimerDelegate::CreateUObject( ToonTanksPlayerController, \u0026amp;AToonTanksPlayerController::SetPlayerEnabledState, true ); GetWorldTimerManager().SetTimer( PlayerEnableTimerHandle, PlayerenableTimerDelegate, StartDelay, false ); } } 其中，FTimerDelegate::CreateUObject用于创建代理，参数分别为 InUserObject：函数所在的对象，这里是ToonTanksPlayerController，函数指针，这里是\u0026amp;AToonTanksPlayerController::SetPlayerEnabledState，函数的参数，这里是true\n游戏倒计时 在GameMode.h中，实现\n1 2 UFUNCTION(BlueprintImplementableEvent) void StartGame(); 随后实现一个WBP：\n在Character类代码中生成蓝图Actor 首先在Character头文件中进行声明：\n1 2 3 4 5 UPROPERTY(EditDefaultOnly) TSubClassOf\u0026lt;AGun\u0026gt; GunClass; UPROPERTY() AGun* Gun; 然后在BeginPlay中：\n1 Gun = GetWorld()-\u0026gt;SpawnActor\u0026lt;AGun\u0026gt;(GunClass); 然后在蓝图中设置Character所需要绑定的Actor蓝图 如果原本角色的Skeletal Mesh上有这个Actor(比如枪械)，则可以使用\n1 GetMesh()-\u0026gt;HideBoneByName(TEXT(\u0026#34;weapon_r\u0026#34;), EPhysOp::PBO_None); 来隐藏原本的模型。\n现在在Skeleton蓝图中添加Socket来将新生成的Actor附加到某个骨骼上，并且命名（比如WeaponSocket）。\n1 2 Gun-\u0026gt;AttachToComponent(GetMesh(), FAttchmentTransformRules::KeepRelativeTransform, TEXT(\u0026#34;WeaponSocket\u0026#34;)); 造成伤害 首先在Gun.h中声明伤害等变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 UPROPERTY(EditAnywhere) USceneComponent* Root; UPROPERTY(EditAnywhere) USkeletalMeshComponent* Mesh; UPROPERTY(EditAnywhere) UParticleSystem* MuzzleFlash; UPROPERTY(EditAnywhere) UParticleSystem* ImpactEffect; UPROPERTY(EditAnywhere) float MaxRange = 1000.f; UPROPERTY(EditAnywhere) float Damage = 10.f; 随后实现PullTrigger函数中的造成伤害部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 FVector Location; FRotator Rotation; OwnerController-\u0026gt;GetPlayerViewPoint(Location, Rotation); FVector End = Location + Rotation.Vector()*MaxRange; FHitResult Hit; // 在进行检测时忽视枪械本身以及所属角色 FCollisionQueryparams Params; Params.AddIgnoredActor(this); Params.AddIgnoredActor(getOwner()); bool bSuccess = GetWorld()-\u0026gt;LineTraceByChannel(Hit, Location, End, ECollisionChannel::ECC_GameTraceChannel1, Params); if(bSuccess){ FVector ShotDirection = -Rotation.Vector(); UGameplayStatics::SpawnEmittertAtLocation(GetWorld(), ImpactEffect, Hit.Location, ShotDirection); if(Hit.GetActor()!=nullptr){ FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); Hit.GetActor()-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); } } 1. FPointDamageEvent 构造函数参数 1 FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); 参数 类型 作用 Damage float 伤害值（如 10.0f）。目标 Actor 的 TakeDamage 方法会接收此值。 Hit FHitResult 射线检测的命中结果，包含： • 命中位置 (Hit.Location) • 命中法线 (Hit.Normal) • 命中的 Actor (Hit.GetActor())。 ShotDirection FVector 伤害来源方向（归一化向量）。用于计算击退、伤害角度修正等逻辑。 （此处取 -Rotation.Vector() 表示子弹从玩家指向命中点） nullptr UClass* （可选）伤害类型（UDamageType 子类）。 如果为 nullptr，则使用默认伤害类型。 2. TakeDamage 方法参数 1 Hit.GetActor()-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); 参数 类型 作用 Damage float 同 FPointDamageEvent 中的伤害值，实际传递给目标的伤害逻辑。 DamageEvent FDamageEvent\u0026amp; 伤害事件数据（此处是 FPointDamageEvent），包含伤害来源、方向等上下文信息。 OwnerController AController* 伤害的责任控制器（如玩家控制器或 AI 控制器）。 • 用于统计击杀/助攻。 • 可被 nullptr。 this AActor* 直接造成伤害的 Actor（如子弹或武器）。 • 用于触发 OnTakeDamage 事件时的来源判断。 • 可被 nullptr。 3. 覆写 TakeDamage 方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 float TakeDamage ( float DamageAmount, struct FDamageEvent const \u0026amp; DamageEvent, class AController * EventInstigator, AActor * DamageCauser ){ float DamageToApply = Super::TakeDamage(DamageAmount, DamageEvent, EventInstigator, DamageCauser); DamageToApply = FMath::Min(Health, DamageToApply); Health -= DamageToApply; // 如果死亡，就令控制器失效，并且使胶囊碰撞体也失效 if(IsDead()){ DetachFromControllerPendingDestroy(); GetCapsulecomponent()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } return DamageToApply; } 创建AI敌人 1. 创建AI Controller C++创建一个继承AIController的子类\n使用蓝图创建一个基于这个C++类的子类\n将角色的AI Controller Class 改为蓝图创建的Controller\n2. 令AI可以进行视线跟随以及寻路 在场景中放置一个角色，其会被默认为AI控制的角色\n使用Nav Mesh并将其覆盖到整个地图（可以将Nav Mesh在地图中可视化），随后使用AIController的MoveTo函数进行跟随实现\n在BeginPlay，中通过\n1 2 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); SetFocus(PlayerPawn); 实现视线跟随。\n在Tick中，\n1 2 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); MoveToActor(PlayerPawn, 200); 实现跟踪\n3. 实现条件跟踪与取消跟踪 假如要在无法直接查看到玩家的情况下进行或者取消跟踪，可以使用LineOfSight方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void AShooterAIController::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (LineOfSightTo(PlayerPawn)) { SetFocus(PlayerPawn); MoveToActor(PlayerPawn, 200); } else { ClearFocus(EAIFocusPriority::Gameplay); StopMovement(); } } 行为树 首先在编辑器中创建行为树和Blackboard，如果名字后缀相同，两者会自动连接，否则需要在行为树蓝图中手动操作；\n随后，在AIController蓝图中，将行为树进行绑定，\n并且在AIControllerC++进行声明\n1 2 UPROPERTY(EditAnywhere) class UBehaviorTree* AIBehavior; 随后在Beginplay中，进行行为树的使用\n1 2 3 if(AIBehavior){ RunBehaviorTree(AIBehavior); } 黑板变量绑定 使用黑板创建一个变量，进行取名，并且在Beginplay中进行变量绑定\n1 2 3 4 5 6 7 if(AIBehavior){ RunBehaviorTree(AIBehavior); // 进行角色变量绑定 APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); GetBlackboardController()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;PlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); GetBlackboardController()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;StartLocation\u0026#34;), GetPawn()-\u0026gt;GetActorLocation()); } Sequence和Selector 进行行为树的设置之后，如果没有出现错误，则sequence节点就会依次执行行为，并重复。\nSelector\n从左到右依次检查子节点。 一旦某个子节点返回 Success，停止后续检查。 用于实现行为优先级控制。 Sequence\n顺序执行所有子节点。 一旦某个子节点 Fails，整个序列 Fails。 用于实现一系列必须连续成功的子行为。 “Can See Player?” Decorator\n条件：黑板中的 PlayerLocation 被设置。 加了 Observer Aborts: Both，用于动态中断行为（详见下文）。 MoveTo: PlayerLocation / LastKnownPlayerLocation\n让 AI 移动到指定黑板位置。 特性 Selector Sequence 执行逻辑 直到某个子节点成功为止 所有子节点需按顺序全部成功 中途停止 遇到成功立即返回成功 遇到失败立即返回失败 用途 行为选择（如：追 or 查） 行为流程（如：锁定 → 移动） Observer Aborts 设置说明：\n设置类型 含义 None 条件变化不会中断任何行为。 Self 条件变化时会中断当前节点及其子树行为。 Lower Priority 条件变化时会中断右边的兄弟节点及其子树（优先级更低者）。 Both 条件变化时中断当前节点和所有右边兄弟节点，实现动态行为切换。 示例：“Can See Player?” 设置为 Abort: Both，使得看到玩家时中断 Investigate 行为，反之亦然。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void AShooterAIController::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (LineOfSightTo(PlayerPawn)) { GetBlackboardComponent()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;PlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); GetBlackboardComponent()-\u0026gt;SetValueAsVector(TEXT(\u0026#34;LastKnownPlayerLocation\u0026#34;), PlayerPawn-\u0026gt;GetActorLocation()); } else { GetBlackboardComponent()-\u0026gt;ClearValue(TEXT(\u0026#34;PlayerLocation\u0026#34;)); } } 创建自定义C++行为树任务 如果需要创建一个自定义任务，最常见的父类包含BTTaskNode和BTTask_BlackBoardBase\n其中，BTTask_BlackBoardBase可以选择一个Blackboard key作为参数，可以在蓝图中进行指定。\n创建这个的时候，需要在SimpleShooter.Build.cs中添加\u0026quot;GamePlayTasks\u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public SimpleShooter(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] { \u0026#34;Core\u0026#34;, \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;InputCore\u0026#34;, \u0026#34;GameplayTasks\u0026#34; }); PrivateDependencyModuleNames.AddRange(new string[] { }); } 使用BTTask_BlackBoardBase作为父类进行创建之后，在构造函数中取一个名称作为蓝图现实的名字\n1 2 3 4 UBTTask_ClearBlackboardValue::UBTTask_ClearBlackboardValue() { NodeName = \u0026#34;Clear Blackboard Value\u0026#34;; } 随后执行任务，假设这里的目的是清除一个变量，那么只需要覆写ExecuteTask函数\n1 2 3 4 5 6 7 EBTNodeResult::Type UBTTask_ClearBlackboardValue::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint32* NodeMemory) { Super::ExecuteTask(OwnerComp, NodeMemory); OwnerComp.GetBlackboardComponent()-\u0026gt;ClearValue(GetSelectedBlackboardKey()); return EBTNodeResult::Succeeded; } 最后行为树设置如下：\n实现射击行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 UBTTask_Shoot::UBTTask_Shoot() { NodeName = \u0026#34;Shoot\u0026#34;; } EBTNodeResult::Type UBTTask_Shoot::ExecuteTask(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory) { Super::ExecuteTask(OwnerComp, NodeMemory); if (OwnerComp.GetAIOwner() == nullptr){ return EBTNodeResult::Failed; } AShooterCharacter* Character = Cast\u0026lt;AShooterCharacter\u0026gt;(OwnerComp.GetAIOwner()-\u0026gt;GetPawn()); if (Character == nullptr){ return EBTNodeResult::Failed; } Character-\u0026gt;Shoot(); return EBTNodeResult::Succeeded; } BTService 行为树服务 在AI跟踪玩家的时候，我们希望时刻知道玩家的位置并且让AI移动到该位置，之前该功能在Tick中实现，但实际上可以使用行为树的Service实现。使用Service实现的原因包括：\n简化Tick函数中的代码，并且只在某个节点执行对应代码，减少了计算量 我们有时只希望在行为树的某个状态下实行某种更新 有许多默认服务，比如SetDefaultFocus可以让AI朝向某处（比如玩家位置）\n要实现自定义服务，使用C++继承BTService或者BTService_BlackboardBase，它们的区别和之前的Task相同。\n1 2 3 4 5 6 7 8 9 10 11 12 UBTService_PlayerLocation::UBTService_PlayerLocation() { NodeName = \u0026#34;Update Player Location\u0026#34;; } void UBTService_PlayerLocation::TickNode(UBehaviorTreeComponent \u0026amp;OwnerComp, uint8 *NodeMemory, float DeltaSeconds) { Super::TickNode(OwnerComp, NodeMemory, DeltaSeconds); APawn *PlayerPawn = UGameplayStatics::GetPlayerPawn(GetWorld(), 0); if (PlayerPawn == nullptr) { return; } OwnerComp.GetBlackboardComponent()-\u0026gt;SetValueAsVector(GetSelectedBlackboardKey(), PlayerPawn-\u0026gt;GetActorLocation()); } 最后的行为树如下所示：\n游戏结束处理 游戏结束时的流程如下：\n当一个Character受到伤害而且HP为0时，它会调用一个自定义GameMode的行为，并令其判断如何结束游戏；\n这个GameMode核实游戏结果之后，调用对应的Controller的GameHasended方法。这里的GameMode和Controller都需要重新设置C++子类和对应蓝图，以提升灵活性，具体如下图所示：\nShooterCharacter.cpp的IsDead部分改写如下：\n1 2 3 4 5 6 7 8 if (IsDead()) { ASimpleShooterGameModeBase* GameMode = GetWorld() -\u0026gt; GetAuthGameMode\u0026lt;ASimpleShooterGameModeBase\u0026gt;(); if (GameMode != nullptr) { GameMode-\u0026gt;PawnKilled(this); } DetachFromControllerPendingDestroy(); GetCapsuleComponent()-\u0026gt;SetCollisionEnabled(ECollisionEnabled::NoCollision); } PawnKilled函数实现如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 void AKillEmAllGameMode::PawnKilled(APawn* PawnKilled) { Super::PawnKilled(PawnKilled); APlayerController* PlayerController = Cast\u0026lt;APlayerController\u0026gt;(PawnKilled-\u0026gt;GetController()); if(PlayerController != nullptr) { EndGame(false); } for(AShooterAIController* Controller : TActorRange\u0026lt;AShooterAIController\u0026gt;(GetWorld())) { if(!Controller-\u0026gt;IsDead()) return; EndGame(true); } } 这里的Controller-\u0026gt;IsDead()实现如下：\n1 2 3 4 5 6 7 bool AShooterAIController::IsDead() const{ AShooterCharacter* ControlledCharacter = Cast\u0026lt;AShooterCharacter\u0026gt;(GetPawn()); if(ControlledCharacter != nullptr) { return ControlledCharacter-\u0026gt;IsDead(); } return true; } EndGame实现如下：\n1 2 3 4 5 6 void AKillEmAllGameMode::EndGame(bool bIsPlayerWinner) { for (AController* Controller : TActorRange\u0026lt;AController\u0026gt;(GetWorld())) { bool bIsWinner = Controller-\u0026gt;IsPlayerController() == bIsPlayerWinner; Controller-\u0026gt;GameHasEnded(Controller-\u0026gt;GetPawn(), bIsWinner); } } 其中，TActorRange\u0026lt;Type\u0026gt; 是一个模板类，用于遍历当前世界中所有类型为 Type 的 Actor；\n失败/胜利提示UI 创建蓝图UI空间，并将UMG添加到SimpleShooter.Build.cs中\n1 2 3 4 5 6 7 8 9 10 11 12 13 public SimpleShooter(ReadOnlyTargetRules Target) : base(Target) { PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] { \u0026#34;Core\u0026#34;, \u0026#34;CoreUObject\u0026#34;, \u0026#34;Engine\u0026#34;, \u0026#34;InputCore\u0026#34;, \u0026#34;GameplayTasks\u0026#34;, \u0026#34;UMG\u0026#34; }); PrivateDependencyModuleNames.AddRange(new string[] { }); } GameHasended实现如下：\n1 2 3 4 5 6 7 8 9 10 // ShooterPlayerController.h private: UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;class UUserWidget\u0026gt; LoseScreenClass; UPROPERTY(EditAnywhere) TSubclassOf\u0026lt;class UUserWidget\u0026gt; WinScreenClass; UPROPERTY(EditAnywhere) float RestartDelay = 5; FTimerHandle RestartTimer; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ShooterPlayerController.cpp void AShooterPlayerController::GameHasEnded(class AActor *EndGameFocus, bool bIsWinner){ Super::GameHasEnded(EndGameFocus,bIsWinner); if(bIsWinner){ UUserWidget *WinScreen = CreateWidget(this , WinScreenClass ); if(WinScreen!=nullptr){ LoseScreen-\u0026gt;AddToViewport(); } } else{ UUserWidget *LoseScreen=CreateWidget(this,LoseScreenClass ); if(LoseScreen!=nullptr){ LoseScreen-\u0026gt;AddToViewport(); } } } 准心UI创建与销毁 首先使用蓝图创建一个UI Widget\n随后在PlayerController中进行声明和创建\n1 2 3 4 5 UPROPERTY(EditAnywhere) TSubClassOf\u0026lt;class UUserWidget\u0026gt; HUDClass; UPROPERTY() UUSerWidget* HUD; 这里的HUD需要使用UPROPERTY()是因为需要Unreal系统对其进行销毁。\n在BeginPlay中对其进行创建\n1 2 3 4 5 6 7 void AShooterPlayerController::BeginPlay(){ Super::BeginPlay(); HUD = CreateWidget(this, HUDClass); if (HUD != nullptr){ HUD-\u0026gt;AddToViewport(); } } 随后在GameHasEnded中移除\n1 HUD-\u0026gt;RemoveFromViewport(); 音效 当需要在部件上发出音效时，使用SpawnSoundAttached函数，而某个特定位置发出音效时，使用PlaySoundAtLocation函数。\n生成音效的函数的参数包括USoundBase指针，它是USoundWave和USoundCue的基类。\n1 2 3 4 5 UPROPERTY(EditAnywhere) USoundBase* MuzzleSound; UPROPERTY(EditAnywhere) USoundBase* ImpactSound; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void AGun::PullTrigger() { UGameplayStatics::SpawnEmitterAttached(MuzzleFlash, Mesh, TEXT(\u0026#34;MuzzleFlashSocket\u0026#34;)); UGameplayStatics::SpawnSoundAttached(MuzzleSound, Mesh, TEXT(\u0026#34;MuzzleFlashSocket\u0026#34;)); FHitResult Hit; FVector ShotDirection; bool bSuccess = GunTrace(Hit, ShotDirection); if (bSuccess) { UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), ImpactEffect, Hit.Location, ShotDirection.Rotation()); UGameplayStatics::PlaySoundAtLocation(GetWorld(), ImpactSound, Hit.Location); AActor* HitActor = Hit.GetActor(); if (HitActor != nullptr) { FPointDamageEvent DamageEvent(Damage, Hit, ShotDirection, nullptr); AController* OwnerController = GetOwnerController(); HitActor-\u0026gt;TakeDamage(Damage, DamageEvent, OwnerController, this); } } } 选择声音的时候，可以选择单个声音，也可以从SoundCue中选择多种音效进行随机处理，比如可以使用下图中的方法进行随机音效选择和随机音量和音高\n对于背景声音，可以使用Ambient Sound Actor，将其添加到场景并且选择合适的背景音乐。\n动画实现 混合空间 通过BlendSpace可以实现动画的插值，比如将x轴作为方向（Angle），y轴作为速度，并且在相应方向放置对应动画，就可以创建一个Blend Space.\n叠加动画 对于局部不同的动作，可以使用叠加动画（Additive），如图所示：\n设计俯仰角的时候，需要使用控制器和角色俯仰角的差值\n动画状态机 当我们需要在角色的不同状态下使用不同的动画类型，可以使用动画状态机，比如从在地面的动作切换到在跳跃时的动作，可以通过状态机进行流畅的切换\n在切换状态的时候，可以选择当动画播放完后就切换，比如下图中选择Translation - Automatic Rule Based on Sequence Player in State，也可以使用bool值进行设置，比如通过是否在地面决定播放起跳或者落地动画。\n状态机种可以内嵌其他的状态机。\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/unreal-notes/","summary":"\u003cp\u003e\u003ca href=\"\"\u003eudemy.com/course/unrealcourse/\u003c/a\u003e 的课程笔记\u003c/p\u003e\n\u003ch2 id=\"常见技巧\"\u003e常见技巧\u003c/h2\u003e\n\u003ch3 id=\"防止速度过快导致的平台位置偏移\"\u003e防止速度过快导致的平台位置偏移\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eAMovingPlatform\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"n\"\u003eSuper\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eTick\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePlatformVelocity\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eDeltaTime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eSetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003eDistanceMoved\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eDist\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCurrentLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDistanceMoved\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDistance\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 获得速度的单位向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e        \u003cspan class=\"n\"\u003eFVector\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDirection\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetSafeNormal\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMoveDirection\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eMoveDistance\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSetActorLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eStartLocation\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003ePlatformVelocty\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"解决被方块撞击时人物视角异常的问题\"\u003e解决被方块撞击时人物视角异常的问题\u003c/h3\u003e\n\u003cp\u003e这是因为只有角色默认只有在移动时才会检查碰撞\u003c/p\u003e\n\u003cp\u003e解决方法：使用蓝图中的\u003ccode\u003eMoveUpdatedComponent\u003c/code\u003e，在每一帧都移动一个小距离再反向移动\u003c/p\u003e\n\u003cp\u003e可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003ch3 id=\"背对光源时场景过暗的问题\"\u003e背对光源时场景过暗的问题\u003c/h3\u003e\n\u003cp\u003e在场景中加入\u003ccode\u003ePostProcessVolume\u003c/code\u003e，在\u003ccode\u003eLens-Exposure-Metering Mode\u003c/code\u003e中，将选项改为\u003ccode\u003eAuto Exposure Basic\u003c/code\u003e，然后修改\u003ccode\u003eBrush\u003c/code\u003e中的x,y,z，令其覆盖整个场景。\u003c/p\u003e\n\u003ch2 id=\"调试方法\"\u003e调试方法\u003c/h2\u003e\n\u003ch3 id=\"ue_log\"\u003eUE_LOG\u003c/h3\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如果使用\u003ccode\u003eFString\u003c/code\u003e格式如下\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eFString Name = GetName();\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;%s\u0026#34;), *Name);\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"绘制调试射线球\"\u003e绘制调试射线、球\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e#include \u0026#34;Engine/World.h\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e引入该头文件获得UWorld\u003c/p\u003e","title":"Unreal Notes"},{"content":"UE4: 将蓝图转换为C++ 教程https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c的笔记\n创建C++基类 注意点：\n可以使用蓝图继承C++，反之不行 C++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现 如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注 1 2 3 4 5 UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent), Blueprintable) class BLUEPRINTSTOCPP_API UGrabber : public USceneComponent { // ... }; 需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成 进行生成后，点击VS的“开始执行（不调试）”，即可重启UE 如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目 生命周期方法 对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\n打印的格式如下：\n1 UE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;)); 在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\n1 PrimaryComponentTick.bCanEverTick = false; 可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\nActor 与 Components 比较 Actors Components Can be placed in levels √ ✘ Can have components √ ✘ Modularity 低 高 Inheritance √ √ Default variable values √ √ Maintainability 低 高 Composable _ √ 我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\nUPROPERTY Defaults Instance Defaults \u0026amp; Instance Blueprint RO VisibleDefaultsOnly VisibleInstanceOnly VisibleAnywhere BlueprintReadOnly RW EditDefaultsOnly EditInstanceOnly EditAnywhere BlueprintReadWrite 如果我们想要对应的C++变量可以在其继承的蓝图中被读取（但是运行时不能修改），同时可以在蓝图中修改默认值，实例化后也可以进行修改，可以将UPROPERTY设置为\n1 2 UPROPERTY(EditAnywhere, BlueprintReadWrite) float MaxGrabDistance = 100.f; 可以被蓝图调用的UFUNCTION 蓝图和C++数据类型的对应关系：\nBlueprint C++ Float float \u0026ndash; double Integer int32 \u0026ndash; uint32 Integer64 int64 \u0026ndash; uint64 Bool bool Blueprint C++ String FString Name FName Vector FVector Rotator FRotator Transform FTransform Object UObject* Actor AActor* ActorComponent UActorComponent* 要实现一个可以被蓝图调用的C++函数，首先声明：\n1 2 UFUNCTION(BlueprintCallable, BlueprintPure) FVector GetMaxGrabLocation() const; 其中BlueprintCallable令继承该类的蓝图可以调用这个函数，BlueprintPure表示这是一个纯函数\n接下来进行相应的实现：\n1 2 3 4 5 6 7 #include \u0026#34;Grabber.h\u0026#34; #include \u0026#34;Kismet/KismetMathLibrary.h\u0026#34; // ... FVector UGrabber::GetMaxGrabLocation() const { return GetComponentLocation() + UKismetMathLibrary::GetForwardVector(GetComponentRotation()) * MaxGrabDistance; } 从蓝图函数找到并使用C++类方法 常用C++类：\nClass #include UWorld Engine/World.h AActor GameFramework/Actor.h UActorComponent Components/ActorComponent.h UGameplayStatics Kismet/GameplayStatics.h UKismetSystemLibrary Kismet/KismetSystemLibrary.h FMath Math/UnrealMathUtility.h 有许多蓝图方法在其对应的C++实现中名字有差别，所以要找到对应的方法，可以按照以下步骤：\nVS中，使用ctrl+ , 找到函数的Target对应的类，这个类所在的路径的最后一个子文件夹一般就是要导入头文件的时候输入的路径 将头文件输入到当前实现类的头文件时，注意不能放在#include \u0026quot;Grabber.generated.h\u0026quot;之后 对于对应的方法，可以查看许多相似的名字，其中可能有更加适合的方法，比如一个模板函数方法 使用BlueprintImplementableEvent在蓝图中实现C++ 通过在C++中声明函数的时候如以下方法注明 BlueprintImplementableEvent：\n1 2 UFUNCTION(BlueprintCallable, BlueprintImplementableEvent) void NotifyQuestActor(AActor* Actor); 在继承的蓝图中会出现相应的函数/事件，注意：这里不需要写virtual，预编译指令会进行相应的处理。\n因为这里没有返回值，在蓝图中会对应一个事件，而已经有的同名函数会报错，这里可以删除对应的函数，将相关的实现复制到事件当中。\n注意：这里的蓝图中的Access Specifier必须和C++中的对应声明的访问权限一样\n使用BlueprintImplementableEvent在蓝图中实现C++ 比较：\nBlueprintImplementableEvent No C++ implementation possible. Typically wants to be overridden. BlueprintNativeEvent Has default C++ implementation. Blueprint can call to super. Doesn’t have to be implemented in Blueprint. 实现的时候，首先如下定义头文件：\n如果对应的函数返回3个参数，一个为bool，另外两个为 Object Reference，可以使用以下方法声明C++：\n1 2 UFUNCTION(BlueprintCallable, BlueprintNativeEvent) bool TraceForPhysicsBodies(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent); 实现时需要在名字后边添加_Implementation，如下：\n1 2 3 4 bool UGrabber::TraceForPhysicsBodies_Implementation(AActor*\u0026amp; HitActor, UPrimitiveComponent*\u0026amp; HitComponent) { return false; } 接着在C++蓝图中点击Override重写相关的蓝图实现即可\n注意：如果在蓝图中相关事件是private的，在C++中声明的时候应该将其放在protected中\n将蓝图Structs转成C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 USTRUCT(BlueprintType) struct BLUEPRINTSTOCPP_API FQuestInfo { GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadwrite) FString Name; UPROPERTY(EditAnywhere, BlueprintReadwrite) FName QuestId; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 Progress; UPROPERTY(EditAnywhere, BlueprintReadwrite) int32 ProgressTotal; }; 注意：结构体开头必须为F，不需要继承任何类，预编译指令 USTRUCT(BlueprintType) 表示这是一个可以在蓝图中使用的类型\n将Component转换为C++ 首先在头文件中输入\n1 2 3 4 5 6 7 8 #include \u0026#34;Particles/ParticleSystemComponent.h\u0026#34; protected: UPROPERTY(VisibleAnywhere, BlueprintReadOnly) USceneComponent* Root; UPROPERTY(VisibleAnywhere, BlueprintReadOnly) UParticleSystemComponent* ParticleSystem; UPROPERTY(VisibleAnywhere, BlueprintReadOnly)是为了在构造函数的时候让指针不知向其他位置；\n随后在cpp文件中进行实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 AQuestMarker::AQuestMarker() { PrimaryActorTick.bCanEverTick = false; // Can only be called in constructor Root = CreateDefaultSubobject\u0026lt;USceneComponent\u0026gt;(TEXT(\u0026#34;SceneRoot\u0026#34;)); ParticleSystem = CreateDefaultSubobject\u0026lt;UParticleSystemComponent\u0026gt;(TEXT(\u0026#34;ParticleSystem\u0026#34;)); SetRootComponent(Root); // Can only be called in constructor ParticleSystem-\u0026gt;SetupAttachment(Root); } 注意到其中一些函数只能在构造函数中才能使用；\n创建完之后，将希望使用这个UParticleSystemComponent的蓝图Actor的父类设置为写出来的类，将对应的属性粘贴到ParticleSystem上面，修改相关的引用，最后删除原ParticleSystem\nC++实现Delegate 在 Unreal Engine 中，Delegate（委托） 和 Event（事件） 都是用于实现对象间通信的机制，但它们在设计目的、使用方式和灵活性上有显著区别。以下是详细对比：\n1. 核心概念 特性 Delegate（委托） Event（事件） 本质 一种类型安全的函数指针容器，支持动态绑定多个函数。 基于委托的封装，通常与特定游戏逻辑或引擎系统（如 Actor 生命周期）关联。 设计目的 通用的解耦通信机制，任何类均可使用。 通常用于引擎内部或特定场景（如碰撞、动画通知），提供更严格的访问控制。 绑定权限 允许外部对象绑定/解绑。 通常是单向的：只有事件拥有者可以触发，外部对象只能绑定。 2. 关键区别 (1) 绑定与触发权限 Delegate\n任何对象都可以绑定（Bind）、解绑（Unbind）或触发（Execute）委托。 例如：FOnActorClicked 委托允许任意类绑定点击回调。 Event\n只有定义事件的类可以触发（Broadcast），外部对象只能绑定。 例如：AActor::OnActorBeginOverlap 事件只能由引擎在碰撞时触发，外部代码无法直接调用。 (2) 多播能力 Delegate\n分为单播（Unicast，一对一）和多播（Multicast，一对多）。 需要显式选择类型（如 DECLARE_DELEGATE vs DECLARE_MULTICAST_DELEGATE）。 Event\n本质是多播委托的封装（隐式支持一对多）。 使用 DECLARE_EVENT 宏定义时，默认允许多个绑定。 (3) 访问控制 Delegate\n完全公开，绑定和触发无限制。 风险：可能被外部代码误触发。 Event\n通过封装实现更安全的访问控制： 1 2 DECLARE_EVENT(MyClass, MyEvent) // 只有 MyClass 能触发 MyEvent.AddLambda([](){...}); // 外部仅能绑定 (4) 常见用途 Delegate\nUI 按钮回调、自定义游戏逻辑解耦。 动态绑定运行时逻辑（如技能效果）。 Event\n引擎内置行为（如 Actor 生命周期、碰撞、动画通知）。 需要严格控制的场景（如关卡加载完成事件）。 3. 代码示例 (1) Delegate 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 声明一个多播委托 DECLARE_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float); class AMyActor : public AActor { public: FOnHealthChanged OnHealthChanged; void TakeDamage(float Damage) { Health -= Damage; OnHealthChanged.Broadcast(Health); // 任意触发 } }; // 外部绑定 OtherActor-\u0026gt;OnHealthChanged.AddLambda([](float Health){ ... }); (2) Event 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 声明一个事件（只有 MyClass 能触发） DECLARE_EVENT(MyClass, FOnSecretEvent) class MyClass { public: FOnSecretEvent OnSecretEvent; void DoSecretThing() { OnSecretEvent.Broadcast(); // 仅限 MyClass 内部触发 } }; // 外部只能绑定 MyInstance-\u0026gt;OnSecretEvent.AddLambda([](){ ... }); 总结 维度 Delegate Event 触发权限 公开 仅限定义者 多播支持 需显式声明 默认支持 典型用途 自定义逻辑解耦 引擎内置通知 安全性 较低（需自行管理） 较高（封装触发权限） 理解两者的差异后，可以根据场景灵活选择：需要灵活性用委托，需要安全性用事件。\n实现使用C++替换Delegate 在头文件中首先声明宏\n1 DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FCompletedQuestSignature, int32, Index); 随后进行声明\n1 2 UPROPERTY(BlueprintAssignable, BlueprintCallable) FCompletedQuestSignature CompletedQuest; 如何和将要被替换的蓝图事件分配器声明一致，这时只需要在蓝图中将call的部分进行替换即可，否则需要搜索原本的Bind Event并进行逐个替换。\n在C++中进行广播和注册 要使用广播，首先在先前的Delegate声明完成之后，在需要广播的位置调用\n1 CompletedQuest.Broadcast(QuestIndex); 要进行注册，首先要实现绑定事件，在C++中声明并且实现一个函数，其签名和声明的Delegate一致\n1 2 3 4 // QuestMarker.h private: UFUNCTION() void QuestUpdate(int32 Index); 注意这里绑定的事件实际是一个使用UFUNCTION预编译的函数\n1 2 3 4 5 // QuestMarker.cpp void AQuestMarker::QuestUpdate(int32 Index) { RefreshVisibility(); } 随后在希望的位置进行绑定\n1 2 3 4 5 void AQuestMarker::BeginPlay() { GetQuestManager()-\u0026gt;CompletedQuest.AddDynamic(this, \u0026amp;AQuestMarker::QuestUpdate); RefreshVisibility(); } C++中绑定用户输入 首先创建对应类，将蓝图父类重新设置\n随后新建函数表示轴输入和Action输入\n1 2 3 private: void Forward(float AxisValue); void Jump(); 随后进行实现和绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;FirstPersonCharacter.h\u0026#34; #include \u0026#34;Components/InputComponent.h\u0026#34; #include \u0026#34;GameFramework/CharacterMovementComponent.h\u0026#34; void AFirstPersonCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent) { Super::SetupPlayerInputComponent(PlayerInputComponent); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Forward\u0026#34;), this, \u0026amp;AFirstPersonCharacter::Forward); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;Right\u0026#34;), this, \u0026amp;AFirstPersonCharacter::Right); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookUp\u0026#34;), this, \u0026amp;APawn::AddControllerPitchInput); PlayerInputComponent-\u0026gt;BindAxis(TEXT(\u0026#34;LookRight\u0026#34;), this, \u0026amp;APawn::AddControllerYawInput); PlayerInputComponent-\u0026gt;BindAction(TEXT(\u0026#34;Jump\u0026#34;), IE_Pressed, this, \u0026amp;ACharacter::Jump); } void AFirstPersonCharacter::Forward(float AxisValue) { GetCharacterMovement()-\u0026gt;AddInputVector(GetActorForwardVector()* AxisValue); } void AFirstPersonCharacter::Right(float AxisValue) { GetCharacterMovement()-\u0026gt;AddInputVector(GetActorRightVector() * AxisValue); } 其中，BindAxis(TEXT(\u0026quot;Forward\u0026quot;), this, \u0026amp;AFirstPersonCharacter::Forward);中，第一个参数的名称可以在Project Setting中找到\nBindAction(TEXT(\u0026quot;Jump\u0026quot;), IE_Pressed, this, \u0026amp;AFirstPersonCharacter::Jump);中，第二个参数是一个枚举类型\n","permalink":"https://wstfdxfh.github.io/posts/unrealengine/converting-blueprint-to-c++/","summary":"\u003ch1 id=\"ue4-将蓝图转换为c\"\u003eUE4: 将蓝图转换为C++\u003c/h1\u003e\n\u003cp\u003e教程\u003ca href=\"https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\"\u003ehttps://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c\u003c/a\u003e的笔记\u003c/p\u003e\n\u003ch2 id=\"创建c基类\"\u003e创建C++基类\u003c/h2\u003e\n\u003cp\u003e注意点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以使用蓝图继承C++，反之不行\u003c/li\u003e\n\u003cli\u003eC++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现\u003c/li\u003e\n\u003cli\u003e如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C++\" data-lang=\"C++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eUCLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eClassGroup\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCustom\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003emeta\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBlueprintSpawnableComponent\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eBlueprintable\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eBLUEPRINTSTOCPP_API\u003c/span\u003e \u003cspan class=\"nl\"\u003eUGrabber\u003c/span\u003e \u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eUSceneComponent\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// ...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e需要对Visual Studio中的配置管理器设置为\u0026quot;Development Editor\u0026quot;, 方案平台设置为\u0026quot;Win64\u0026quot;，随后进行生成\u003c/li\u003e\n\u003cli\u003e进行生成后，点击VS的“开始执行（不调试）”，即可重启UE\u003c/li\u003e\n\u003cli\u003e如果发生错误，可以尝试删除项目中的\u0026quot;Binaries\u0026quot;文件夹以及\u0026quot;Intermediate\u0026quot;文件夹后右键.uproject生成VS项目\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生命周期方法\"\u003e生命周期方法\u003c/h2\u003e\n\u003cp\u003e对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。\u003c/p\u003e\n\u003cp\u003e打印的格式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUE_LOG(LogTemp, Warning, TEXT(\u0026#34;Grabber Constructed\u0026#34;));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ePrimaryComponentTick.bCanEverTick = false;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。\u003c/p\u003e\n\u003ch2 id=\"actor-与-components-比较\"\u003eActor 与 Components 比较\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e\u003c/th\u003e\n          \u003cth\u003eActors\u003c/th\u003e\n          \u003cth\u003eComponents\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan be placed in levels\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCan have components\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e✘\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eModularity\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eInheritance\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDefault variable values\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMaintainability\u003c/td\u003e\n          \u003ctd\u003e低\u003c/td\u003e\n          \u003ctd\u003e高\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eComposable\u003c/td\u003e\n          \u003ctd\u003e_\u003c/td\u003e\n          \u003ctd\u003e√\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。\u003c/p\u003e","title":"Converting Blueprint to C++"},{"content":"在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\n1. 整数输入输出 输入单个整数：\n1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a; cin \u0026gt;\u0026gt; a; // 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); return 0; } 输入多个整数（空格分隔）：\n1 2 int a, b, c; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; // 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); 输出整数：\n1 cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%d\\n\u0026#34;, a); 2. 字符串输入输出 输入无空格的字符串：\n1 2 3 string s; cin \u0026gt;\u0026gt; s; // 遇到空格停止 // 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s); 输入有空格的字符串（整行）：\n1 2 3 4 #include \u0026lt;string\u0026gt; string s; cin.ignore(); // 清除缓冲区残留的换行符 getline(cin, s); // 读取整行（含空格） 输出字符串：\n1 cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // 或 printf(\u0026#34;%s\\n\u0026#34;, s.c_str()); 3. 浮点数输入输出 输入浮点数：\n1 2 double d; cin \u0026gt;\u0026gt; d; // 或 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;d); 输出有效精度固定（如3位有效数字）：\n1 2 #include \u0026lt;iomanip\u0026gt; cout \u0026lt;\u0026lt; setprecision(3) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 非fixed模式下为有效数字 输出小数位数固定（如2位小数）：\n1 cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; // 固定小数点后2位 4. 混合数据输入示例 假设输入格式为：先读整数n，再读n行，每行包含一个带空格的字符串和一个浮点数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; cin.ignore(); // 忽略换行符 while (n--) { string line; getline(cin, line); // 读取整行（如：\u0026#34;Apple Pie 3.1415\u0026#34;） // 使用字符串流分割数据 stringstream ss(line); string name, part; double value; // 提取前导字符串部分 name = \u0026#34;\u0026#34;; while (ss \u0026gt;\u0026gt; part) { if (isdigit(part[0]) || part[0] == \u0026#39;-\u0026#39; || part.find(\u0026#39;.\u0026#39;) != string::npos) { // 可能是数值，回退并提取 ss.seekg(-part.size(), ios::cur); break; } if (!name.empty()) name += \u0026#34; \u0026#34;; name += part; } ss \u0026gt;\u0026gt; value; // 提取数值 // 输出结果，保留两位小数 cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(2) \u0026lt;\u0026lt; value \u0026lt;\u0026lt; endl; } return 0; } 关键库和函数 输入输出基础： \u0026lt;iostream\u0026gt;：提供cin、cout。 \u0026lt;cstdio\u0026gt;：提供scanf、printf（速度更快）。 字符串处理： \u0026lt;string\u0026gt;：提供string类和getline。 格式控制： \u0026lt;iomanip\u0026gt;：提供setprecision、fixed等控制符。 字符串分割： \u0026lt;sstream\u0026gt;：提供stringstream处理复杂输入。 注意事项 关闭同步流提升速度： 1 2 ios::sync_with_stdio(false); cin.tie(0); // 在大量数据输入时优化性能 处理换行符残留：在cin后使用getline时，需先调用cin.ignore()。 通过灵活组合上述方法，可以高效处理ACM竞赛中的各类输入输出需求。\n","permalink":"https://wstfdxfh.github.io/posts/others/acmformat/","summary":"\u003cp\u003e在ACM竞赛中处理各种数据格式的输入输出时，需熟悉C++标准库的输入输出函数和格式控制方法。以下是常见数据类型的处理方式及示例：\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-整数输入输出\"\u003e\u003cstrong\u003e1. 整数输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入单个整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 或 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入多个整数（空格分隔）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 或 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出整数\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 或 printf(\u0026#34;%d\\n\u0026#34;, a);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"2-字符串输入输出\"\u003e\u003cstrong\u003e2. 字符串输入输出\u003c/strong\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入无空格的字符串\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 遇到空格停止\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 或 char s[100]; scanf(\u0026#34;%s\u0026#34;, s);\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输入有空格的字符串（整行）\u003c/strong\u003e：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eignore\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 清除缓冲区残留的换行符\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003egetline\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecin\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e     \u003cspan class=\"c1\"\u003e// 读取整行（含空格）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e输出字符串\u003c/strong\u003e：\u003c/p\u003e","title":"ACMFormat"},{"content":" 可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; struct Point { double x, y; }; // 向量叉积：计算向量a × 向量b的值 double crossProduct(const Point\u0026amp; a, const Point\u0026amp; b) { return a.x * b.y - a.y * b.x; } // 检查点p1和p2是否在边a-b的同一侧（包含边上的点） bool isSameSide(const Point\u0026amp; p1, const Point\u0026amp; p2, const Point\u0026amp; a, const Point\u0026amp; b) { Point ab = {b.x - a.x, b.y - a.y}; // 边a→b的向量 Point ap1 = {p1.x - a.x, p1.y - a.y}; Point ap2 = {p2.x - a.x, p2.y - a.y}; double cp1 = crossProduct(ab, ap1); // 计算叉积AB × AP1 double cp2 = crossProduct(ab, ap2); // 计算叉积AB × AP2 return (cp1 * cp2) \u0026gt;= 0; // 符号相同或其中一个为0（点在线段上） } // 判断点P是否在三角形ABC内 bool isInsideTriangle(const Point\u0026amp; A, const Point\u0026amp; B, const Point\u0026amp; C, const Point\u0026amp; P) { return isSameSide(P, C, A, B) \u0026amp;\u0026amp; // P和C在AB同侧 isSameSide(P, A, B, C) \u0026amp;\u0026amp; // P和A在BC同侧 isSameSide(P, B, C, A); // P和B在CA同侧 } int main() { Point A = {0, 0}; Point B = {3, 0}; Point C = {1.5, 2.5}; Point P = {1.5, 10}; // 待检测点 if (isInsideTriangle(A, B, C, P)) { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形内部\u0026#34; \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;点P在三角形外部\u0026#34; \u0026lt;\u0026lt; std::endl; } return 0; } ","permalink":"https://wstfdxfh.github.io/posts/others/ispointintriangle/","summary":"\u003cul\u003e\n\u003cli\u003e可以使用叉乘的方法判断一个点是否在三角形内部。当三角形中所有边的对点和点P都位于该边的一侧时，就说明P在三角形内部，而判断是否位于一侧可以使用叉乘的符号是否相等来判断。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e43\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"nc\"\u003ePoint\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 向量叉积：计算向量a × 向量b的值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"nf\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 检查点p1和p2是否在边a-b的同一侧（包含边上的点）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eab\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 边a→b的向量\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eap1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eap2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep2\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ecp1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eab\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eap1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 计算叉积AB × AP1\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"kt\"\u003edouble\u003c/span\u003e \u003cspan class=\"n\"\u003ecp2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecrossProduct\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eab\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eap2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 计算叉积AB × AP2\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecp1\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecp2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e             \u003cspan class=\"c1\"\u003e// 符号相同或其中一个为0（点在线段上）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 判断点P是否在三角形ABC内\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003eisInsideTriangle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                      \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// P和C在AB同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e         \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// P和A在BC同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e         \u003cspan class=\"n\"\u003eisSameSide\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// P和B在CA同侧\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mf\"\u003e2.5\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"n\"\u003ePoint\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 待检测点\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eisInsideTriangle\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eA\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eB\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eC\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eP\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;点P在三角形内部\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;点P在三角形外部\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"IsPointInTriangle"},{"content":"UE5快节奏横板射击对战游戏 这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\n前往Github仓库进行下载：\n该游戏项目的原创部分适用于 CC BY-NC 4.0 许可\n开发进度 已完成功能 ✅ 基础场景搭建 ✅ 初始地图设计 ✅ 基础设计系统 ✅ 增益道具系统 ✅ 基础人物角色实现 待开发功能 ⏳ 敌方 AI 系统 ⏳ 多人游戏系统 ⏳ 游戏 UI 优化 ⏳ 更多地图场景 目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\n","permalink":"https://wstfdxfh.github.io/posts/gamedev/platform-shooter/","summary":"\u003ch2 id=\"ue5快节奏横板射击对战游戏\"\u003eUE5快节奏横板射击对战游戏\u003c/h2\u003e\n\u003cp\u003e这是一款基于虚幻引擎5开发的快节奏横板射击游戏，目前仍在早期开发中。游戏采用横板视角，玩家可以在地图中自由移动，通过射击击败对手获得胜利。\u003c/p\u003e\n\u003cp\u003e前往\u003ca href=\"https://github.com/wstfdxfh/Platform-Shooter\"\u003eGithub仓库\u003c/a\u003e进行下载：\u003c/p\u003e\n\u003cp\u003e该游戏项目的原创部分适用于 \u003ca href=\"https://creativecommons.org/licenses/by-nc/4.0/\"\u003eCC BY-NC 4.0\u003c/a\u003e 许可\u003c/p\u003e\n\u003ch2 id=\"开发进度\"\u003e开发进度\u003c/h2\u003e\n\u003ch3 id=\"已完成功能\"\u003e已完成功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e✅ 基础场景搭建\u003c/li\u003e\n\u003cli\u003e✅ 初始地图设计\u003c/li\u003e\n\u003cli\u003e✅ 基础设计系统\u003c/li\u003e\n\u003cli\u003e✅ 增益道具系统\u003c/li\u003e\n\u003cli\u003e✅ 基础人物角色实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"待开发功能\"\u003e待开发功能\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e⏳ 敌方 AI 系统\u003c/li\u003e\n\u003cli\u003e⏳ 多人游戏系统\u003c/li\u003e\n\u003cli\u003e⏳ 游戏 UI 优化\u003c/li\u003e\n\u003cli\u003e⏳ 更多地图场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e目前正在使用C++对项目进行重构，如果对项目感兴趣，请联系我！\u003c/p\u003e","title":"Platform Shooter"}]