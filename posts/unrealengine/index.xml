<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>UnrealEngine on 李睿杰的博客</title>
    <link>https://wstfdxfh.github.io/posts/unrealengine/</link>
    <description>Recent content in UnrealEngine on 李睿杰的博客</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 06 Apr 2025 19:45:39 +0800</lastBuildDate>
    <atom:link href="https://wstfdxfh.github.io/posts/unrealengine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unreal Notes</title>
      <link>https://wstfdxfh.github.io/posts/unrealengine/unreal-notes/</link>
      <pubDate>Sun, 06 Apr 2025 19:45:39 +0800</pubDate>
      <guid>https://wstfdxfh.github.io/posts/unrealengine/unreal-notes/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;常见技巧&#34;&gt;常见技巧&lt;/h2&gt;
&lt;h3 id=&#34;防止速度过快导致的平台位置偏移&#34;&gt;防止速度过快导致的平台位置偏移&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; AMovingPlatform&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tick(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; DeltaTime){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Super&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Tick(DeltaTime);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    FVector CurrentLocation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetActorLocation();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CurrentLocation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CurrentLocation &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (PlatformVelocity&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;DeltaTime);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SetActorLocation(CurrentLocation);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; DistanceMoved &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FVector&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Dist(StartLocation, CurrentLocation);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(DistanceMoved &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; MoveDistance){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 获得速度的单位向量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        FVector MoveDirection &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PlatformVelocty.GetSafeNormal();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        StartLocation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StartLocation&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; MoveDirection&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;MoveDistance;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        SetActorLocation(StartLocation);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        PlatformVelocty &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;PlatformVelocty;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;解决被方块撞击时人物视角的问题&#34;&gt;解决被方块撞击时人物视角的问题&lt;/h3&gt;
&lt;p&gt;这是因为只有角色默认只有在移动时才会检查碰撞&lt;/p&gt;
&lt;p&gt;解决方法：使用蓝图中的&lt;code&gt;MoveUpdatedComponent&lt;/code&gt;，在每一帧都移动一个小距离再反向移动&lt;/p&gt;
&lt;p&gt;可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。&lt;/p&gt;
&lt;h2 id=&#34;ue_log&#34;&gt;UE_LOG&lt;/h2&gt;
&lt;p&gt;打印的格式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;UE_LOG(LogTemp, Warning, TEXT(&amp;#34;Grabber Constructed&amp;#34;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用&lt;code&gt;FString&lt;/code&gt;格式如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FString Name = GetName();
UE_LOG(LogTemp, Warning, TEXT(&amp;#34;%s&amp;#34;), *Name);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;旋转平台&#34;&gt;旋转平台&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;AddActorRotation(RotationVelocity*DeltaT)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;不同的灯光类型&#34;&gt;不同的灯光类型&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;名称&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;解释&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Point Light&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;从一个点向外发射的光源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spot Light&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;聚光灯，有方向性地发出光线&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Rect Light&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;方形的有方向性光源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Directional Light&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;太阳光（只有方向，没有位置的光）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Sky Light&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;将远处的场景作为光源&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;将scenecomponent添加到角色后的旋转差异&#34;&gt;将SceneComponent添加到角色后的旋转差异&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; UGrabber&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;TickComponent(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; DeltaTime, ELevelTick TickType, FActorComponentTickFunction&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ThisTickFunction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	Super&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;TickComponent(DeltaTime, TickType, ThisTickFunction);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; Rotator &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetOwner()&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;GetActorRotation();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; MyRotation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GetComponentRotation();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; RotatorString &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Rotator.ToCompactString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; MyRotationString &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; MyRotation.ToCompactString();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// LogTemp: Display: Owner Rotation: R(Y=-107.75), Component Rotation: R(P=-4.78, Y=-107.75)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// 可以注意到，使用Owner Rotation得到的只有Yaw方向的旋转，而Component Rotation包含Pitch和Yaw旋转
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	UE_LOG(LogTemp, Display, TEXT(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Owner Rotation: %s, Component Rotation: %s&amp;#34;&lt;/span&gt;), &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;RotatorString, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;MyRotationString);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中，Pitch是俯仰角，Yaw是偏航角，除此之外还有一个滚转角Roll。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Converting Blueprint to C&#43;&#43;</title>
      <link>https://wstfdxfh.github.io/posts/unrealengine/converting-blueprint-to-c&#43;&#43;/</link>
      <pubDate>Tue, 25 Mar 2025 22:20:27 +0800</pubDate>
      <guid>https://wstfdxfh.github.io/posts/unrealengine/converting-blueprint-to-c&#43;&#43;/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;ue4-将蓝图转换为c&#34;&gt;UE4: 将蓝图转换为C++&lt;/h1&gt;
&lt;p&gt;教程&lt;a href=&#34;https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c&#34;&gt;https://dev.epicgames.com/community/learning/courses/KJ/unreal-engine-converting-blueprint-to-c/kjB/unreal-engine-introduction-to-blueprint-vs-c&lt;/a&gt;的笔记&lt;/p&gt;
&lt;h2 id=&#34;创建c基类&#34;&gt;创建C++基类&lt;/h2&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用蓝图继承C++，反之不行&lt;/li&gt;
&lt;li&gt;C++可以在运行时调用蓝图的function，称之为Runtime Calls，调用的时候C++调用一个C++的声明函数，并且由蓝图函数实现&lt;/li&gt;
&lt;li&gt;如果要使用蓝图继承C++类，必须在C++类头文件的的UCLASS宏中设置Blueprintable，注意这个关键词(Keyword)是可继承的，比如AActor中已经进行了标注了关键词(Keyword)的话，继承它的类就不需要再进行标注&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;UCLASS( ClassGroup&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(Custom), meta&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(BlueprintSpawnableComponent), Blueprintable)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BLUEPRINTSTOCPP_API&lt;/span&gt; UGrabber : &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; USceneComponent
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;需要对Visual Studio中的配置管理器设置为&amp;quot;Development Editor&amp;quot;, 方案平台设置为&amp;quot;Win64&amp;quot;，随后进行生成&lt;/li&gt;
&lt;li&gt;进行生成后，点击VS的“开始执行（不调试）”，即可重启UE&lt;/li&gt;
&lt;li&gt;如果发生错误，可以尝试删除项目中的&amp;quot;Binaries&amp;quot;文件夹以及&amp;quot;Intermediate&amp;quot;文件夹后右键.uproject生成VS项目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生命周期方法&#34;&gt;生命周期方法&lt;/h2&gt;
&lt;p&gt;对于AActor类和SceneComponent类来说，它们都有各自的构造函数、Beginplay函数以及Tick（或者是TickComponent）函数，可以使用UE_LOG进行日志打印，打印的结果会出现在UE的Output Log窗口中。&lt;/p&gt;
&lt;p&gt;打印的格式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;UE_LOG(LogTemp, Warning, TEXT(&amp;#34;Grabber Constructed&amp;#34;));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在以上函数中都加入类似的日志打印以后生成，会发现构造函数在打开编辑器以及开始游戏时各调用一次；Beginplay在开始游戏时（在构造函数后）调用一次；Tick会在之后每帧调用，通过&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PrimaryComponentTick.bCanEverTick = false;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以禁用Tick函数的调用，节约CPU，但是这个设置会被继承的蓝图覆盖。&lt;/p&gt;
&lt;h2 id=&#34;actor-与-components-比较&#34;&gt;Actor 与 Components 比较&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;Actors&lt;/th&gt;
          &lt;th&gt;Components&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Can be placed in levels&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
          &lt;td&gt;✘&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Can have components&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
          &lt;td&gt;✘&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Modularity&lt;/td&gt;
          &lt;td&gt;低&lt;/td&gt;
          &lt;td&gt;高&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Inheritance&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Default variable values&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Maintainability&lt;/td&gt;
          &lt;td&gt;低&lt;/td&gt;
          &lt;td&gt;高&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Composable&lt;/td&gt;
          &lt;td&gt;_&lt;/td&gt;
          &lt;td&gt;√&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们一般倾向于将Components接在Actor上，而Actor本身不去实现太多功能。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
