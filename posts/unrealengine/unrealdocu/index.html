<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>UnrealDocu | 李睿杰的博客</title>
<meta name="keywords" content="">
<meta name="description" content="针对Unreal文档的摘录
Unreal 反射系统
https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4
Unreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C&#43;&#43;类、函数和变量。

Unreal 中所有对象的基类是 UObject。
TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。
类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。
Unreal 智能指针库是对 C&#43;&#43;11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。
接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。
元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。
UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。

Objects

UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。
虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。
一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C&#43;&#43;代码中可用的普通 C&#43;&#43;函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。
UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。
UObject 不支持构造函数参数。所有 C&#43;&#43; UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。

UOBJECT支持以下广泛的功能：">
<meta name="author" content="李睿杰">
<link rel="canonical" href="https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wstfdxfh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://wstfdxfh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://wstfdxfh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://wstfdxfh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://wstfdxfh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/">
  <meta property="og:site_name" content="李睿杰的博客">
  <meta property="og:title" content="UnrealDocu">
  <meta property="og:description" content="针对Unreal文档的摘录
Unreal 反射系统 https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4
Unreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C&#43;&#43;类、函数和变量。
Unreal 中所有对象的基类是 UObject。 TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。 类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。 Unreal 智能指针库是对 C&#43;&#43;11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。 接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。 元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。 UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。 Objects UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。 虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。 一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C&#43;&#43;代码中可用的普通 C&#43;&#43;函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。 UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。 UObject 不支持构造函数参数。所有 C&#43;&#43; UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。 UOBJECT支持以下广泛的功能：">
  <meta property="og:locale" content="zh-CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-05T23:22:23+08:00">
    <meta property="article:modified_time" content="2025-05-05T23:22:23+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UnrealDocu">
<meta name="twitter:description" content="针对Unreal文档的摘录
Unreal 反射系统
https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4
Unreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C&#43;&#43;类、函数和变量。

Unreal 中所有对象的基类是 UObject。
TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。
类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。
Unreal 智能指针库是对 C&#43;&#43;11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。
接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。
元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。
UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。

Objects

UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。
虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。
一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C&#43;&#43;代码中可用的普通 C&#43;&#43;函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。
UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。
UObject 不支持构造函数参数。所有 C&#43;&#43; UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。

UOBJECT支持以下广泛的功能：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://wstfdxfh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "UnrealEngine",
      "item": "https://wstfdxfh.github.io/posts/unrealengine/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "UnrealDocu",
      "item": "https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UnrealDocu",
  "name": "UnrealDocu",
  "description": "针对Unreal文档的摘录\nUnreal 反射系统 https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4\nUnreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C++类、函数和变量。\nUnreal 中所有对象的基类是 UObject。 TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。 类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。 Unreal 智能指针库是对 C++11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。 接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。 元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。 UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。 Objects UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。 虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。 一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C++代码中可用的普通 C++函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。 UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。 UObject 不支持构造函数参数。所有 C++ UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。 UOBJECT支持以下广泛的功能：\n",
  "keywords": [
    
  ],
  "articleBody": "针对Unreal文档的摘录\nUnreal 反射系统 https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4\nUnreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C++类、函数和变量。\nUnreal 中所有对象的基类是 UObject。 TSubclassOf 是一个模板类，提供 UClass 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。 类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 USTRUCT() 宏单独定义。 Unreal 智能指针库是对 C++11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。 接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。 元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。 UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。 Objects UCLASS 宏为 UObject 提供了一个指向描述其 Unreal 类型信息的 UCLASS 引用。每个 UCLASS 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。 虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 GetClass() 函数访问。 一个 UCLASS 包含一组定义类的属性和函数。这些是标准 C++代码中可用的普通 C++函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。 UObject 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。 UObject 不支持构造函数参数。所有 C++ UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。UObject 在运行时应当仅通过 NewObject 创建，或在构造函数中使用 CreateDefaultSubobject。 UOBJECT支持以下广泛的功能：\nReflection 反射 Serialization 序列化 Automatic updating of default property changes 默认属性变更的自动更新 Automatic property initialization 自动属性初始化 Automatic editor integration 自动编辑器集成 Type information available at runtime 运行时可用的类型信息 Network replication 网络复制 The Unreal Header Tool 要利用 UObject 派生类型提供的功能，需要对这些类型的头文件运行预处理步骤以收集所需信息。该预处理步骤由 UnrealHeaderTool（简称 UHT）执行。UObject 派生类型需遵循特定的结构规范。\n假设 UObject 派生类名为 UMyObject，创建它的项目名为 MyProject，其基础头文件可能如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 #pragma once #include 'Object.h' // 这一行预期是该文件中最后一个 #include 指令。如果此头文件需要了解其他类，可以在文件任意位置前向声明它们，或在 MyObject.generated.h 上方包含相关文件。 #include 'MyObject.generated.h' // UCLASS 宏使 UMyObject 对 Unreal Engine 可见。该宏支持多种 Class Specifiers（类说明符），用于决定为类启用或禁用哪些功能。 UCLASS() // 如果 MyProject 希望将 UMyObject 类暴露给其他模块，则必须指定 MYPROJECT_API 。这对于将被游戏项目包含的模块或插件最为有用。 class MYPROJECT_API UMyObject : public UObject { // GENERATED_BODY 宏不接收任何参数，但会设置类以支持引擎所需的基础设施。所有 UCLASS 和 USTRUCT 都需要它。 GENERATED_BODY() }; 更新对象 “Tick”（帧更新）指的是虚幻引擎中对象的更新机制。所有 Actor 都具备每帧被更新的能力，这为执行必要的计算或操作提供了途径。\n当注册启用时，Actor 和 ActorComponent 会自动调用其 Tick 函数，但 UObjects 并不具备内置的更新功能。若项目需要，可通过继承 FTickableGameObject 类（使用 inherits 类说明符）来添加此功能。随后它们可实现 Tick() 函数，该函数将由引擎每帧调用。\n销毁对象 对象销毁由垃圾回收系统在对象不再被引用时自动处理。这意味着不应有任何 UPROPERTY 指针、引擎容器、 TStrongObjectPtr 或类实例对它们持有强引用。 当垃圾收集器运行时，未被引用的对象会被从内存中移除。此外，可以直接在对象上调用函数 MarkPendingKill() 。此函数会将所有指向该对象的指针设为 NULL ，并将该对象从全局搜索中移除。该对象将在下一次垃圾回收过程中被完全删除。 对于 Actor 而言，即使对其调用了 Destroy() 并将其从关卡中移除，只要仍存在对它的引用，该 Actor 就不会被垃圾回收。 NewObject 1 2 3 4 template\u003c class T \u003e T* NewObject ( UObject* Outer=(UObject*)GetTransientPackage(), UClass* Class=T::StaticClass() ) NewNamedObject NewNamedObject() 在 NewObject() 的基础上进行了扩展，允许为新实例指定名称，同时还能通过参数设置对象标志和模板对象。\n1 2 3 4 5 6 template\u003c class TClass \u003e TClass* NewNamedObject( UObject* Outer, FName Name, EObjectFlags Flags = RF_NoFlags, UObject const* Template=NULL ) ConstructObject 为实现完全灵活性，可使用 ConstructObject() 函数创建 UObjects 的新实例。该函数会调用 StaticConstructObject() 来分配对象、执行 ClassConstructor ，并执行诸如加载配置属性、加载本地化属性及实例化组件等初始化操作。\nObject Flags EObjectFlags 枚举用于快速简洁地描述一个对象。它包含多种标志来描述对象的类型、垃圾回收处理方式、对象生命周期的当前阶段等。此外，还提供了特殊的全选或全不选掩码以及预定义的标志组。\n引用自动更新 **当一个 AActor 或 UActorComponent 被销毁或以其他方式从游戏中移除时，反射系统可见的所有对其引用（如 UProperty 指针和存储在 Unreal Engine 容器类如 TArray 中的指针）会自动置空。**这样做的好处是防止悬空指针持续存在并引发后续问题，但也意味着如果其他代码销毁了它们， AActor 和 UActorComponent 指针可能会变为空值。这一机制的最终优势在于空值检查更加可靠，因为它既能检测标准情况下的空指针，也能检测非空指针指向已删除内存的情况。 **需要注意的是，此特性仅适用于标记为 UActorComponent 或 AActor 的引用，或存储在 Unreal Engine 容器类中的引用。存储在原始指针中的对象引用对 Unreal Engine 而言是未知的，既不会自动置空，也不会阻止垃圾回收。**请注意，这并不意味着所有 UObject* 变量都必须 UProperties 。如果你需要一个非 UProperty 的对象指针，可以考虑使用 TWeakObjectPtr 。这是一种\"弱\"指针，意味着它不会阻止垃圾回收，但在访问前可以查询其有效性，并且如果指向的对象被销毁，它会被置空。 另一种被引用 UObject UProperty 会被自动置空的情况是在编辑器中对资源使用’强制删除’操作。因此，所有操作作为资源的 UObject 的代码都必须处理这些指针变为空的情况。 序列化 当 UObject 被序列化时，除非显式标记为\"transient\"或保持构造后默认值未变，否则所有 UProperty 值都会自动写入或读取。例如，您可以在关卡中放置一个 AEnemy 实例，将其生命值设为 500，保存后无需在 UClass 定义之外编写任何代码即可成功重新加载。 当 UProperty 被添加或移除时，系统会无缝处理已有内容的加载。新增属性会从新的类默认对象(CDO)中复制默认值，被移除的属性则会被静默忽略。 如需自定义行为，可重写 UObject::Serialize 函数。这对于检测数据错误、检查版本号，或在数据格式变更时执行自动转换或更新非常有用。 属性值更新 当一个类的类默认对象（CDO）发生变更时，引擎会在加载该类的所有实例时尝试应用这些变更。对于给定的对象实例，如果更新变量的值与旧 CDO 中的值匹配，则该值会被更新为新 CDO 中的值。如果变量具有其他任何值，则假定该值是故意设置的，这些变更将被保留。（就是说，如果在实例中修改了这些值，即使修改类默认值也不会修改这些内容） 运行时类型信息与类型转换 由于 UObjects 属于虚幻引擎的反射系统，它们始终知晓自身的 UClass 类型，因此可以在运行时进行类型相关决策和类型转换。 在原生代码中，每个 UObject 类都有一个自定义的 Super 类型定义指向其父类，这使得行为重写控制更加便捷。 此外，你可以安全地使用模板化的 Cast 函数将对象从基类转换为更派生的类，或者使用 IsA 查询对象是否属于特定类。 1 2 3 4 5 6 7 8 9 10 11 class ALegendaryWeapon : public AWeapon { void SlayMegaBoss() { TArray\u003cAEnemy\u003e EnemyList = GetEnemyListFromSomewhere(); // The legendary weapon is only effective against the MegaBoss for (AEnemy Enemy : EnemyList) { AMegaBoss* MegaBoss = Cast\u003cAMegaBoss\u003e(Enemy); if (MegaBoss) Incinerate(MegaBoss); } } }; 垃圾回收 虚幻引擎采用一套垃圾回收机制，当 UObjects 不再被引用或已被显式标记为待销毁时，系统会定期清理这些对象。**引擎通过构建引用关系图来判定哪些 UObjects 仍在使用中，哪些已成为孤立对象。**该图的根部是一组被指定为\"根集\"的 UObjects 。任何 UObject 都可被添加至根集中。当垃圾回收触发时，引擎能够通过从根集出发遍历已知 UObject 引用树，追踪所有被引用的 UObjects 。那些未被引用到的 UObjects （即在树搜索中未找到的对象）将被判定为不再需要，并予以移除。 这里的一个实际含义是，你通常需要维护一个 UPROPERTY 引用以保持任何你想保留的 Object 存活，无论它是一个简单的 Object 指针还是包含 Object 指针类型的 Unreal Engine 容器类，例如 TArray 。Actors 及其 Components 通常是这一规则的例外，因为 Actors 通常被链接回根集的 Object 引用，例如它们所属的 Level，而 Actor 的 Components 则由 Actor 自身引用。可以通过调用 Actors 的 Destroy 函数显式标记它们为销毁状态，这是从进行中的游戏中移除 Actor 的标准方法。Components 可以通过 DestroyComponent 函数显式销毁，但它们通常在其所属的 Actor 从游戏中移除时被销毁。 此外还可调整其他功能来更精确地控制垃圾回收的执行时机与方式，这些设置大多位于项目设置的\"Engine - Garbage Collection“分类下。 Incremental Garbage Collection 增量垃圾回收 Improved garbage collection system for UObjects.\n虚幻引擎(UE)采用标记-清除垃圾回收机制来管理 UObject 内存。对于软实时应用而言，垃圾回收器历来存在一个主要缺陷**：在执行可达性分析确定哪些对象内存可回收时，可能导致游戏卡顿。**在 UE 中，这一过程称为可达性分析。**UE 始终要求垃圾回收的这一阶段必须在一帧内完成，期间会暂时停止所有 UObject 处理（尤其是游戏逻辑）。需要扫描的可达对象越多，暂停时间就越长，通常很容易因此引发明显的游戏卡顿。**程序员可通过多种方式规避此问题，例如：\n严格控制 UObject 数量 使用 UObject 对象池 在常规游戏过程中禁用垃圾回收 UE 通过增量可达性分析对此进行了改进。用户现在能够将垃圾回收器的可达性分析阶段分散到多个帧中完成，并配置每帧的软性时间限制。引擎通过 TObjectPtr 属性跟踪可达性分析迭代间的 UObject 引用。即，在垃圾回收进行期间，任何对 TObjectPtr 暴露的 UPROPERTY 的赋值都会立即将该对象标记为可达。这也被称为垃圾回收写屏障。\n引擎已全面改用 TObjectPtr 替代原始 C++指针，所有向垃圾回收器暴露 UObject 的场景（包括 UObject 或 FGCObject AddReferencedObjects 函数）均已适配。要在基于虚幻引擎构建的项目中使用增量可达性分析，必须将所有 UPROPERTY 实例转换为使用 TObjectPtr 而非原始 C++指针，否则垃圾回收可能过早释放某些 UObject 的内存。该功能目前作为实验性功能发布，因为可达性分析阶段仍有可能超出规定的时间限制。\nProperties Int类型 整数数据类型的命名惯例是 “int” 或 “uint” 后跟以位为单位的长度，比如 int32, uint8。 整型属性现在可以作为位掩码暴露给编辑器。要将整型属性标记为位掩码，只需在元数据部分添加\"bitmask”，如下所示： 1 2 3 4 5 6 7 /*~ BasicBits appears as a list of generic flags in the editor, instead of an integer field. */ UPROPERTY(EditAnywhere, Meta = (Bitmask)) int32 BasicBits; /*~ You can set MyFunction using a generic list of flags instead of typing in an integer value. */ UFUNCTION(BlueprintCallable) void MyFunction(UPARAM(meta=(Bitmask)) int32 BasicBitsParam) 为了自定义位标志的名称，我们首先需要创建一个带有\"bitflags\"元标签的 UENUM： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 UENUM(Meta = (Bitflags)) enum class EColorBits { ECB_Red, ECB_Green, ECB_Blue }; /*~ This property lists flags matching the names of values from EColorBits. */ UPROPERTY(EditAnywhere, Meta = (Bitmask, BitmaskEnum = \"EColorBits\")) int32 ColorFlags; /*~ MyOtherFunction shows flags named after the values from EColorBits. */ UFUNCTION(BlueprintCallable) void MyOtherFunction(UPARAM(meta=(Bitmask, BitmaskEnum = \"EColorBits\")) int32 ColorFlagsParam) Float类型 Unreal 使用标准的 C++浮点类型，包括 float 和 double。\nBool类型 1 2 uint32 bIsHungry : 1; bool bIsThirsty; 字符串类型 UE支持3种字符串类型：\nFString 类型是一个变长的字符串 FName是固定长度的字符串 FText更加复杂，是支持本地化的字符串 UE的字符类型为TCHAR，可以使用TEXT宏来表示字面量\nUPROPERTY属性说明符 在声明属性时，可以添加属性说明符（Property Specifiers）来控制该属性在引擎和编辑器各个方面的行为表现。 详见 https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-uproperties?application_version=5.4\nUPROPERTY元数据说明符 在声明类、接口、结构体、枚举、枚举值、函数或属性时，可以添加元数据说明符以控制它们与引擎及编辑器各部分的交互方式。每种数据结构或成员类型都有其专属的元数据说明符列表。\n元数据仅存在于编辑器中；不要编写访问元数据的游戏逻辑。\n",
  "wordCount" : "692",
  "inLanguage": "en",
  "datePublished": "2025-05-05T23:22:23+08:00",
  "dateModified": "2025-05-05T23:22:23+08:00",
  "author":{
    "@type": "Person",
    "name": "李睿杰"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wstfdxfh.github.io/posts/unrealengine/unrealdocu/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "李睿杰的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wstfdxfh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wstfdxfh.github.io/" accesskey="h" title="李睿杰的博客 (Alt + H)">李睿杰的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wstfdxfh.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://wstfdxfh.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://wstfdxfh.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://wstfdxfh.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://wstfdxfh.github.io/posts/unrealengine/">UnrealEngine</a></div>
    <h1 class="post-title entry-hint-parent">
      UnrealDocu
    </h1>
    <div class="post-meta"><span title='2025-05-05 23:22:23 +0800 CST'>May 5, 2025</span>&nbsp;·&nbsp;李睿杰

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#unreal-%e5%8f%8d%e5%b0%84%e7%b3%bb%e7%bb%9f" aria-label="Unreal 反射系统">Unreal 反射系统</a><ul>
                        
                <li>
                    <a href="#objects" aria-label="Objects">Objects</a><ul>
                        
                <li>
                    <a href="#the-unreal-header-tool" aria-label="The Unreal Header Tool">The Unreal Header Tool</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e5%af%b9%e8%b1%a1" aria-label="更新对象">更新对象</a></li>
                <li>
                    <a href="#%e9%94%80%e6%af%81%e5%af%b9%e8%b1%a1" aria-label="销毁对象">销毁对象</a></li>
                <li>
                    <a href="#newobject" aria-label="NewObject">NewObject</a></li>
                <li>
                    <a href="#newnamedobject" aria-label="NewNamedObject">NewNamedObject</a></li>
                <li>
                    <a href="#constructobject" aria-label="ConstructObject">ConstructObject</a></li>
                <li>
                    <a href="#object-flags" aria-label="Object Flags">Object Flags</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e8%87%aa%e5%8a%a8%e6%9b%b4%e6%96%b0" aria-label="引用自动更新">引用自动更新</a></li>
                <li>
                    <a href="#%e5%ba%8f%e5%88%97%e5%8c%96" aria-label="序列化">序列化</a></li>
                <li>
                    <a href="#%e5%b1%9e%e6%80%a7%e5%80%bc%e6%9b%b4%e6%96%b0" aria-label="属性值更新">属性值更新</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af%e4%b8%8e%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" aria-label="运行时类型信息与类型转换">运行时类型信息与类型转换</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" aria-label="垃圾回收">垃圾回收</a></li>
                <li>
                    <a href="#incremental-garbage-collection-%e5%a2%9e%e9%87%8f%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" aria-label="Incremental Garbage Collection 增量垃圾回收">Incremental Garbage Collection 增量垃圾回收</a></li></ul>
                </li>
                <li>
                    <a href="#properties" aria-label="Properties">Properties</a><ul>
                        
                <li>
                    <a href="#int%e7%b1%bb%e5%9e%8b" aria-label="Int类型">Int类型</a></li>
                <li>
                    <a href="#float%e7%b1%bb%e5%9e%8b" aria-label="Float类型">Float类型</a></li>
                <li>
                    <a href="#bool%e7%b1%bb%e5%9e%8b" aria-label="Bool类型">Bool类型</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b" aria-label="字符串类型">字符串类型</a></li>
                <li>
                    <a href="#uproperty%e5%b1%9e%e6%80%a7%e8%af%b4%e6%98%8e%e7%ac%a6" aria-label="UPROPERTY属性说明符">UPROPERTY属性说明符</a></li>
                <li>
                    <a href="#uproperty%e5%85%83%e6%95%b0%e6%8d%ae%e8%af%b4%e6%98%8e%e7%ac%a6" aria-label="UPROPERTY元数据说明符">UPROPERTY元数据说明符</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>针对Unreal文档的摘录</p>
<h2 id="unreal-反射系统">Unreal 反射系统<a hidden class="anchor" aria-hidden="true" href="#unreal-反射系统">#</a></h2>
<p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4">https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine?application_version=5.4</a></p>
<p>Unreal Engine 反射系统通过多种宏封装类，以提供引擎和编辑器功能。在使用 Unreal Engine(UE)编程时，可以拥有标准的 C++类、函数和变量。</p>
<ul>
<li>Unreal 中所有对象的基类是 UObject。</li>
<li>TSubclassOf 是一个模板类，提供 <code>UClass</code> 类型安全。它适用于分配从特定类型派生的类。例如，可以将此变量暴露给蓝图，设计师可以在其中指定为玩家角色生成哪种武器类。</li>
<li>类可以包含结构体。结构体是一种数据结构，有助于组织和管理其相关的成员属性。结构体可以使用 <code>USTRUCT()</code> 宏单独定义。</li>
<li>Unreal 智能指针库是对 C++11 智能指针的自定义实现，旨在减轻内存分配和跟踪的负担。该实现包括行业标准的共享指针、弱指针、唯一指针以及行为类似于非可空共享指针的共享引用。</li>
<li>接口提供了可以在多个或不同类中实现的函数和额外游戏行为。你的玩家角色可以与世界中的各种 Actor 互动。这些互动中的每一个都可能对事件产生不同的反应。</li>
<li>元数据说明符控制类、接口、结构体、枚举、函数或属性如何与引擎和编辑器的各个方面交互。每种数据结构或成员都有其自己的元数据说明符列表。</li>
<li>UFUNCTION 和 UPROPERTY 宏使 UE 能够识别新的类、函数和变量。这些宏由引擎进行垃圾回收。在指定宏时，您可以在虚幻编辑器中编辑和显示它们。</li>
</ul>
<h3 id="objects"><strong>Objects</strong><a hidden class="anchor" aria-hidden="true" href="#objects">#</a></h3>
<ul>
<li><code>UCLASS</code> 宏为 <code>UObject</code> 提供了一个指向描述其 Unreal 类型信息的 <code>UCLASS</code> 引用。<strong>每个 <code>UCLASS</code> 维护着一个名为类默认对象(Class Default Object, CDO)的 Object。CDO 本质上是由类构造函数生成且之后不再修改的默认“模板”对象。</strong></li>
<li>虽然通常应视为只读，但可以通过给定对象实例检索 UCLASS 和 CDO。对象实例的 UCLASS 随时可通过 <code>GetClass()</code> 函数访问。</li>
<li>一个 <code>UCLASS</code> 包含一组定义类的属性和函数。这些是标准 C++代码中可用的普通 C++函数和变量，但带有控制其在对象系统内行为的 Unreal Engine 特定元数据标签。</li>
<li><code>UObject</code> 类可以包含未用 UFUNCTION 或 UPROPERTY 说明符标记反射的原生属性。然而，只有被说明符宏标记的函数和属性才会在其对应的 UCLASS 中列出。</li>
<li><code>UObject</code> 不支持构造函数参数。所有 C++ UObject 在引擎启动时初始化，引擎会调用它们的默认构造函数。如果没有默认构造函数，你的 UObject 将无法编译。<strong>UObject 在运行时应当仅通过 <code>NewObject</code> 创建，或在构造函数中使用 <code>CreateDefaultSubobject</code>。</strong></li>
</ul>
<p><code>UOBJECT</code>支持以下广泛的功能：</p>
<ul>
<li>Reflection 反射</li>
<li>Serialization 序列化</li>
<li>Automatic updating of default property changes 默认属性变更的自动更新</li>
<li>Automatic property initialization 自动属性初始化</li>
<li>Automatic editor integration 自动编辑器集成</li>
<li>Type information available at runtime 运行时可用的类型信息</li>
<li>Network replication 网络复制</li>
</ul>
<h4 id="the-unreal-header-tool">The Unreal Header Tool<a hidden class="anchor" aria-hidden="true" href="#the-unreal-header-tool">#</a></h4>
<p>要利用 UObject 派生类型提供的功能，需要对这些类型的头文件运行预处理步骤以收集所需信息。该预处理步骤由 UnrealHeaderTool（简称 UHT）执行。UObject 派生类型需遵循特定的结构规范。</p>
<p>假设 UObject 派生类名为 UMyObject，创建它的项目名为 MyProject，其基础头文件可能如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#pragma once
</span></span></span><span class="line"><span class="cl"><span class="cp">#include &#39;Object.h&#39;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 这一行预期是该文件中最后一个 #include 指令。如果此头文件需要了解其他类，可以在文件任意位置前向声明它们，或在 MyObject.generated.h 上方包含相关文件。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include &#39;MyObject.generated.h&#39;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// UCLASS 宏使 UMyObject 对 Unreal Engine 可见。该宏支持多种 Class Specifiers（类说明符），用于决定为类启用或禁用哪些功能。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">UCLASS</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 如果 MyProject 希望将 UMyObject 类暴露给其他模块，则必须指定 MYPROJECT_API 。这对于将被游戏项目包含的模块或插件最为有用。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">MYPROJECT_API</span> <span class="nl">UMyObject</span> <span class="p">:</span> <span class="k">public</span> <span class="n">UObject</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="c1">// GENERATED_BODY 宏不接收任何参数，但会设置类以支持引擎所需的基础设施。所有 UCLASS 和 USTRUCT 都需要它。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">GENERATED_BODY</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="更新对象">更新对象<a hidden class="anchor" aria-hidden="true" href="#更新对象">#</a></h4>
<ul>
<li>
<p><strong>“Tick”（帧更新）指的是虚幻引擎中对象的更新机制。所有 Actor 都具备每帧被更新的能力，这为执行必要的计算或操作提供了途径。</strong></p>
</li>
<li>
<p>当注册启用时，Actor 和 ActorComponent 会自动调用其 Tick 函数，但 <code>UObjects</code> 并不具备内置的更新功能。若项目需要，可通过继承 <code>FTickableGameObject</code> 类（使用 inherits 类说明符）来添加此功能。随后它们可实现 <code>Tick()</code> 函数，该函数将由引擎每帧调用。</p>
</li>
</ul>
<h4 id="销毁对象">销毁对象<a hidden class="anchor" aria-hidden="true" href="#销毁对象">#</a></h4>
<ul>
<li>对象销毁由垃圾回收系统在对象不再被引用时自动处理。这意味着不应有任何 <code>UPROPERTY</code> 指针、引擎容器、 <code>TStrongObjectPtr</code> 或类实例对它们持有强引用。</li>
<li>当垃圾收集器运行时，未被引用的对象会被从内存中移除。此外，可以直接在对象上调用函数 <code>MarkPendingKill()</code> 。此函数会将所有指向该对象的指针设为 <code>NULL</code> ，并将该对象从全局搜索中移除。该对象将在下一次垃圾回收过程中被完全删除。</li>
<li><strong>对于 Actor 而言，即使对其调用了 <code>Destroy()</code> 并将其从关卡中移除，只要仍存在对它的引用，该 Actor 就不会被垃圾回收。</strong></li>
</ul>
<h4 id="newobject">NewObject<a hidden class="anchor" aria-hidden="true" href="#newobject">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span> <span class="n">T</span><span class="o">*</span> <span class="n">NewObject</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">UObject</span><span class="o">*</span> <span class="n">Outer</span><span class="o">=</span><span class="p">(</span><span class="n">UObject</span><span class="o">*</span><span class="p">)</span><span class="n">GetTransientPackage</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">    <span class="n">UClass</span><span class="o">*</span> <span class="n">Class</span><span class="o">=</span><span class="n">T</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="newnamedobject">NewNamedObject<a hidden class="anchor" aria-hidden="true" href="#newnamedobject">#</a></h4>
<p><code>NewNamedObject()</code> 在 <code>NewObject()</code> 的基础上进行了扩展，允许为新实例指定名称，同时还能通过参数设置对象标志和模板对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">TClass</span> <span class="o">&gt;</span> <span class="n">TClass</span><span class="o">*</span> <span class="n">NewNamedObject</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">UObject</span><span class="o">*</span> <span class="n">Outer</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">FName</span> <span class="n">Name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">EObjectFlags</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">RF_NoFlags</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">UObject</span> <span class="k">const</span><span class="o">*</span> <span class="n">Template</span><span class="o">=</span><span class="nb">NULL</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="constructobject">ConstructObject<a hidden class="anchor" aria-hidden="true" href="#constructobject">#</a></h4>
<p>为实现完全灵活性，可使用 <code>ConstructObject()</code> 函数创建 <code>UObjects</code> 的新实例。该函数会调用 <code>StaticConstructObject()</code> 来分配对象、执行 <code>ClassConstructor</code> ，并执行诸如加载配置属性、加载本地化属性及实例化组件等初始化操作。</p>
<h4 id="object-flags">Object Flags<a hidden class="anchor" aria-hidden="true" href="#object-flags">#</a></h4>
<p><code>EObjectFlags</code> 枚举用于快速简洁地描述一个对象。它包含多种标志来描述对象的类型、垃圾回收处理方式、对象生命周期的当前阶段等。此外，还提供了特殊的全选或全不选掩码以及预定义的标志组。</p>
<h4 id="引用自动更新">引用自动更新<a hidden class="anchor" aria-hidden="true" href="#引用自动更新">#</a></h4>
<ul>
<li>**当一个 <code>AActor</code> 或 <code>UActorComponent</code> 被销毁或以其他方式从游戏中移除时，反射系统可见的所有对其引用（如 <code>UProperty</code> 指针和存储在 Unreal Engine 容器类如 <code>TArray</code> 中的指针）会自动置空。**这样做的好处是防止悬空指针持续存在并引发后续问题，但也意味着如果其他代码销毁了它们， <code>AActor</code> 和 <code>UActorComponent</code> 指针可能会变为空值。这一机制的最终优势在于空值检查更加可靠，因为它既能检测标准情况下的空指针，也能检测非空指针指向已删除内存的情况。</li>
<li>**需要注意的是，此特性仅适用于标记为 <code>UActorComponent</code> 或 <code>AActor</code> 的引用，或存储在 Unreal Engine 容器类中的引用。存储在原始指针中的对象引用对 Unreal Engine 而言是未知的，既不会自动置空，也不会阻止垃圾回收。**请注意，这并不意味着所有 <code>UObject*</code> 变量都必须 <code>UProperties</code> 。<strong>如果你需要一个非 <code>UProperty</code> 的对象指针，可以考虑使用 <code>TWeakObjectPtr</code> 。这是一种&quot;弱&quot;指针，意味着它不会阻止垃圾回收，但在访问前可以查询其有效性，并且如果指向的对象被销毁，它会被置空。</strong></li>
<li>另一种被引用 UObject UProperty 会被自动置空的情况是在编辑器中对资源使用&rsquo;强制删除&rsquo;操作。因此，所有操作作为资源的 UObject 的代码都必须处理这些指针变为空的情况。</li>
</ul>
<h4 id="序列化">序列化<a hidden class="anchor" aria-hidden="true" href="#序列化">#</a></h4>
<ul>
<li>当 <code>UObject</code> 被序列化时，除非显式标记为&quot;transient&quot;或保持构造后默认值未变，否则所有 <code>UProperty</code> 值都会自动写入或读取。例如，您可以在关卡中放置一个 <code>AEnemy</code> 实例，将其生命值设为 500，保存后无需在 <code>UClass</code> 定义之外编写任何代码即可成功重新加载。</li>
<li>当 UProperty 被添加或移除时，系统会无缝处理已有内容的加载。新增属性会从新的类默认对象(CDO)中复制默认值，被移除的属性则会被静默忽略。</li>
<li>如需自定义行为，可重写 <code>UObject::Serialize</code> 函数。这对于检测数据错误、检查版本号，或在数据格式变更时执行自动转换或更新非常有用。</li>
</ul>
<h4 id="属性值更新">属性值更新<a hidden class="anchor" aria-hidden="true" href="#属性值更新">#</a></h4>
<ul>
<li>当一个类的类默认对象（CDO）发生变更时，引擎会在加载该类的所有实例时尝试应用这些变更。对于给定的对象实例，如果更新变量的值与旧 CDO 中的值匹配，则该值会被更新为新 CDO 中的值。如果变量具有其他任何值，则假定该值是故意设置的，这些变更将被保留。<strong>（就是说，如果在实例中修改了这些值，即使修改类默认值也不会修改这些内容）</strong></li>
</ul>
<h4 id="运行时类型信息与类型转换">运行时类型信息与类型转换<a hidden class="anchor" aria-hidden="true" href="#运行时类型信息与类型转换">#</a></h4>
<ul>
<li>由于 <code>UObjects</code> 属于虚幻引擎的反射系统，它们始终知晓自身的 <code>UClass</code> 类型，因此可以在运行时进行类型相关决策和类型转换。</li>
<li>在原生代码中，每个 <code>UObject</code> 类都有一个自定义的 <code>Super</code> 类型定义指向其父类，这使得行为重写控制更加便捷。</li>
<li>此外，你可以安全地使用模板化的 <code>Cast</code> 函数将对象从基类转换为更派生的类，或者使用 <code>IsA</code> 查询对象是否属于特定类。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ALegendaryWeapon</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AWeapon</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">SlayMegaBoss</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">TArray</span><span class="o">&lt;</span><span class="n">AEnemy</span><span class="o">&gt;</span> <span class="n">EnemyList</span> <span class="o">=</span> <span class="n">GetEnemyListFromSomewhere</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The legendary weapon is only effective against the MegaBoss
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">AEnemy</span> <span class="nl">Enemy</span> <span class="p">:</span> <span class="n">EnemyList</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">AMegaBoss</span><span class="o">*</span> <span class="n">MegaBoss</span> <span class="o">=</span> <span class="n">Cast</span><span class="o">&lt;</span><span class="n">AMegaBoss</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Enemy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">MegaBoss</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">Incinerate</span><span class="p">(</span><span class="n">MegaBoss</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="垃圾回收">垃圾回收<a hidden class="anchor" aria-hidden="true" href="#垃圾回收">#</a></h4>
<ul>
<li>虚幻引擎采用一套垃圾回收机制，当 <code>UObjects</code> 不再被引用或已被显式标记为待销毁时，系统会定期清理这些对象。**引擎通过构建引用关系图来判定哪些 <code>UObjects</code> 仍在使用中，哪些已成为孤立对象。**该图的根部是一组被指定为&quot;根集&quot;的 <code>UObjects</code> 。任何 <code>UObject</code> 都可被添加至根集中。<strong>当垃圾回收触发时，引擎能够通过从根集出发遍历已知 <code>UObject</code> 引用树，追踪所有被引用的 <code>UObjects</code> 。那些未被引用到的 <code>UObjects</code> （即在树搜索中未找到的对象）将被判定为不再需要，并予以移除。</strong></li>
<li>这里的一个实际含义是，<strong>你通常需要维护一个 <code>UPROPERTY</code> 引用以保持任何你想保留的 Object 存活</strong>，无论它是一个简单的 Object 指针还是包含 Object 指针类型的 Unreal Engine 容器类，例如 <code>TArray&lt;UObject*&gt;</code> 。<strong>Actors 及其 Components 通常是这一规则的例外，因为 Actors 通常被链接回根集的 Object 引用，例如它们所属的 Level，而 Actor 的 Components 则由 Actor 自身引用。可以通过调用 Actors 的 <code>Destroy</code> 函数显式标记它们为销毁状态，这是从进行中的游戏中移除 Actor 的标准方法。Components 可以通过 <code>DestroyComponent</code> 函数显式销毁，但它们通常在其所属的 Actor 从游戏中移除时被销毁。</strong></li>
<li>此外还可调整其他功能来更精确地控制垃圾回收的执行时机与方式，这些设置大多位于项目设置的&quot;<strong>Engine - Garbage Collection</strong>&ldquo;分类下。</li>
</ul>
<h4 id="incremental-garbage-collection-增量垃圾回收">Incremental Garbage Collection 增量垃圾回收<a hidden class="anchor" aria-hidden="true" href="#incremental-garbage-collection-增量垃圾回收">#</a></h4>
<blockquote>
<p>Improved garbage collection system for UObjects.</p></blockquote>
<p>虚幻引擎(UE)采用标记-清除垃圾回收机制来管理 UObject 内存。对于软实时应用而言，垃圾回收器历来存在一个主要缺陷**：在执行可达性分析确定哪些对象内存可回收时，可能导致游戏卡顿。**在 UE 中，这一过程称为可达性分析。**UE 始终要求垃圾回收的这一阶段必须在一帧内完成，期间会暂时停止所有 UObject 处理（尤其是游戏逻辑）。需要扫描的可达对象越多，暂停时间就越长，通常很容易因此引发明显的游戏卡顿。**程序员可通过多种方式规避此问题，例如：</p>
<ul>
<li><strong>严格控制 UObject 数量</strong></li>
<li><strong>使用 UObject 对象池</strong></li>
<li><strong>在常规游戏过程中禁用垃圾回收</strong></li>
</ul>
<blockquote>
<p>UE 通过增量可达性分析对此进行了改进。用户现在能够将垃圾回收器的可达性分析阶段分散到多个帧中完成，并配置每帧的软性时间限制。引擎通过 <code>TObjectPtr</code> 属性跟踪可达性分析迭代间的 UObject 引用。即，在垃圾回收进行期间，任何对 <code>TObjectPtr</code> 暴露的 <code>UPROPERTY</code> 的赋值都会立即将该对象标记为可达。这也被称为垃圾回收写屏障。</p>
<p>引擎已全面改用 <code>TObjectPtr</code> 替代原始 C++指针，所有向垃圾回收器暴露 UObject 的场景（包括 UObject 或 <code>FGCObject</code> <code>AddReferencedObjects</code> 函数）均已适配。要在基于虚幻引擎构建的项目中使用增量可达性分析，必须将所有 <code>UPROPERTY</code> 实例转换为使用 <code>TObjectPtr</code> 而非原始 C++指针，否则垃圾回收可能过早释放某些 UObject 的内存。该功能目前作为实验性功能发布，因为可达性分析阶段仍有可能超出规定的时间限制。</p></blockquote>
<h3 id="properties"><strong>Properties</strong><a hidden class="anchor" aria-hidden="true" href="#properties">#</a></h3>
<h4 id="int类型">Int类型<a hidden class="anchor" aria-hidden="true" href="#int类型">#</a></h4>
<ul>
<li>整数数据类型的命名惯例是 &ldquo;int&rdquo; 或 &ldquo;uint&rdquo; 后跟以位为单位的长度，比如 <code>int32</code>, <code>uint8</code>。</li>
<li>整型属性现在可以作为位掩码暴露给编辑器。要将整型属性标记为位掩码，只需在元数据部分添加&quot;bitmask&rdquo;，如下所示：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*~ BasicBits appears as a list of generic flags in the editor, instead of an integer field. */</span>
</span></span><span class="line"><span class="cl"><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">Bitmask</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">int32</span> <span class="n">BasicBits</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*~ You can set MyFunction using a generic list of flags instead of typing in an integer value. */</span>
</span></span><span class="line"><span class="cl"><span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintCallable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">MyFunction</span><span class="p">(</span><span class="n">UPARAM</span><span class="p">(</span><span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">Bitmask</span><span class="p">))</span> <span class="n">int32</span> <span class="n">BasicBitsParam</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>为了自定义位标志的名称，我们首先需要创建一个带有&quot;bitflags&quot;元标签的 UENUM：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">UENUM</span><span class="p">(</span><span class="n">Meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">Bitflags</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="k">class</span> <span class="nc">EColorBits</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ECB_Red</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ECB_Green</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">ECB_Blue</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*~ This property lists flags matching the names of values from EColorBits. */</span>
</span></span><span class="line"><span class="cl"><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span> <span class="n">Meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">Bitmask</span><span class="p">,</span> <span class="n">BitmaskEnum</span> <span class="o">=</span> <span class="s">&#34;EColorBits&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">int32</span> <span class="n">ColorFlags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*~ MyOtherFunction shows flags named after the values from EColorBits. */</span>
</span></span><span class="line"><span class="cl"><span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintCallable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">MyOtherFunction</span><span class="p">(</span><span class="n">UPARAM</span><span class="p">(</span><span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">Bitmask</span><span class="p">,</span> <span class="n">BitmaskEnum</span> <span class="o">=</span> <span class="s">&#34;EColorBits&#34;</span><span class="p">))</span> <span class="n">int32</span> <span class="n">ColorFlagsParam</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="float类型">Float类型<a hidden class="anchor" aria-hidden="true" href="#float类型">#</a></h4>
<p>Unreal 使用标准的 C++浮点类型，包括 float 和 double。</p>
<h4 id="bool类型">Bool类型<a hidden class="anchor" aria-hidden="true" href="#bool类型">#</a></h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">uint32 bIsHungry : 1;
</span></span><span class="line"><span class="cl">bool bIsThirsty;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="字符串类型">字符串类型<a hidden class="anchor" aria-hidden="true" href="#字符串类型">#</a></h4>
<p>UE支持3种字符串类型：</p>
<ul>
<li><code>FString</code> 类型是一个变长的字符串</li>
<li><code>FName</code>是固定长度的字符串</li>
<li><code>FText</code>更加复杂，是支持本地化的字符串</li>
</ul>
<p>UE的字符类型为<code>TCHAR</code>，可以使用<code>TEXT</code>宏来表示字面量</p>
<h4 id="uproperty属性说明符">UPROPERTY属性说明符<a hidden class="anchor" aria-hidden="true" href="#uproperty属性说明符">#</a></h4>
<ul>
<li>在声明属性时，可以添加属性说明符（Property Specifiers）来控制该属性在引擎和编辑器各个方面的行为表现。</li>
</ul>
<p>详见 <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-uproperties?application_version=5.4">https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-uproperties?application_version=5.4</a></p>
<h4 id="uproperty元数据说明符">UPROPERTY元数据说明符<a hidden class="anchor" aria-hidden="true" href="#uproperty元数据说明符">#</a></h4>
<ul>
<li>
<p>在声明类、接口、结构体、枚举、枚举值、函数或属性时，可以添加元数据说明符以控制它们与引擎及编辑器各部分的交互方式。每种数据结构或成员类型都有其专属的元数据说明符列表。</p>
</li>
<li>
<p>元数据仅存在于编辑器中；不要编写访问元数据的游戏逻辑。</p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://wstfdxfh.github.io/posts/gamedev/oddtanks/">
    <span class="title">Next »</span>
    <br>
    <span>OddTanks</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://wstfdxfh.github.io/">李睿杰的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
